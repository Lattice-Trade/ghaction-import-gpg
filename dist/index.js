require('./sourcemap-register.js');(()=>{var w={351:function(w,O,_){"use strict";var N=this&&this.__createBinding||(Object.create?function(w,O,_,N){if(N===undefined)N=_;var F=Object.getOwnPropertyDescriptor(O,_);if(!F||("get"in F?!O.__esModule:F.writable||F.configurable)){F={enumerable:true,get:function(){return O[_]}}}Object.defineProperty(w,N,F)}:function(w,O,_,N){if(N===undefined)N=_;w[N]=O[_]});var F=this&&this.__setModuleDefault||(Object.create?function(w,O){Object.defineProperty(w,"default",{enumerable:true,value:O})}:function(w,O){w["default"]=O});var H=this&&this.__importStar||function(w){if(w&&w.__esModule)return w;var O={};if(w!=null)for(var _ in w)if(_!=="default"&&Object.prototype.hasOwnProperty.call(w,_))N(O,w,_);F(O,w);return O};Object.defineProperty(O,"__esModule",{value:true});O.issue=O.issueCommand=void 0;const j=H(_(37));const G=_(278);function issueCommand(w,O,_){const N=new Command(w,O,_);process.stdout.write(N.toString()+j.EOL)}O.issueCommand=issueCommand;function issue(w,O=""){issueCommand(w,{},O)}O.issue=issue;const z="::";class Command{constructor(w,O,_){if(!w){w="missing.command"}this.command=w;this.properties=O;this.message=_}toString(){let w=z+this.command;if(this.properties&&Object.keys(this.properties).length>0){w+=" ";let O=true;for(const _ in this.properties){if(this.properties.hasOwnProperty(_)){const N=this.properties[_];if(N){if(O){O=false}else{w+=","}w+=`${_}=${escapeProperty(N)}`}}}}w+=`${z}${escapeData(this.message)}`;return w}}function escapeData(w){return(0,G.toCommandValue)(w).replace(/%/g,"%25").replace(/\r/g,"%0D").replace(/\n/g,"%0A")}function escapeProperty(w){return(0,G.toCommandValue)(w).replace(/%/g,"%25").replace(/\r/g,"%0D").replace(/\n/g,"%0A").replace(/:/g,"%3A").replace(/,/g,"%2C")}},186:function(w,O,_){"use strict";var N=this&&this.__createBinding||(Object.create?function(w,O,_,N){if(N===undefined)N=_;var F=Object.getOwnPropertyDescriptor(O,_);if(!F||("get"in F?!O.__esModule:F.writable||F.configurable)){F={enumerable:true,get:function(){return O[_]}}}Object.defineProperty(w,N,F)}:function(w,O,_,N){if(N===undefined)N=_;w[N]=O[_]});var F=this&&this.__setModuleDefault||(Object.create?function(w,O){Object.defineProperty(w,"default",{enumerable:true,value:O})}:function(w,O){w["default"]=O});var H=this&&this.__importStar||function(w){if(w&&w.__esModule)return w;var O={};if(w!=null)for(var _ in w)if(_!=="default"&&Object.prototype.hasOwnProperty.call(w,_))N(O,w,_);F(O,w);return O};var j=this&&this.__awaiter||function(w,O,_,N){function adopt(w){return w instanceof _?w:new _((function(O){O(w)}))}return new(_||(_=Promise))((function(_,F){function fulfilled(w){try{step(N.next(w))}catch(w){F(w)}}function rejected(w){try{step(N["throw"](w))}catch(w){F(w)}}function step(w){w.done?_(w.value):adopt(w.value).then(fulfilled,rejected)}step((N=N.apply(w,O||[])).next())}))};Object.defineProperty(O,"__esModule",{value:true});O.platform=O.toPlatformPath=O.toWin32Path=O.toPosixPath=O.markdownSummary=O.summary=O.getIDToken=O.getState=O.saveState=O.group=O.endGroup=O.startGroup=O.info=O.notice=O.warning=O.error=O.debug=O.isDebug=O.setFailed=O.setCommandEcho=O.setOutput=O.getBooleanInput=O.getMultilineInput=O.getInput=O.addPath=O.setSecret=O.exportVariable=O.ExitCode=void 0;const G=_(351);const z=_(717);const X=_(278);const ee=H(_(37));const se=H(_(17));const ae=_(41);var Ae;(function(w){w[w["Success"]=0]="Success";w[w["Failure"]=1]="Failure"})(Ae||(O.ExitCode=Ae={}));function exportVariable(w,O){const _=(0,X.toCommandValue)(O);process.env[w]=_;const N=process.env["GITHUB_ENV"]||"";if(N){return(0,z.issueFileCommand)("ENV",(0,z.prepareKeyValueMessage)(w,O))}(0,G.issueCommand)("set-env",{name:w},_)}O.exportVariable=exportVariable;function setSecret(w){(0,G.issueCommand)("add-mask",{},w)}O.setSecret=setSecret;function addPath(w){const O=process.env["GITHUB_PATH"]||"";if(O){(0,z.issueFileCommand)("PATH",w)}else{(0,G.issueCommand)("add-path",{},w)}process.env["PATH"]=`${w}${se.delimiter}${process.env["PATH"]}`}O.addPath=addPath;function getInput(w,O){const _=process.env[`INPUT_${w.replace(/ /g,"_").toUpperCase()}`]||"";if(O&&O.required&&!_){throw new Error(`Input required and not supplied: ${w}`)}if(O&&O.trimWhitespace===false){return _}return _.trim()}O.getInput=getInput;function getMultilineInput(w,O){const _=getInput(w,O).split("\n").filter((w=>w!==""));if(O&&O.trimWhitespace===false){return _}return _.map((w=>w.trim()))}O.getMultilineInput=getMultilineInput;function getBooleanInput(w,O){const _=["true","True","TRUE"];const N=["false","False","FALSE"];const F=getInput(w,O);if(_.includes(F))return true;if(N.includes(F))return false;throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${w}\n`+`Support boolean input list: \`true | True | TRUE | false | False | FALSE\``)}O.getBooleanInput=getBooleanInput;function setOutput(w,O){const _=process.env["GITHUB_OUTPUT"]||"";if(_){return(0,z.issueFileCommand)("OUTPUT",(0,z.prepareKeyValueMessage)(w,O))}process.stdout.write(ee.EOL);(0,G.issueCommand)("set-output",{name:w},(0,X.toCommandValue)(O))}O.setOutput=setOutput;function setCommandEcho(w){(0,G.issue)("echo",w?"on":"off")}O.setCommandEcho=setCommandEcho;function setFailed(w){process.exitCode=Ae.Failure;error(w)}O.setFailed=setFailed;function isDebug(){return process.env["RUNNER_DEBUG"]==="1"}O.isDebug=isDebug;function debug(w){(0,G.issueCommand)("debug",{},w)}O.debug=debug;function error(w,O={}){(0,G.issueCommand)("error",(0,X.toCommandProperties)(O),w instanceof Error?w.toString():w)}O.error=error;function warning(w,O={}){(0,G.issueCommand)("warning",(0,X.toCommandProperties)(O),w instanceof Error?w.toString():w)}O.warning=warning;function notice(w,O={}){(0,G.issueCommand)("notice",(0,X.toCommandProperties)(O),w instanceof Error?w.toString():w)}O.notice=notice;function info(w){process.stdout.write(w+ee.EOL)}O.info=info;function startGroup(w){(0,G.issue)("group",w)}O.startGroup=startGroup;function endGroup(){(0,G.issue)("endgroup")}O.endGroup=endGroup;function group(w,O){return j(this,void 0,void 0,(function*(){startGroup(w);let _;try{_=yield O()}finally{endGroup()}return _}))}O.group=group;function saveState(w,O){const _=process.env["GITHUB_STATE"]||"";if(_){return(0,z.issueFileCommand)("STATE",(0,z.prepareKeyValueMessage)(w,O))}(0,G.issueCommand)("save-state",{name:w},(0,X.toCommandValue)(O))}O.saveState=saveState;function getState(w){return process.env[`STATE_${w}`]||""}O.getState=getState;function getIDToken(w){return j(this,void 0,void 0,(function*(){return yield ae.OidcClient.getIDToken(w)}))}O.getIDToken=getIDToken;var be=_(327);Object.defineProperty(O,"summary",{enumerable:true,get:function(){return be.summary}});var ve=_(327);Object.defineProperty(O,"markdownSummary",{enumerable:true,get:function(){return ve.markdownSummary}});var Se=_(981);Object.defineProperty(O,"toPosixPath",{enumerable:true,get:function(){return Se.toPosixPath}});Object.defineProperty(O,"toWin32Path",{enumerable:true,get:function(){return Se.toWin32Path}});Object.defineProperty(O,"toPlatformPath",{enumerable:true,get:function(){return Se.toPlatformPath}});O.platform=H(_(243))},717:function(w,O,_){"use strict";var N=this&&this.__createBinding||(Object.create?function(w,O,_,N){if(N===undefined)N=_;var F=Object.getOwnPropertyDescriptor(O,_);if(!F||("get"in F?!O.__esModule:F.writable||F.configurable)){F={enumerable:true,get:function(){return O[_]}}}Object.defineProperty(w,N,F)}:function(w,O,_,N){if(N===undefined)N=_;w[N]=O[_]});var F=this&&this.__setModuleDefault||(Object.create?function(w,O){Object.defineProperty(w,"default",{enumerable:true,value:O})}:function(w,O){w["default"]=O});var H=this&&this.__importStar||function(w){if(w&&w.__esModule)return w;var O={};if(w!=null)for(var _ in w)if(_!=="default"&&Object.prototype.hasOwnProperty.call(w,_))N(O,w,_);F(O,w);return O};Object.defineProperty(O,"__esModule",{value:true});O.prepareKeyValueMessage=O.issueFileCommand=void 0;const j=H(_(113));const G=H(_(147));const z=H(_(37));const X=_(278);function issueFileCommand(w,O){const _=process.env[`GITHUB_${w}`];if(!_){throw new Error(`Unable to find environment variable for file command ${w}`)}if(!G.existsSync(_)){throw new Error(`Missing file at path: ${_}`)}G.appendFileSync(_,`${(0,X.toCommandValue)(O)}${z.EOL}`,{encoding:"utf8"})}O.issueFileCommand=issueFileCommand;function prepareKeyValueMessage(w,O){const _=`ghadelimiter_${j.randomUUID()}`;const N=(0,X.toCommandValue)(O);if(w.includes(_)){throw new Error(`Unexpected input: name should not contain the delimiter "${_}"`)}if(N.includes(_)){throw new Error(`Unexpected input: value should not contain the delimiter "${_}"`)}return`${w}<<${_}${z.EOL}${N}${z.EOL}${_}`}O.prepareKeyValueMessage=prepareKeyValueMessage},41:function(w,O,_){"use strict";var N=this&&this.__awaiter||function(w,O,_,N){function adopt(w){return w instanceof _?w:new _((function(O){O(w)}))}return new(_||(_=Promise))((function(_,F){function fulfilled(w){try{step(N.next(w))}catch(w){F(w)}}function rejected(w){try{step(N["throw"](w))}catch(w){F(w)}}function step(w){w.done?_(w.value):adopt(w.value).then(fulfilled,rejected)}step((N=N.apply(w,O||[])).next())}))};Object.defineProperty(O,"__esModule",{value:true});O.OidcClient=void 0;const F=_(255);const H=_(526);const j=_(186);class OidcClient{static createHttpClient(w=true,O=10){const _={allowRetries:w,maxRetries:O};return new F.HttpClient("actions/oidc-client",[new H.BearerCredentialHandler(OidcClient.getRequestToken())],_)}static getRequestToken(){const w=process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];if(!w){throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable")}return w}static getIDTokenUrl(){const w=process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];if(!w){throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable")}return w}static getCall(w){var O;return N(this,void 0,void 0,(function*(){const _=OidcClient.createHttpClient();const N=yield _.getJson(w).catch((w=>{throw new Error(`Failed to get ID Token. \n \n        Error Code : ${w.statusCode}\n \n        Error Message: ${w.message}`)}));const F=(O=N.result)===null||O===void 0?void 0:O.value;if(!F){throw new Error("Response json body do not have ID Token field")}return F}))}static getIDToken(w){return N(this,void 0,void 0,(function*(){try{let O=OidcClient.getIDTokenUrl();if(w){const _=encodeURIComponent(w);O=`${O}&audience=${_}`}(0,j.debug)(`ID token url is ${O}`);const _=yield OidcClient.getCall(O);(0,j.setSecret)(_);return _}catch(w){throw new Error(`Error message: ${w.message}`)}}))}}O.OidcClient=OidcClient},981:function(w,O,_){"use strict";var N=this&&this.__createBinding||(Object.create?function(w,O,_,N){if(N===undefined)N=_;var F=Object.getOwnPropertyDescriptor(O,_);if(!F||("get"in F?!O.__esModule:F.writable||F.configurable)){F={enumerable:true,get:function(){return O[_]}}}Object.defineProperty(w,N,F)}:function(w,O,_,N){if(N===undefined)N=_;w[N]=O[_]});var F=this&&this.__setModuleDefault||(Object.create?function(w,O){Object.defineProperty(w,"default",{enumerable:true,value:O})}:function(w,O){w["default"]=O});var H=this&&this.__importStar||function(w){if(w&&w.__esModule)return w;var O={};if(w!=null)for(var _ in w)if(_!=="default"&&Object.prototype.hasOwnProperty.call(w,_))N(O,w,_);F(O,w);return O};Object.defineProperty(O,"__esModule",{value:true});O.toPlatformPath=O.toWin32Path=O.toPosixPath=void 0;const j=H(_(17));function toPosixPath(w){return w.replace(/[\\]/g,"/")}O.toPosixPath=toPosixPath;function toWin32Path(w){return w.replace(/[/]/g,"\\")}O.toWin32Path=toWin32Path;function toPlatformPath(w){return w.replace(/[/\\]/g,j.sep)}O.toPlatformPath=toPlatformPath},243:function(w,O,_){"use strict";var N=this&&this.__createBinding||(Object.create?function(w,O,_,N){if(N===undefined)N=_;var F=Object.getOwnPropertyDescriptor(O,_);if(!F||("get"in F?!O.__esModule:F.writable||F.configurable)){F={enumerable:true,get:function(){return O[_]}}}Object.defineProperty(w,N,F)}:function(w,O,_,N){if(N===undefined)N=_;w[N]=O[_]});var F=this&&this.__setModuleDefault||(Object.create?function(w,O){Object.defineProperty(w,"default",{enumerable:true,value:O})}:function(w,O){w["default"]=O});var H=this&&this.__importStar||function(w){if(w&&w.__esModule)return w;var O={};if(w!=null)for(var _ in w)if(_!=="default"&&Object.prototype.hasOwnProperty.call(w,_))N(O,w,_);F(O,w);return O};var j=this&&this.__awaiter||function(w,O,_,N){function adopt(w){return w instanceof _?w:new _((function(O){O(w)}))}return new(_||(_=Promise))((function(_,F){function fulfilled(w){try{step(N.next(w))}catch(w){F(w)}}function rejected(w){try{step(N["throw"](w))}catch(w){F(w)}}function step(w){w.done?_(w.value):adopt(w.value).then(fulfilled,rejected)}step((N=N.apply(w,O||[])).next())}))};var G=this&&this.__importDefault||function(w){return w&&w.__esModule?w:{default:w}};Object.defineProperty(O,"__esModule",{value:true});O.getDetails=O.isLinux=O.isMacOS=O.isWindows=O.arch=O.platform=void 0;const z=G(_(37));const X=H(_(514));const getWindowsInfo=()=>j(void 0,void 0,void 0,(function*(){const{stdout:w}=yield X.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"',undefined,{silent:true});const{stdout:O}=yield X.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"',undefined,{silent:true});return{name:O.trim(),version:w.trim()}}));const getMacOsInfo=()=>j(void 0,void 0,void 0,(function*(){var w,O,_,N;const{stdout:F}=yield X.getExecOutput("sw_vers",undefined,{silent:true});const H=(O=(w=F.match(/ProductVersion:\s*(.+)/))===null||w===void 0?void 0:w[1])!==null&&O!==void 0?O:"";const j=(N=(_=F.match(/ProductName:\s*(.+)/))===null||_===void 0?void 0:_[1])!==null&&N!==void 0?N:"";return{name:j,version:H}}));const getLinuxInfo=()=>j(void 0,void 0,void 0,(function*(){const{stdout:w}=yield X.getExecOutput("lsb_release",["-i","-r","-s"],{silent:true});const[O,_]=w.trim().split("\n");return{name:O,version:_}}));O.platform=z.default.platform();O.arch=z.default.arch();O.isWindows=O.platform==="win32";O.isMacOS=O.platform==="darwin";O.isLinux=O.platform==="linux";function getDetails(){return j(this,void 0,void 0,(function*(){return Object.assign(Object.assign({},yield O.isWindows?getWindowsInfo():O.isMacOS?getMacOsInfo():getLinuxInfo()),{platform:O.platform,arch:O.arch,isWindows:O.isWindows,isMacOS:O.isMacOS,isLinux:O.isLinux})}))}O.getDetails=getDetails},327:function(w,O,_){"use strict";var N=this&&this.__awaiter||function(w,O,_,N){function adopt(w){return w instanceof _?w:new _((function(O){O(w)}))}return new(_||(_=Promise))((function(_,F){function fulfilled(w){try{step(N.next(w))}catch(w){F(w)}}function rejected(w){try{step(N["throw"](w))}catch(w){F(w)}}function step(w){w.done?_(w.value):adopt(w.value).then(fulfilled,rejected)}step((N=N.apply(w,O||[])).next())}))};Object.defineProperty(O,"__esModule",{value:true});O.summary=O.markdownSummary=O.SUMMARY_DOCS_URL=O.SUMMARY_ENV_VAR=void 0;const F=_(37);const H=_(147);const{access:j,appendFile:G,writeFile:z}=H.promises;O.SUMMARY_ENV_VAR="GITHUB_STEP_SUMMARY";O.SUMMARY_DOCS_URL="https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";class Summary{constructor(){this._buffer=""}filePath(){return N(this,void 0,void 0,(function*(){if(this._filePath){return this._filePath}const w=process.env[O.SUMMARY_ENV_VAR];if(!w){throw new Error(`Unable to find environment variable for $${O.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`)}try{yield j(w,H.constants.R_OK|H.constants.W_OK)}catch(O){throw new Error(`Unable to access summary file: '${w}'. Check if the file has correct read/write permissions.`)}this._filePath=w;return this._filePath}))}wrap(w,O,_={}){const N=Object.entries(_).map((([w,O])=>` ${w}="${O}"`)).join("");if(!O){return`<${w}${N}>`}return`<${w}${N}>${O}</${w}>`}write(w){return N(this,void 0,void 0,(function*(){const O=!!(w===null||w===void 0?void 0:w.overwrite);const _=yield this.filePath();const N=O?z:G;yield N(_,this._buffer,{encoding:"utf8"});return this.emptyBuffer()}))}clear(){return N(this,void 0,void 0,(function*(){return this.emptyBuffer().write({overwrite:true})}))}stringify(){return this._buffer}isEmptyBuffer(){return this._buffer.length===0}emptyBuffer(){this._buffer="";return this}addRaw(w,O=false){this._buffer+=w;return O?this.addEOL():this}addEOL(){return this.addRaw(F.EOL)}addCodeBlock(w,O){const _=Object.assign({},O&&{lang:O});const N=this.wrap("pre",this.wrap("code",w),_);return this.addRaw(N).addEOL()}addList(w,O=false){const _=O?"ol":"ul";const N=w.map((w=>this.wrap("li",w))).join("");const F=this.wrap(_,N);return this.addRaw(F).addEOL()}addTable(w){const O=w.map((w=>{const O=w.map((w=>{if(typeof w==="string"){return this.wrap("td",w)}const{header:O,data:_,colspan:N,rowspan:F}=w;const H=O?"th":"td";const j=Object.assign(Object.assign({},N&&{colspan:N}),F&&{rowspan:F});return this.wrap(H,_,j)})).join("");return this.wrap("tr",O)})).join("");const _=this.wrap("table",O);return this.addRaw(_).addEOL()}addDetails(w,O){const _=this.wrap("details",this.wrap("summary",w)+O);return this.addRaw(_).addEOL()}addImage(w,O,_){const{width:N,height:F}=_||{};const H=Object.assign(Object.assign({},N&&{width:N}),F&&{height:F});const j=this.wrap("img",null,Object.assign({src:w,alt:O},H));return this.addRaw(j).addEOL()}addHeading(w,O){const _=`h${O}`;const N=["h1","h2","h3","h4","h5","h6"].includes(_)?_:"h1";const F=this.wrap(N,w);return this.addRaw(F).addEOL()}addSeparator(){const w=this.wrap("hr",null);return this.addRaw(w).addEOL()}addBreak(){const w=this.wrap("br",null);return this.addRaw(w).addEOL()}addQuote(w,O){const _=Object.assign({},O&&{cite:O});const N=this.wrap("blockquote",w,_);return this.addRaw(N).addEOL()}addLink(w,O){const _=this.wrap("a",w,{href:O});return this.addRaw(_).addEOL()}}const X=new Summary;O.markdownSummary=X;O.summary=X},278:(w,O)=>{"use strict";Object.defineProperty(O,"__esModule",{value:true});O.toCommandProperties=O.toCommandValue=void 0;function toCommandValue(w){if(w===null||w===undefined){return""}else if(typeof w==="string"||w instanceof String){return w}return JSON.stringify(w)}O.toCommandValue=toCommandValue;function toCommandProperties(w){if(!Object.keys(w).length){return{}}return{title:w.title,file:w.file,line:w.startLine,endLine:w.endLine,col:w.startColumn,endColumn:w.endColumn}}O.toCommandProperties=toCommandProperties},514:function(w,O,_){"use strict";var N=this&&this.__createBinding||(Object.create?function(w,O,_,N){if(N===undefined)N=_;Object.defineProperty(w,N,{enumerable:true,get:function(){return O[_]}})}:function(w,O,_,N){if(N===undefined)N=_;w[N]=O[_]});var F=this&&this.__setModuleDefault||(Object.create?function(w,O){Object.defineProperty(w,"default",{enumerable:true,value:O})}:function(w,O){w["default"]=O});var H=this&&this.__importStar||function(w){if(w&&w.__esModule)return w;var O={};if(w!=null)for(var _ in w)if(_!=="default"&&Object.hasOwnProperty.call(w,_))N(O,w,_);F(O,w);return O};var j=this&&this.__awaiter||function(w,O,_,N){function adopt(w){return w instanceof _?w:new _((function(O){O(w)}))}return new(_||(_=Promise))((function(_,F){function fulfilled(w){try{step(N.next(w))}catch(w){F(w)}}function rejected(w){try{step(N["throw"](w))}catch(w){F(w)}}function step(w){w.done?_(w.value):adopt(w.value).then(fulfilled,rejected)}step((N=N.apply(w,O||[])).next())}))};Object.defineProperty(O,"__esModule",{value:true});O.getExecOutput=O.exec=void 0;const G=_(576);const z=H(_(159));function exec(w,O,_){return j(this,void 0,void 0,(function*(){const N=z.argStringToArray(w);if(N.length===0){throw new Error(`Parameter 'commandLine' cannot be null or empty.`)}const F=N[0];O=N.slice(1).concat(O||[]);const H=new z.ToolRunner(F,O,_);return H.exec()}))}O.exec=exec;function getExecOutput(w,O,_){var N,F;return j(this,void 0,void 0,(function*(){let H="";let j="";const z=new G.StringDecoder("utf8");const X=new G.StringDecoder("utf8");const ee=(N=_===null||_===void 0?void 0:_.listeners)===null||N===void 0?void 0:N.stdout;const se=(F=_===null||_===void 0?void 0:_.listeners)===null||F===void 0?void 0:F.stderr;const stdErrListener=w=>{j+=X.write(w);if(se){se(w)}};const stdOutListener=w=>{H+=z.write(w);if(ee){ee(w)}};const ae=Object.assign(Object.assign({},_===null||_===void 0?void 0:_.listeners),{stdout:stdOutListener,stderr:stdErrListener});const Ae=yield exec(w,O,Object.assign(Object.assign({},_),{listeners:ae}));H+=z.end();j+=X.end();return{exitCode:Ae,stdout:H,stderr:j}}))}O.getExecOutput=getExecOutput},159:function(w,O,_){"use strict";var N=this&&this.__createBinding||(Object.create?function(w,O,_,N){if(N===undefined)N=_;Object.defineProperty(w,N,{enumerable:true,get:function(){return O[_]}})}:function(w,O,_,N){if(N===undefined)N=_;w[N]=O[_]});var F=this&&this.__setModuleDefault||(Object.create?function(w,O){Object.defineProperty(w,"default",{enumerable:true,value:O})}:function(w,O){w["default"]=O});var H=this&&this.__importStar||function(w){if(w&&w.__esModule)return w;var O={};if(w!=null)for(var _ in w)if(_!=="default"&&Object.hasOwnProperty.call(w,_))N(O,w,_);F(O,w);return O};var j=this&&this.__awaiter||function(w,O,_,N){function adopt(w){return w instanceof _?w:new _((function(O){O(w)}))}return new(_||(_=Promise))((function(_,F){function fulfilled(w){try{step(N.next(w))}catch(w){F(w)}}function rejected(w){try{step(N["throw"](w))}catch(w){F(w)}}function step(w){w.done?_(w.value):adopt(w.value).then(fulfilled,rejected)}step((N=N.apply(w,O||[])).next())}))};Object.defineProperty(O,"__esModule",{value:true});O.argStringToArray=O.ToolRunner=void 0;const G=H(_(37));const z=H(_(361));const X=H(_(81));const ee=H(_(17));const se=H(_(436));const ae=H(_(962));const Ae=_(512);const be=process.platform==="win32";class ToolRunner extends z.EventEmitter{constructor(w,O,_){super();if(!w){throw new Error("Parameter 'toolPath' cannot be null or empty.")}this.toolPath=w;this.args=O||[];this.options=_||{}}_debug(w){if(this.options.listeners&&this.options.listeners.debug){this.options.listeners.debug(w)}}_getCommandString(w,O){const _=this._getSpawnFileName();const N=this._getSpawnArgs(w);let F=O?"":"[command]";if(be){if(this._isCmdFile()){F+=_;for(const w of N){F+=` ${w}`}}else if(w.windowsVerbatimArguments){F+=`"${_}"`;for(const w of N){F+=` ${w}`}}else{F+=this._windowsQuoteCmdArg(_);for(const w of N){F+=` ${this._windowsQuoteCmdArg(w)}`}}}else{F+=_;for(const w of N){F+=` ${w}`}}return F}_processLineBuffer(w,O,_){try{let N=O+w.toString();let F=N.indexOf(G.EOL);while(F>-1){const w=N.substring(0,F);_(w);N=N.substring(F+G.EOL.length);F=N.indexOf(G.EOL)}return N}catch(w){this._debug(`error processing line. Failed with error ${w}`);return""}}_getSpawnFileName(){if(be){if(this._isCmdFile()){return process.env["COMSPEC"]||"cmd.exe"}}return this.toolPath}_getSpawnArgs(w){if(be){if(this._isCmdFile()){let O=`/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;for(const _ of this.args){O+=" ";O+=w.windowsVerbatimArguments?_:this._windowsQuoteCmdArg(_)}O+='"';return[O]}}return this.args}_endsWith(w,O){return w.endsWith(O)}_isCmdFile(){const w=this.toolPath.toUpperCase();return this._endsWith(w,".CMD")||this._endsWith(w,".BAT")}_windowsQuoteCmdArg(w){if(!this._isCmdFile()){return this._uvQuoteCmdArg(w)}if(!w){return'""'}const O=[" ","\t","&","(",")","[","]","{","}","^","=",";","!","'","+",",","`","~","|","<",">",'"'];let _=false;for(const N of w){if(O.some((w=>w===N))){_=true;break}}if(!_){return w}let N='"';let F=true;for(let O=w.length;O>0;O--){N+=w[O-1];if(F&&w[O-1]==="\\"){N+="\\"}else if(w[O-1]==='"'){F=true;N+='"'}else{F=false}}N+='"';return N.split("").reverse().join("")}_uvQuoteCmdArg(w){if(!w){return'""'}if(!w.includes(" ")&&!w.includes("\t")&&!w.includes('"')){return w}if(!w.includes('"')&&!w.includes("\\")){return`"${w}"`}let O='"';let _=true;for(let N=w.length;N>0;N--){O+=w[N-1];if(_&&w[N-1]==="\\"){O+="\\"}else if(w[N-1]==='"'){_=true;O+="\\"}else{_=false}}O+='"';return O.split("").reverse().join("")}_cloneExecOptions(w){w=w||{};const O={cwd:w.cwd||process.cwd(),env:w.env||process.env,silent:w.silent||false,windowsVerbatimArguments:w.windowsVerbatimArguments||false,failOnStdErr:w.failOnStdErr||false,ignoreReturnCode:w.ignoreReturnCode||false,delay:w.delay||1e4};O.outStream=w.outStream||process.stdout;O.errStream=w.errStream||process.stderr;return O}_getSpawnOptions(w,O){w=w||{};const _={};_.cwd=w.cwd;_.env=w.env;_["windowsVerbatimArguments"]=w.windowsVerbatimArguments||this._isCmdFile();if(w.windowsVerbatimArguments){_.argv0=`"${O}"`}return _}exec(){return j(this,void 0,void 0,(function*(){if(!ae.isRooted(this.toolPath)&&(this.toolPath.includes("/")||be&&this.toolPath.includes("\\"))){this.toolPath=ee.resolve(process.cwd(),this.options.cwd||process.cwd(),this.toolPath)}this.toolPath=yield se.which(this.toolPath,true);return new Promise(((w,O)=>j(this,void 0,void 0,(function*(){this._debug(`exec tool: ${this.toolPath}`);this._debug("arguments:");for(const w of this.args){this._debug(`   ${w}`)}const _=this._cloneExecOptions(this.options);if(!_.silent&&_.outStream){_.outStream.write(this._getCommandString(_)+G.EOL)}const N=new ExecState(_,this.toolPath);N.on("debug",(w=>{this._debug(w)}));if(this.options.cwd&&!(yield ae.exists(this.options.cwd))){return O(new Error(`The cwd: ${this.options.cwd} does not exist!`))}const F=this._getSpawnFileName();const H=X.spawn(F,this._getSpawnArgs(_),this._getSpawnOptions(this.options,F));let j="";if(H.stdout){H.stdout.on("data",(w=>{if(this.options.listeners&&this.options.listeners.stdout){this.options.listeners.stdout(w)}if(!_.silent&&_.outStream){_.outStream.write(w)}j=this._processLineBuffer(w,j,(w=>{if(this.options.listeners&&this.options.listeners.stdline){this.options.listeners.stdline(w)}}))}))}let z="";if(H.stderr){H.stderr.on("data",(w=>{N.processStderr=true;if(this.options.listeners&&this.options.listeners.stderr){this.options.listeners.stderr(w)}if(!_.silent&&_.errStream&&_.outStream){const O=_.failOnStdErr?_.errStream:_.outStream;O.write(w)}z=this._processLineBuffer(w,z,(w=>{if(this.options.listeners&&this.options.listeners.errline){this.options.listeners.errline(w)}}))}))}H.on("error",(w=>{N.processError=w.message;N.processExited=true;N.processClosed=true;N.CheckComplete()}));H.on("exit",(w=>{N.processExitCode=w;N.processExited=true;this._debug(`Exit code ${w} received from tool '${this.toolPath}'`);N.CheckComplete()}));H.on("close",(w=>{N.processExitCode=w;N.processExited=true;N.processClosed=true;this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);N.CheckComplete()}));N.on("done",((_,N)=>{if(j.length>0){this.emit("stdline",j)}if(z.length>0){this.emit("errline",z)}H.removeAllListeners();if(_){O(_)}else{w(N)}}));if(this.options.input){if(!H.stdin){throw new Error("child process missing stdin")}H.stdin.end(this.options.input)}}))))}))}}O.ToolRunner=ToolRunner;function argStringToArray(w){const O=[];let _=false;let N=false;let F="";function append(w){if(N&&w!=='"'){F+="\\"}F+=w;N=false}for(let H=0;H<w.length;H++){const j=w.charAt(H);if(j==='"'){if(!N){_=!_}else{append(j)}continue}if(j==="\\"&&N){append(j);continue}if(j==="\\"&&_){N=true;continue}if(j===" "&&!_){if(F.length>0){O.push(F);F=""}continue}append(j)}if(F.length>0){O.push(F.trim())}return O}O.argStringToArray=argStringToArray;class ExecState extends z.EventEmitter{constructor(w,O){super();this.processClosed=false;this.processError="";this.processExitCode=0;this.processExited=false;this.processStderr=false;this.delay=1e4;this.done=false;this.timeout=null;if(!O){throw new Error("toolPath must not be empty")}this.options=w;this.toolPath=O;if(w.delay){this.delay=w.delay}}CheckComplete(){if(this.done){return}if(this.processClosed){this._setResult()}else if(this.processExited){this.timeout=Ae.setTimeout(ExecState.HandleTimeout,this.delay,this)}}_debug(w){this.emit("debug",w)}_setResult(){let w;if(this.processExited){if(this.processError){w=new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`)}else if(this.processExitCode!==0&&!this.options.ignoreReturnCode){w=new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`)}else if(this.processStderr&&this.options.failOnStdErr){w=new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`)}}if(this.timeout){clearTimeout(this.timeout);this.timeout=null}this.done=true;this.emit("done",w,this.processExitCode)}static HandleTimeout(w){if(w.done){return}if(!w.processClosed&&w.processExited){const O=`The STDIO streams did not close within ${w.delay/1e3} seconds of the exit event from process '${w.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;w._debug(O)}w._setResult()}}},526:function(w,O){"use strict";var _=this&&this.__awaiter||function(w,O,_,N){function adopt(w){return w instanceof _?w:new _((function(O){O(w)}))}return new(_||(_=Promise))((function(_,F){function fulfilled(w){try{step(N.next(w))}catch(w){F(w)}}function rejected(w){try{step(N["throw"](w))}catch(w){F(w)}}function step(w){w.done?_(w.value):adopt(w.value).then(fulfilled,rejected)}step((N=N.apply(w,O||[])).next())}))};Object.defineProperty(O,"__esModule",{value:true});O.PersonalAccessTokenCredentialHandler=O.BearerCredentialHandler=O.BasicCredentialHandler=void 0;class BasicCredentialHandler{constructor(w,O){this.username=w;this.password=O}prepareRequest(w){if(!w.headers){throw Error("The request has no headers")}w.headers["Authorization"]=`Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`}canHandleAuthentication(){return false}handleAuthentication(){return _(this,void 0,void 0,(function*(){throw new Error("not implemented")}))}}O.BasicCredentialHandler=BasicCredentialHandler;class BearerCredentialHandler{constructor(w){this.token=w}prepareRequest(w){if(!w.headers){throw Error("The request has no headers")}w.headers["Authorization"]=`Bearer ${this.token}`}canHandleAuthentication(){return false}handleAuthentication(){return _(this,void 0,void 0,(function*(){throw new Error("not implemented")}))}}O.BearerCredentialHandler=BearerCredentialHandler;class PersonalAccessTokenCredentialHandler{constructor(w){this.token=w}prepareRequest(w){if(!w.headers){throw Error("The request has no headers")}w.headers["Authorization"]=`Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`}canHandleAuthentication(){return false}handleAuthentication(){return _(this,void 0,void 0,(function*(){throw new Error("not implemented")}))}}O.PersonalAccessTokenCredentialHandler=PersonalAccessTokenCredentialHandler},255:function(w,O,_){"use strict";var N=this&&this.__createBinding||(Object.create?function(w,O,_,N){if(N===undefined)N=_;Object.defineProperty(w,N,{enumerable:true,get:function(){return O[_]}})}:function(w,O,_,N){if(N===undefined)N=_;w[N]=O[_]});var F=this&&this.__setModuleDefault||(Object.create?function(w,O){Object.defineProperty(w,"default",{enumerable:true,value:O})}:function(w,O){w["default"]=O});var H=this&&this.__importStar||function(w){if(w&&w.__esModule)return w;var O={};if(w!=null)for(var _ in w)if(_!=="default"&&Object.hasOwnProperty.call(w,_))N(O,w,_);F(O,w);return O};var j=this&&this.__awaiter||function(w,O,_,N){function adopt(w){return w instanceof _?w:new _((function(O){O(w)}))}return new(_||(_=Promise))((function(_,F){function fulfilled(w){try{step(N.next(w))}catch(w){F(w)}}function rejected(w){try{step(N["throw"](w))}catch(w){F(w)}}function step(w){w.done?_(w.value):adopt(w.value).then(fulfilled,rejected)}step((N=N.apply(w,O||[])).next())}))};Object.defineProperty(O,"__esModule",{value:true});O.HttpClient=O.isHttps=O.HttpClientResponse=O.HttpClientError=O.getProxyUrl=O.MediaTypes=O.Headers=O.HttpCodes=void 0;const G=H(_(685));const z=H(_(687));const X=H(_(835));const ee=H(_(294));var se;(function(w){w[w["OK"]=200]="OK";w[w["MultipleChoices"]=300]="MultipleChoices";w[w["MovedPermanently"]=301]="MovedPermanently";w[w["ResourceMoved"]=302]="ResourceMoved";w[w["SeeOther"]=303]="SeeOther";w[w["NotModified"]=304]="NotModified";w[w["UseProxy"]=305]="UseProxy";w[w["SwitchProxy"]=306]="SwitchProxy";w[w["TemporaryRedirect"]=307]="TemporaryRedirect";w[w["PermanentRedirect"]=308]="PermanentRedirect";w[w["BadRequest"]=400]="BadRequest";w[w["Unauthorized"]=401]="Unauthorized";w[w["PaymentRequired"]=402]="PaymentRequired";w[w["Forbidden"]=403]="Forbidden";w[w["NotFound"]=404]="NotFound";w[w["MethodNotAllowed"]=405]="MethodNotAllowed";w[w["NotAcceptable"]=406]="NotAcceptable";w[w["ProxyAuthenticationRequired"]=407]="ProxyAuthenticationRequired";w[w["RequestTimeout"]=408]="RequestTimeout";w[w["Conflict"]=409]="Conflict";w[w["Gone"]=410]="Gone";w[w["TooManyRequests"]=429]="TooManyRequests";w[w["InternalServerError"]=500]="InternalServerError";w[w["NotImplemented"]=501]="NotImplemented";w[w["BadGateway"]=502]="BadGateway";w[w["ServiceUnavailable"]=503]="ServiceUnavailable";w[w["GatewayTimeout"]=504]="GatewayTimeout"})(se=O.HttpCodes||(O.HttpCodes={}));var ae;(function(w){w["Accept"]="accept";w["ContentType"]="content-type"})(ae=O.Headers||(O.Headers={}));var Ae;(function(w){w["ApplicationJson"]="application/json"})(Ae=O.MediaTypes||(O.MediaTypes={}));function getProxyUrl(w){const O=X.getProxyUrl(new URL(w));return O?O.href:""}O.getProxyUrl=getProxyUrl;const be=[se.MovedPermanently,se.ResourceMoved,se.SeeOther,se.TemporaryRedirect,se.PermanentRedirect];const ve=[se.BadGateway,se.ServiceUnavailable,se.GatewayTimeout];const Se=["OPTIONS","GET","DELETE","HEAD"];const Ie=10;const Be=5;class HttpClientError extends Error{constructor(w,O){super(w);this.name="HttpClientError";this.statusCode=O;Object.setPrototypeOf(this,HttpClientError.prototype)}}O.HttpClientError=HttpClientError;class HttpClientResponse{constructor(w){this.message=w}readBody(){return j(this,void 0,void 0,(function*(){return new Promise((w=>j(this,void 0,void 0,(function*(){let O=Buffer.alloc(0);this.message.on("data",(w=>{O=Buffer.concat([O,w])}));this.message.on("end",(()=>{w(O.toString())}))}))))}))}}O.HttpClientResponse=HttpClientResponse;function isHttps(w){const O=new URL(w);return O.protocol==="https:"}O.isHttps=isHttps;class HttpClient{constructor(w,O,_){this._ignoreSslError=false;this._allowRedirects=true;this._allowRedirectDowngrade=false;this._maxRedirects=50;this._allowRetries=false;this._maxRetries=1;this._keepAlive=false;this._disposed=false;this.userAgent=w;this.handlers=O||[];this.requestOptions=_;if(_){if(_.ignoreSslError!=null){this._ignoreSslError=_.ignoreSslError}this._socketTimeout=_.socketTimeout;if(_.allowRedirects!=null){this._allowRedirects=_.allowRedirects}if(_.allowRedirectDowngrade!=null){this._allowRedirectDowngrade=_.allowRedirectDowngrade}if(_.maxRedirects!=null){this._maxRedirects=Math.max(_.maxRedirects,0)}if(_.keepAlive!=null){this._keepAlive=_.keepAlive}if(_.allowRetries!=null){this._allowRetries=_.allowRetries}if(_.maxRetries!=null){this._maxRetries=_.maxRetries}}}options(w,O){return j(this,void 0,void 0,(function*(){return this.request("OPTIONS",w,null,O||{})}))}get(w,O){return j(this,void 0,void 0,(function*(){return this.request("GET",w,null,O||{})}))}del(w,O){return j(this,void 0,void 0,(function*(){return this.request("DELETE",w,null,O||{})}))}post(w,O,_){return j(this,void 0,void 0,(function*(){return this.request("POST",w,O,_||{})}))}patch(w,O,_){return j(this,void 0,void 0,(function*(){return this.request("PATCH",w,O,_||{})}))}put(w,O,_){return j(this,void 0,void 0,(function*(){return this.request("PUT",w,O,_||{})}))}head(w,O){return j(this,void 0,void 0,(function*(){return this.request("HEAD",w,null,O||{})}))}sendStream(w,O,_,N){return j(this,void 0,void 0,(function*(){return this.request(w,O,_,N)}))}getJson(w,O={}){return j(this,void 0,void 0,(function*(){O[ae.Accept]=this._getExistingOrDefaultHeader(O,ae.Accept,Ae.ApplicationJson);const _=yield this.get(w,O);return this._processResponse(_,this.requestOptions)}))}postJson(w,O,_={}){return j(this,void 0,void 0,(function*(){const N=JSON.stringify(O,null,2);_[ae.Accept]=this._getExistingOrDefaultHeader(_,ae.Accept,Ae.ApplicationJson);_[ae.ContentType]=this._getExistingOrDefaultHeader(_,ae.ContentType,Ae.ApplicationJson);const F=yield this.post(w,N,_);return this._processResponse(F,this.requestOptions)}))}putJson(w,O,_={}){return j(this,void 0,void 0,(function*(){const N=JSON.stringify(O,null,2);_[ae.Accept]=this._getExistingOrDefaultHeader(_,ae.Accept,Ae.ApplicationJson);_[ae.ContentType]=this._getExistingOrDefaultHeader(_,ae.ContentType,Ae.ApplicationJson);const F=yield this.put(w,N,_);return this._processResponse(F,this.requestOptions)}))}patchJson(w,O,_={}){return j(this,void 0,void 0,(function*(){const N=JSON.stringify(O,null,2);_[ae.Accept]=this._getExistingOrDefaultHeader(_,ae.Accept,Ae.ApplicationJson);_[ae.ContentType]=this._getExistingOrDefaultHeader(_,ae.ContentType,Ae.ApplicationJson);const F=yield this.patch(w,N,_);return this._processResponse(F,this.requestOptions)}))}request(w,O,_,N){return j(this,void 0,void 0,(function*(){if(this._disposed){throw new Error("Client has already been disposed.")}const F=new URL(O);let H=this._prepareRequest(w,F,N);const j=this._allowRetries&&Se.includes(w)?this._maxRetries+1:1;let G=0;let z;do{z=yield this.requestRaw(H,_);if(z&&z.message&&z.message.statusCode===se.Unauthorized){let w;for(const O of this.handlers){if(O.canHandleAuthentication(z)){w=O;break}}if(w){return w.handleAuthentication(this,H,_)}else{return z}}let O=this._maxRedirects;while(z.message.statusCode&&be.includes(z.message.statusCode)&&this._allowRedirects&&O>0){const j=z.message.headers["location"];if(!j){break}const G=new URL(j);if(F.protocol==="https:"&&F.protocol!==G.protocol&&!this._allowRedirectDowngrade){throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.")}yield z.readBody();if(G.hostname!==F.hostname){for(const w in N){if(w.toLowerCase()==="authorization"){delete N[w]}}}H=this._prepareRequest(w,G,N);z=yield this.requestRaw(H,_);O--}if(!z.message.statusCode||!ve.includes(z.message.statusCode)){return z}G+=1;if(G<j){yield z.readBody();yield this._performExponentialBackoff(G)}}while(G<j);return z}))}dispose(){if(this._agent){this._agent.destroy()}this._disposed=true}requestRaw(w,O){return j(this,void 0,void 0,(function*(){return new Promise(((_,N)=>{function callbackForResult(w,O){if(w){N(w)}else if(!O){N(new Error("Unknown error"))}else{_(O)}}this.requestRawWithCallback(w,O,callbackForResult)}))}))}requestRawWithCallback(w,O,_){if(typeof O==="string"){if(!w.options.headers){w.options.headers={}}w.options.headers["Content-Length"]=Buffer.byteLength(O,"utf8")}let N=false;function handleResult(w,O){if(!N){N=true;_(w,O)}}const F=w.httpModule.request(w.options,(w=>{const O=new HttpClientResponse(w);handleResult(undefined,O)}));let H;F.on("socket",(w=>{H=w}));F.setTimeout(this._socketTimeout||3*6e4,(()=>{if(H){H.end()}handleResult(new Error(`Request timeout: ${w.options.path}`))}));F.on("error",(function(w){handleResult(w)}));if(O&&typeof O==="string"){F.write(O,"utf8")}if(O&&typeof O!=="string"){O.on("close",(function(){F.end()}));O.pipe(F)}else{F.end()}}getAgent(w){const O=new URL(w);return this._getAgent(O)}_prepareRequest(w,O,_){const N={};N.parsedUrl=O;const F=N.parsedUrl.protocol==="https:";N.httpModule=F?z:G;const H=F?443:80;N.options={};N.options.host=N.parsedUrl.hostname;N.options.port=N.parsedUrl.port?parseInt(N.parsedUrl.port):H;N.options.path=(N.parsedUrl.pathname||"")+(N.parsedUrl.search||"");N.options.method=w;N.options.headers=this._mergeHeaders(_);if(this.userAgent!=null){N.options.headers["user-agent"]=this.userAgent}N.options.agent=this._getAgent(N.parsedUrl);if(this.handlers){for(const w of this.handlers){w.prepareRequest(N.options)}}return N}_mergeHeaders(w){if(this.requestOptions&&this.requestOptions.headers){return Object.assign({},lowercaseKeys(this.requestOptions.headers),lowercaseKeys(w||{}))}return lowercaseKeys(w||{})}_getExistingOrDefaultHeader(w,O,_){let N;if(this.requestOptions&&this.requestOptions.headers){N=lowercaseKeys(this.requestOptions.headers)[O]}return w[O]||N||_}_getAgent(w){let O;const _=X.getProxyUrl(w);const N=_&&_.hostname;if(this._keepAlive&&N){O=this._proxyAgent}if(this._keepAlive&&!N){O=this._agent}if(O){return O}const F=w.protocol==="https:";let H=100;if(this.requestOptions){H=this.requestOptions.maxSockets||G.globalAgent.maxSockets}if(_&&_.hostname){const w={maxSockets:H,keepAlive:this._keepAlive,proxy:Object.assign(Object.assign({},(_.username||_.password)&&{proxyAuth:`${_.username}:${_.password}`}),{host:_.hostname,port:_.port})};let N;const j=_.protocol==="https:";if(F){N=j?ee.httpsOverHttps:ee.httpsOverHttp}else{N=j?ee.httpOverHttps:ee.httpOverHttp}O=N(w);this._proxyAgent=O}if(this._keepAlive&&!O){const w={keepAlive:this._keepAlive,maxSockets:H};O=F?new z.Agent(w):new G.Agent(w);this._agent=O}if(!O){O=F?z.globalAgent:G.globalAgent}if(F&&this._ignoreSslError){O.options=Object.assign(O.options||{},{rejectUnauthorized:false})}return O}_performExponentialBackoff(w){return j(this,void 0,void 0,(function*(){w=Math.min(Ie,w);const O=Be*Math.pow(2,w);return new Promise((w=>setTimeout((()=>w()),O)))}))}_processResponse(w,O){return j(this,void 0,void 0,(function*(){return new Promise(((_,N)=>j(this,void 0,void 0,(function*(){const F=w.message.statusCode||0;const H={statusCode:F,result:null,headers:{}};if(F===se.NotFound){_(H)}function dateTimeDeserializer(w,O){if(typeof O==="string"){const w=new Date(O);if(!isNaN(w.valueOf())){return w}}return O}let j;let G;try{G=yield w.readBody();if(G&&G.length>0){if(O&&O.deserializeDates){j=JSON.parse(G,dateTimeDeserializer)}else{j=JSON.parse(G)}H.result=j}H.headers=w.message.headers}catch(w){}if(F>299){let w;if(j&&j.message){w=j.message}else if(G&&G.length>0){w=G}else{w=`Failed request: (${F})`}const O=new HttpClientError(w,F);O.result=H.result;N(O)}else{_(H)}}))))}))}}O.HttpClient=HttpClient;const lowercaseKeys=w=>Object.keys(w).reduce(((O,_)=>(O[_.toLowerCase()]=w[_],O)),{})},835:(w,O)=>{"use strict";Object.defineProperty(O,"__esModule",{value:true});O.checkBypass=O.getProxyUrl=void 0;function getProxyUrl(w){const O=w.protocol==="https:";if(checkBypass(w)){return undefined}const _=(()=>{if(O){return process.env["https_proxy"]||process.env["HTTPS_PROXY"]}else{return process.env["http_proxy"]||process.env["HTTP_PROXY"]}})();if(_){return new URL(_)}else{return undefined}}O.getProxyUrl=getProxyUrl;function checkBypass(w){if(!w.hostname){return false}const O=process.env["no_proxy"]||process.env["NO_PROXY"]||"";if(!O){return false}let _;if(w.port){_=Number(w.port)}else if(w.protocol==="http:"){_=80}else if(w.protocol==="https:"){_=443}const N=[w.hostname.toUpperCase()];if(typeof _==="number"){N.push(`${N[0]}:${_}`)}for(const w of O.split(",").map((w=>w.trim().toUpperCase())).filter((w=>w))){if(N.some((O=>O===w))){return true}}return false}O.checkBypass=checkBypass},962:function(w,O,_){"use strict";var N=this&&this.__awaiter||function(w,O,_,N){function adopt(w){return w instanceof _?w:new _((function(O){O(w)}))}return new(_||(_=Promise))((function(_,F){function fulfilled(w){try{step(N.next(w))}catch(w){F(w)}}function rejected(w){try{step(N["throw"](w))}catch(w){F(w)}}function step(w){w.done?_(w.value):adopt(w.value).then(fulfilled,rejected)}step((N=N.apply(w,O||[])).next())}))};var F;Object.defineProperty(O,"__esModule",{value:true});const H=_(491);const j=_(147);const G=_(17);F=j.promises,O.chmod=F.chmod,O.copyFile=F.copyFile,O.lstat=F.lstat,O.mkdir=F.mkdir,O.readdir=F.readdir,O.readlink=F.readlink,O.rename=F.rename,O.rmdir=F.rmdir,O.stat=F.stat,O.symlink=F.symlink,O.unlink=F.unlink;O.IS_WINDOWS=process.platform==="win32";function exists(w){return N(this,void 0,void 0,(function*(){try{yield O.stat(w)}catch(w){if(w.code==="ENOENT"){return false}throw w}return true}))}O.exists=exists;function isDirectory(w,_=false){return N(this,void 0,void 0,(function*(){const N=_?yield O.stat(w):yield O.lstat(w);return N.isDirectory()}))}O.isDirectory=isDirectory;function isRooted(w){w=normalizeSeparators(w);if(!w){throw new Error('isRooted() parameter "p" cannot be empty')}if(O.IS_WINDOWS){return w.startsWith("\\")||/^[A-Z]:/i.test(w)}return w.startsWith("/")}O.isRooted=isRooted;function mkdirP(w,_=1e3,F=1){return N(this,void 0,void 0,(function*(){H.ok(w,"a path argument must be provided");w=G.resolve(w);if(F>=_)return O.mkdir(w);try{yield O.mkdir(w);return}catch(N){switch(N.code){case"ENOENT":{yield mkdirP(G.dirname(w),_,F+1);yield O.mkdir(w);return}default:{let _;try{_=yield O.stat(w)}catch(w){throw N}if(!_.isDirectory())throw N}}}}))}O.mkdirP=mkdirP;function tryGetExecutablePath(w,_){return N(this,void 0,void 0,(function*(){let N=undefined;try{N=yield O.stat(w)}catch(O){if(O.code!=="ENOENT"){console.log(`Unexpected error attempting to determine if executable file exists '${w}': ${O}`)}}if(N&&N.isFile()){if(O.IS_WINDOWS){const O=G.extname(w).toUpperCase();if(_.some((w=>w.toUpperCase()===O))){return w}}else{if(isUnixExecutable(N)){return w}}}const F=w;for(const H of _){w=F+H;N=undefined;try{N=yield O.stat(w)}catch(O){if(O.code!=="ENOENT"){console.log(`Unexpected error attempting to determine if executable file exists '${w}': ${O}`)}}if(N&&N.isFile()){if(O.IS_WINDOWS){try{const _=G.dirname(w);const N=G.basename(w).toUpperCase();for(const F of yield O.readdir(_)){if(N===F.toUpperCase()){w=G.join(_,F);break}}}catch(O){console.log(`Unexpected error attempting to determine the actual case of the file '${w}': ${O}`)}return w}else{if(isUnixExecutable(N)){return w}}}}return""}))}O.tryGetExecutablePath=tryGetExecutablePath;function normalizeSeparators(w){w=w||"";if(O.IS_WINDOWS){w=w.replace(/\//g,"\\");return w.replace(/\\\\+/g,"\\")}return w.replace(/\/\/+/g,"/")}function isUnixExecutable(w){return(w.mode&1)>0||(w.mode&8)>0&&w.gid===process.getgid()||(w.mode&64)>0&&w.uid===process.getuid()}},436:function(w,O,_){"use strict";var N=this&&this.__awaiter||function(w,O,_,N){function adopt(w){return w instanceof _?w:new _((function(O){O(w)}))}return new(_||(_=Promise))((function(_,F){function fulfilled(w){try{step(N.next(w))}catch(w){F(w)}}function rejected(w){try{step(N["throw"](w))}catch(w){F(w)}}function step(w){w.done?_(w.value):adopt(w.value).then(fulfilled,rejected)}step((N=N.apply(w,O||[])).next())}))};Object.defineProperty(O,"__esModule",{value:true});const F=_(81);const H=_(17);const j=_(837);const G=_(962);const z=j.promisify(F.exec);function cp(w,O,_={}){return N(this,void 0,void 0,(function*(){const{force:N,recursive:F}=readCopyOptions(_);const j=(yield G.exists(O))?yield G.stat(O):null;if(j&&j.isFile()&&!N){return}const z=j&&j.isDirectory()?H.join(O,H.basename(w)):O;if(!(yield G.exists(w))){throw new Error(`no such file or directory: ${w}`)}const X=yield G.stat(w);if(X.isDirectory()){if(!F){throw new Error(`Failed to copy. ${w} is a directory, but tried to copy without recursive flag.`)}else{yield cpDirRecursive(w,z,0,N)}}else{if(H.relative(w,z)===""){throw new Error(`'${z}' and '${w}' are the same file`)}yield copyFile(w,z,N)}}))}O.cp=cp;function mv(w,O,_={}){return N(this,void 0,void 0,(function*(){if(yield G.exists(O)){let N=true;if(yield G.isDirectory(O)){O=H.join(O,H.basename(w));N=yield G.exists(O)}if(N){if(_.force==null||_.force){yield rmRF(O)}else{throw new Error("Destination already exists")}}}yield mkdirP(H.dirname(O));yield G.rename(w,O)}))}O.mv=mv;function rmRF(w){return N(this,void 0,void 0,(function*(){if(G.IS_WINDOWS){try{if(yield G.isDirectory(w,true)){yield z(`rd /s /q "${w}"`)}else{yield z(`del /f /a "${w}"`)}}catch(w){if(w.code!=="ENOENT")throw w}try{yield G.unlink(w)}catch(w){if(w.code!=="ENOENT")throw w}}else{let O=false;try{O=yield G.isDirectory(w)}catch(w){if(w.code!=="ENOENT")throw w;return}if(O){yield z(`rm -rf "${w}"`)}else{yield G.unlink(w)}}}))}O.rmRF=rmRF;function mkdirP(w){return N(this,void 0,void 0,(function*(){yield G.mkdirP(w)}))}O.mkdirP=mkdirP;function which(w,O){return N(this,void 0,void 0,(function*(){if(!w){throw new Error("parameter 'tool' is required")}if(O){const O=yield which(w,false);if(!O){if(G.IS_WINDOWS){throw new Error(`Unable to locate executable file: ${w}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`)}else{throw new Error(`Unable to locate executable file: ${w}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`)}}}try{const O=[];if(G.IS_WINDOWS&&process.env.PATHEXT){for(const w of process.env.PATHEXT.split(H.delimiter)){if(w){O.push(w)}}}if(G.isRooted(w)){const _=yield G.tryGetExecutablePath(w,O);if(_){return _}return""}if(w.includes("/")||G.IS_WINDOWS&&w.includes("\\")){return""}const _=[];if(process.env.PATH){for(const w of process.env.PATH.split(H.delimiter)){if(w){_.push(w)}}}for(const N of _){const _=yield G.tryGetExecutablePath(N+H.sep+w,O);if(_){return _}}return""}catch(w){throw new Error(`which failed with message ${w.message}`)}}))}O.which=which;function readCopyOptions(w){const O=w.force==null?true:w.force;const _=Boolean(w.recursive);return{force:O,recursive:_}}function cpDirRecursive(w,O,_,F){return N(this,void 0,void 0,(function*(){if(_>=255)return;_++;yield mkdirP(O);const N=yield G.readdir(w);for(const H of N){const N=`${w}/${H}`;const j=`${O}/${H}`;const z=yield G.lstat(N);if(z.isDirectory()){yield cpDirRecursive(N,j,_,F)}else{yield copyFile(N,j,F)}}yield G.chmod(O,(yield G.stat(w)).mode)}))}function copyFile(w,O,_){return N(this,void 0,void 0,(function*(){if((yield G.lstat(w)).isSymbolicLink()){try{yield G.lstat(O);yield G.unlink(O)}catch(w){if(w.code==="EPERM"){yield G.chmod(O,"0666");yield G.unlink(O)}}const _=yield G.readlink(w);yield G.symlink(_,O,G.IS_WINDOWS?"junction":null)}else if(!(yield G.exists(O))||_){yield G.copyFile(w,O)}}))}},764:w=>{"use strict";w.exports=addressparser;function addressparser(w){var O=new Tokenizer(w);var _=O.tokenize();var N=[];var F=[];var H=[];_.forEach((function(w){if(w.type==="operator"&&(w.value===","||w.value===";")){if(F.length){N.push(F)}F=[]}else{F.push(w)}}));if(F.length){N.push(F)}N.forEach((function(w){w=_handleAddress(w);if(w.length){H=H.concat(w)}}));return H}function _handleAddress(w){var O;var _=false;var N="text";var F;var H=[];var j={address:[],comment:[],group:[],text:[]};var G;var z;for(G=0,z=w.length;G<z;G++){O=w[G];if(O.type==="operator"){switch(O.value){case"<":N="address";break;case"(":N="comment";break;case":":N="group";_=true;break;default:N="text"}}else if(O.value){if(N==="address"){O.value=O.value.replace(/^[^<]*<\s*/,"")}j[N].push(O.value)}}if(!j.text.length&&j.comment.length){j.text=j.comment;j.comment=[]}if(_){j.text=j.text.join(" ");H.push({name:j.text||F&&F.name,group:j.group.length?addressparser(j.group.join(",")):[]})}else{if(!j.address.length&&j.text.length){for(G=j.text.length-1;G>=0;G--){if(j.text[G].match(/^[^@\s]+@[^@\s]+$/)){j.address=j.text.splice(G,1);break}}var _regexHandler=function(w){if(!j.address.length){j.address=[w.trim()];return" "}else{return w}};if(!j.address.length){for(G=j.text.length-1;G>=0;G--){j.text[G]=j.text[G].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/,_regexHandler).trim();if(j.address.length){break}}}}if(!j.text.length&&j.comment.length){j.text=j.comment;j.comment=[]}if(j.address.length>1){j.text=j.text.concat(j.address.splice(1))}j.text=j.text.join(" ");j.address=j.address.join(" ");if(!j.address&&_){return[]}else{F={address:j.address||j.text||"",name:j.text||j.address||""};if(F.address===F.name){if((F.address||"").match(/@/)){F.name=""}else{F.address=""}}H.push(F)}}return H}function Tokenizer(w){this.str=(w||"").toString();this.operatorCurrent="";this.operatorExpecting="";this.node=null;this.escaped=false;this.list=[]}Tokenizer.prototype.operators={'"':'"',"(":")","<":">",",":"",":":";",";":""};Tokenizer.prototype.tokenize=function(){var w,O=[];for(var _=0,N=this.str.length;_<N;_++){w=this.str.charAt(_);this.checkChar(w)}this.list.forEach((function(w){w.value=(w.value||"").toString().trim();if(w.value){O.push(w)}}));return O};Tokenizer.prototype.checkChar=function(w){if((w in this.operators||w==="\\")&&this.escaped){this.escaped=false}else if(this.operatorExpecting&&w===this.operatorExpecting){this.node={type:"operator",value:w};this.list.push(this.node);this.node=null;this.operatorExpecting="";this.escaped=false;return}else if(!this.operatorExpecting&&w in this.operators){this.node={type:"operator",value:w};this.list.push(this.node);this.node=null;this.operatorExpecting=this.operators[w];this.escaped=false;return}if(!this.escaped&&w==="\\"){this.escaped=true;return}if(!this.node){this.node={type:"text",value:""};this.list.push(this.node)}if(this.escaped&&w!=="\\"){this.node.value+="\\"}this.node.value+=w;this.escaped=false}},294:(w,O,_)=>{w.exports=_(219)},219:(w,O,_)=>{"use strict";var N=_(808);var F=_(404);var H=_(685);var j=_(687);var G=_(361);var z=_(491);var X=_(837);O.httpOverHttp=httpOverHttp;O.httpsOverHttp=httpsOverHttp;O.httpOverHttps=httpOverHttps;O.httpsOverHttps=httpsOverHttps;function httpOverHttp(w){var O=new TunnelingAgent(w);O.request=H.request;return O}function httpsOverHttp(w){var O=new TunnelingAgent(w);O.request=H.request;O.createSocket=createSecureSocket;O.defaultPort=443;return O}function httpOverHttps(w){var O=new TunnelingAgent(w);O.request=j.request;return O}function httpsOverHttps(w){var O=new TunnelingAgent(w);O.request=j.request;O.createSocket=createSecureSocket;O.defaultPort=443;return O}function TunnelingAgent(w){var O=this;O.options=w||{};O.proxyOptions=O.options.proxy||{};O.maxSockets=O.options.maxSockets||H.Agent.defaultMaxSockets;O.requests=[];O.sockets=[];O.on("free",(function onFree(w,_,N,F){var H=toOptions(_,N,F);for(var j=0,G=O.requests.length;j<G;++j){var z=O.requests[j];if(z.host===H.host&&z.port===H.port){O.requests.splice(j,1);z.request.onSocket(w);return}}w.destroy();O.removeSocket(w)}))}X.inherits(TunnelingAgent,G.EventEmitter);TunnelingAgent.prototype.addRequest=function addRequest(w,O,_,N){var F=this;var H=mergeOptions({request:w},F.options,toOptions(O,_,N));if(F.sockets.length>=this.maxSockets){F.requests.push(H);return}F.createSocket(H,(function(O){O.on("free",onFree);O.on("close",onCloseOrRemove);O.on("agentRemove",onCloseOrRemove);w.onSocket(O);function onFree(){F.emit("free",O,H)}function onCloseOrRemove(w){F.removeSocket(O);O.removeListener("free",onFree);O.removeListener("close",onCloseOrRemove);O.removeListener("agentRemove",onCloseOrRemove)}}))};TunnelingAgent.prototype.createSocket=function createSocket(w,O){var _=this;var N={};_.sockets.push(N);var F=mergeOptions({},_.proxyOptions,{method:"CONNECT",path:w.host+":"+w.port,agent:false,headers:{host:w.host+":"+w.port}});if(w.localAddress){F.localAddress=w.localAddress}if(F.proxyAuth){F.headers=F.headers||{};F.headers["Proxy-Authorization"]="Basic "+new Buffer(F.proxyAuth).toString("base64")}ee("making CONNECT request");var H=_.request(F);H.useChunkedEncodingByDefault=false;H.once("response",onResponse);H.once("upgrade",onUpgrade);H.once("connect",onConnect);H.once("error",onError);H.end();function onResponse(w){w.upgrade=true}function onUpgrade(w,O,_){process.nextTick((function(){onConnect(w,O,_)}))}function onConnect(F,j,G){H.removeAllListeners();j.removeAllListeners();if(F.statusCode!==200){ee("tunneling socket could not be established, statusCode=%d",F.statusCode);j.destroy();var z=new Error("tunneling socket could not be established, "+"statusCode="+F.statusCode);z.code="ECONNRESET";w.request.emit("error",z);_.removeSocket(N);return}if(G.length>0){ee("got illegal response body from proxy");j.destroy();var z=new Error("got illegal response body from proxy");z.code="ECONNRESET";w.request.emit("error",z);_.removeSocket(N);return}ee("tunneling connection has established");_.sockets[_.sockets.indexOf(N)]=j;return O(j)}function onError(O){H.removeAllListeners();ee("tunneling socket could not be established, cause=%s\n",O.message,O.stack);var F=new Error("tunneling socket could not be established, "+"cause="+O.message);F.code="ECONNRESET";w.request.emit("error",F);_.removeSocket(N)}};TunnelingAgent.prototype.removeSocket=function removeSocket(w){var O=this.sockets.indexOf(w);if(O===-1){return}this.sockets.splice(O,1);var _=this.requests.shift();if(_){this.createSocket(_,(function(w){_.request.onSocket(w)}))}};function createSecureSocket(w,O){var _=this;TunnelingAgent.prototype.createSocket.call(_,w,(function(N){var H=w.request.getHeader("host");var j=mergeOptions({},_.options,{socket:N,servername:H?H.replace(/:.*$/,""):w.host});var G=F.connect(0,j);_.sockets[_.sockets.indexOf(N)]=G;O(G)}))}function toOptions(w,O,_){if(typeof w==="string"){return{host:w,port:O,localAddress:_}}return w}function mergeOptions(w){for(var O=1,_=arguments.length;O<_;++O){var N=arguments[O];if(typeof N==="object"){var F=Object.keys(N);for(var H=0,j=F.length;H<j;++H){var G=F[H];if(N[G]!==undefined){w[G]=N[G]}}}}return w}var ee;if(process.env.NODE_DEBUG&&/\btunnel\b/.test(process.env.NODE_DEBUG)){ee=function(){var w=Array.prototype.slice.call(arguments);if(typeof w[0]==="string"){w[0]="TUNNEL: "+w[0]}else{w.unshift("TUNNEL:")}console.error.apply(console,w)}}else{ee=function(){}}O.debug=ee},954:function(w,O,_){"use strict";var N=this&&this.__createBinding||(Object.create?function(w,O,_,N){if(N===undefined)N=_;var F=Object.getOwnPropertyDescriptor(O,_);if(!F||("get"in F?!O.__esModule:F.writable||F.configurable)){F={enumerable:true,get:function(){return O[_]}}}Object.defineProperty(w,N,F)}:function(w,O,_,N){if(N===undefined)N=_;w[N]=O[_]});var F=this&&this.__setModuleDefault||(Object.create?function(w,O){Object.defineProperty(w,"default",{enumerable:true,value:O})}:function(w,O){w["default"]=O});var H=this&&this.__importStar||function(w){if(w&&w.__esModule)return w;var O={};if(w!=null)for(var _ in w)if(_!=="default"&&Object.prototype.hasOwnProperty.call(w,_))N(O,w,_);F(O,w);return O};var j=this&&this.__awaiter||function(w,O,_,N){function adopt(w){return w instanceof _?w:new _((function(O){O(w)}))}return new(_||(_=Promise))((function(_,F){function fulfilled(w){try{step(N.next(w))}catch(w){F(w)}}function rejected(w){try{step(N["throw"](w))}catch(w){F(w)}}function step(w){w.done?_(w.value):adopt(w.value).then(fulfilled,rejected)}step((N=N.apply(w,O||[])).next())}))};Object.defineProperty(O,"__esModule",{value:true});O.getInputs=void 0;const G=H(_(186));function getInputs(){return j(this,void 0,void 0,(function*(){return{gpgPrivateKey:G.getInput("gpg_private_key",{required:true}),passphrase:G.getInput("passphrase"),trustLevel:G.getInput("trust_level"),gitConfigGlobal:G.getBooleanInput("git_config_global"),gitUserSigningkey:G.getBooleanInput("git_user_signingkey"),gitCommitGpgsign:G.getBooleanInput("git_commit_gpgsign"),gitTagGpgsign:G.getBooleanInput("git_tag_gpgsign"),gitPushGpgsign:G.getInput("git_push_gpgsign")||"if-asked",gitCommitterName:G.getInput("git_committer_name"),gitCommitterEmail:G.getInput("git_committer_email"),workdir:G.getInput("workdir")||".",fingerprint:G.getInput("fingerprint")}}))}O.getInputs=getInputs},350:function(w,O,_){"use strict";var N=this&&this.__createBinding||(Object.create?function(w,O,_,N){if(N===undefined)N=_;var F=Object.getOwnPropertyDescriptor(O,_);if(!F||("get"in F?!O.__esModule:F.writable||F.configurable)){F={enumerable:true,get:function(){return O[_]}}}Object.defineProperty(w,N,F)}:function(w,O,_,N){if(N===undefined)N=_;w[N]=O[_]});var F=this&&this.__setModuleDefault||(Object.create?function(w,O){Object.defineProperty(w,"default",{enumerable:true,value:O})}:function(w,O){w["default"]=O});var H=this&&this.__importStar||function(w){if(w&&w.__esModule)return w;var O={};if(w!=null)for(var _ in w)if(_!=="default"&&Object.prototype.hasOwnProperty.call(w,_))N(O,w,_);F(O,w);return O};var j=this&&this.__awaiter||function(w,O,_,N){function adopt(w){return w instanceof _?w:new _((function(O){O(w)}))}return new(_||(_=Promise))((function(_,F){function fulfilled(w){try{step(N.next(w))}catch(w){F(w)}}function rejected(w){try{step(N["throw"](w))}catch(w){F(w)}}function step(w){w.done?_(w.value):adopt(w.value).then(fulfilled,rejected)}step((N=N.apply(w,O||[])).next())}))};Object.defineProperty(O,"__esModule",{value:true});O.setConfig=void 0;const G=H(_(514));const git=(w=[])=>j(void 0,void 0,void 0,(function*(){return yield G.getExecOutput(`git`,w,{ignoreReturnCode:true,silent:true}).then((w=>{if(w.stderr.length>0&&w.exitCode!=0){throw new Error(w.stderr)}return w.stdout.trim()}))}));function setConfig(w,O,_){return j(this,void 0,void 0,(function*(){const N=["config"];if(_){N.push("--global")}N.push(w,O);yield git(N)}))}O.setConfig=setConfig},759:function(w,O,_){"use strict";var N=this&&this.__createBinding||(Object.create?function(w,O,_,N){if(N===undefined)N=_;var F=Object.getOwnPropertyDescriptor(O,_);if(!F||("get"in F?!O.__esModule:F.writable||F.configurable)){F={enumerable:true,get:function(){return O[_]}}}Object.defineProperty(w,N,F)}:function(w,O,_,N){if(N===undefined)N=_;w[N]=O[_]});var F=this&&this.__setModuleDefault||(Object.create?function(w,O){Object.defineProperty(w,"default",{enumerable:true,value:O})}:function(w,O){w["default"]=O});var H=this&&this.__importStar||function(w){if(w&&w.__esModule)return w;var O={};if(w!=null)for(var _ in w)if(_!=="default"&&Object.prototype.hasOwnProperty.call(w,_))N(O,w,_);F(O,w);return O};var j=this&&this.__awaiter||function(w,O,_,N){function adopt(w){return w instanceof _?w:new _((function(O){O(w)}))}return new(_||(_=Promise))((function(_,F){function fulfilled(w){try{step(N.next(w))}catch(w){F(w)}}function rejected(w){try{step(N["throw"](w))}catch(w){F(w)}}function step(w){w.done?_(w.value):adopt(w.value).then(fulfilled,rejected)}step((N=N.apply(w,O||[])).next())}))};Object.defineProperty(O,"__esModule",{value:true});O.killAgent=O.deleteKey=O.setTrustLevel=O.presetPassphrase=O.configureAgent=O.getKeygrip=O.parseKeygripFromGpgColonsOutput=O.getKeygrips=O.importKey=O.getDirs=O.getVersion=O.getHome=O.agentConfig=void 0;const G=H(_(514));const z=H(_(147));const X=H(_(17));const ee=H(_(37));const se=H(_(728));O.agentConfig=`default-cache-ttl 21600\nmax-cache-ttl 31536000\nallow-preset-passphrase`;const gpgConnectAgent=w=>j(void 0,void 0,void 0,(function*(){return yield G.getExecOutput(`gpg-connect-agent "${w}" /bye`,[],{ignoreReturnCode:true,silent:true}).then((w=>{if(w.stderr.length>0&&w.exitCode!=0){throw new Error(w.stderr)}for(const O of w.stdout.replace(/\r/g,"").trim().split(/\n/g)){if(O.startsWith("ERR")){throw new Error(O)}}return w.stdout.trim()}))}));const getHome=()=>j(void 0,void 0,void 0,(function*(){let w="";if(process.env.GNUPGHOME){w=process.env.GNUPGHOME}else if(ee.platform()=="win32"&&!process.env.HOME&&process.env.USERPROFILE){w=X.join(process.env.USERPROFILE,".gnupg")}else if(process.env.HOME){w=X.join(process.env.HOME,".gnupg")}else{w=(yield(0,O.getDirs)()).homedir}if(w.length==0){throw new Error("Unable to determine GnuPG home directory")}if(!z.existsSync(w)){z.mkdirSync(w,{recursive:true})}return w}));O.getHome=getHome;const getVersion=()=>j(void 0,void 0,void 0,(function*(){return yield G.getExecOutput("gpg",["--version"],{ignoreReturnCode:true,silent:true}).then((w=>{if(w.stderr.length>0&&w.exitCode!=0){throw new Error(w.stderr)}let O="";let _="";for(const N of w.stdout.replace(/\r/g,"").trim().split(/\n/g)){if(N.startsWith("gpg (GnuPG) ")){O=N.substr("gpg (GnuPG) ".length).trim()}else if(N.startsWith("gpg (GnuPG/MacGPG2) ")){O=N.substr("gpg (GnuPG/MacGPG2) ".length).trim()}else if(N.startsWith("libgcrypt ")){_=N.substr("libgcrypt ".length).trim()}}return{gnupg:O,libgcrypt:_}}))}));O.getVersion=getVersion;const getDirs=()=>j(void 0,void 0,void 0,(function*(){return yield G.getExecOutput("gpgconf",["--list-dirs"],{ignoreReturnCode:true,silent:true}).then((w=>{if(w.stderr.length>0&&w.exitCode!=0){throw new Error(w.stderr)}let O="";let _="";let N="";let F="";for(const H of w.stdout.replace(/\r/g,"").trim().split(/\n/g)){if(H.startsWith("libdir:")){O=H.substr("libdir:".length).replace("%3a",":").trim()}else if(H.startsWith("libexecdir:")){_=H.substr("libexecdir:".length).replace("%3a",":").trim()}else if(H.startsWith("datadir:")){N=H.substr("datadir:".length).replace("%3a",":").trim()}else if(H.startsWith("homedir:")){F=H.substr("homedir:".length).replace("%3a",":").trim()}}return{libdir:O,libexecdir:_,datadir:N,homedir:F}}))}));O.getDirs=getDirs;const importKey=w=>j(void 0,void 0,void 0,(function*(){const O=z.mkdtempSync(X.join(ee.tmpdir(),"ghaction-import-gpg-"));const _=`${O}/key.pgp`;z.writeFileSync(_,(yield se.isArmored(w))?w:Buffer.from(w,"base64").toString(),{mode:384});return yield G.getExecOutput("gpg",["--import","--batch","--yes",_],{ignoreReturnCode:true,silent:true}).then((w=>{if(w.stderr.length>0&&w.exitCode!=0){throw new Error(w.stderr)}if(w.stderr!=""){return w.stderr.trim()}return w.stdout.trim()})).finally((()=>{z.unlinkSync(_)}))}));O.importKey=importKey;const getKeygrips=w=>j(void 0,void 0,void 0,(function*(){return yield G.getExecOutput("gpg",["--batch","--with-colons","--with-keygrip","--list-secret-keys",w],{ignoreReturnCode:true,silent:true}).then((w=>{const O=[];for(const _ of w.stdout.replace(/\r/g,"").trim().split(/\n/g)){if(_.startsWith("grp")){O.push(_.replace(/(grp|:)/g,"").trim())}}return O}))}));O.getKeygrips=getKeygrips;const parseKeygripFromGpgColonsOutput=(w,O)=>{let _="";let N=false;const F=w.replace(/\r/g,"").trim().split(/\n/g);for(const w of F){if(w.startsWith(`fpr:`)&&w.includes(`:${O}:`)){N=true;continue}if(w.startsWith("grp:")&&N){_=w.replace(/(grp|:)/g,"").trim();break}}return _};O.parseKeygripFromGpgColonsOutput=parseKeygripFromGpgColonsOutput;const getKeygrip=w=>j(void 0,void 0,void 0,(function*(){return yield G.getExecOutput("gpg",["--batch","--with-colons","--with-keygrip","--list-secret-keys",w],{ignoreReturnCode:true,silent:true}).then((_=>(0,O.parseKeygripFromGpgColonsOutput)(_.stdout,w)))}));O.getKeygrip=getKeygrip;const configureAgent=(w,O)=>j(void 0,void 0,void 0,(function*(){const _=X.join(w,"gpg-agent.conf");yield z.writeFile(_,O,(function(w){if(w)throw w}));yield gpgConnectAgent("RELOADAGENT")}));O.configureAgent=configureAgent;const presetPassphrase=(w,O)=>j(void 0,void 0,void 0,(function*(){const _=Buffer.from(O,"utf8").toString("hex").toUpperCase();yield gpgConnectAgent(`PRESET_PASSPHRASE ${w} -1 ${_}`);return yield gpgConnectAgent(`KEYINFO ${w}`)}));O.presetPassphrase=presetPassphrase;const setTrustLevel=(w,O)=>j(void 0,void 0,void 0,(function*(){yield G.getExecOutput("gpg",["--batch","--no-tty","--command-fd","0","--edit-key",w],{ignoreReturnCode:true,silent:true,input:Buffer.from(`trust\n${O}\ny\nquit\n`)}).then((w=>{if(w.stderr.length>0&&w.exitCode!=0){throw new Error(w.stderr)}}))}));O.setTrustLevel=setTrustLevel;const deleteKey=w=>j(void 0,void 0,void 0,(function*(){yield G.getExecOutput("gpg",["--batch","--yes","--delete-secret-keys",w],{ignoreReturnCode:true,silent:true}).then((w=>{if(w.stderr.length>0&&w.exitCode!=0){throw new Error(w.stderr)}}));yield G.getExecOutput("gpg",["--batch","--yes","--delete-keys",w],{ignoreReturnCode:true,silent:true}).then((w=>{if(w.stderr.length>0&&w.exitCode!=0){throw new Error(w.stderr)}}))}));O.deleteKey=deleteKey;const killAgent=()=>j(void 0,void 0,void 0,(function*(){yield gpgConnectAgent("KILLAGENT")}));O.killAgent=killAgent},399:function(w,O,_){"use strict";var N=this&&this.__createBinding||(Object.create?function(w,O,_,N){if(N===undefined)N=_;var F=Object.getOwnPropertyDescriptor(O,_);if(!F||("get"in F?!O.__esModule:F.writable||F.configurable)){F={enumerable:true,get:function(){return O[_]}}}Object.defineProperty(w,N,F)}:function(w,O,_,N){if(N===undefined)N=_;w[N]=O[_]});var F=this&&this.__setModuleDefault||(Object.create?function(w,O){Object.defineProperty(w,"default",{enumerable:true,value:O})}:function(w,O){w["default"]=O});var H=this&&this.__importStar||function(w){if(w&&w.__esModule)return w;var O={};if(w!=null)for(var _ in w)if(_!=="default"&&Object.prototype.hasOwnProperty.call(w,_))N(O,w,_);F(O,w);return O};var j=this&&this.__awaiter||function(w,O,_,N){function adopt(w){return w instanceof _?w:new _((function(O){O(w)}))}return new(_||(_=Promise))((function(_,F){function fulfilled(w){try{step(N.next(w))}catch(w){F(w)}}function rejected(w){try{step(N["throw"](w))}catch(w){F(w)}}function step(w){w.done?_(w.value):adopt(w.value).then(fulfilled,rejected)}step((N=N.apply(w,O||[])).next())}))};Object.defineProperty(O,"__esModule",{value:true});const G=H(_(186));const z=H(_(954));const X=H(_(350));const ee=H(_(759));const se=H(_(728));const ae=H(_(963));function run(){return j(this,void 0,void 0,(function*(){try{const w=yield z.getInputs();if(w.workdir&&w.workdir!=="."){G.info(`Using ${w.workdir} as working directory...`);process.chdir(w.workdir)}const O=yield ee.getVersion();const _=yield ee.getDirs();yield G.group(`GnuPG info`,(()=>j(this,void 0,void 0,(function*(){G.info(`Version    : ${O.gnupg} (libgcrypt ${O.libgcrypt})`);G.info(`Libdir     : ${_.libdir}`);G.info(`Libexecdir : ${_.libexecdir}`);G.info(`Datadir    : ${_.datadir}`);G.info(`Homedir    : ${_.homedir}`)}))));const N=yield se.readPrivateKey(w.gpgPrivateKey);yield G.group(`GPG private key info`,(()=>j(this,void 0,void 0,(function*(){G.info(`Fingerprint  : ${N.fingerprint}`);G.info(`KeyID        : ${N.keyID}`);G.info(`Name         : ${N.name}`);G.info(`Email        : ${N.email}`);G.info(`CreationTime : ${N.creationTime}`)}))));ae.setFingerprint(N.fingerprint);let F=N.fingerprint;if(w.fingerprint){F=w.fingerprint}yield G.group(`Fingerprint to use`,(()=>j(this,void 0,void 0,(function*(){G.info(F)}))));yield G.group(`Importing GPG private key`,(()=>j(this,void 0,void 0,(function*(){yield ee.importKey(w.gpgPrivateKey).then((w=>{G.info(w)}))}))));if(w.passphrase){yield G.group(`Configuring GnuPG agent`,(()=>j(this,void 0,void 0,(function*(){const w=yield ee.getHome();G.info(`GnuPG home: ${w}`);yield ee.configureAgent(w,ee.agentConfig)}))));if(!w.fingerprint){yield G.group(`Getting keygrips`,(()=>j(this,void 0,void 0,(function*(){for(const O of yield ee.getKeygrips(F)){G.info(`Presetting passphrase for ${O}`);yield ee.presetPassphrase(O,w.passphrase).then((w=>{G.debug(w)}))}}))))}else{yield G.group(`Getting keygrip for fingerprint`,(()=>j(this,void 0,void 0,(function*(){const O=yield ee.getKeygrip(F);G.info(`Presetting passphrase for key ${F} with keygrip ${O}`);yield ee.presetPassphrase(O,w.passphrase).then((w=>{G.debug(w)}))}))))}}if(w.trustLevel){yield G.group(`Setting key's trust level`,(()=>j(this,void 0,void 0,(function*(){yield ee.setTrustLevel(N.keyID,w.trustLevel).then((()=>{G.info(`Trust level set to ${w.trustLevel} for ${N.keyID}`)}))}))))}yield G.group(`Setting outputs`,(()=>j(this,void 0,void 0,(function*(){G.info(`fingerprint=${F}`);G.setOutput("fingerprint",F);G.info(`keyid=${N.keyID}`);G.setOutput("keyid",N.keyID);G.info(`name=${N.name}`);G.setOutput("name",N.name);G.info(`email=${N.email}`);G.setOutput("email",N.email)}))));if(w.gitUserSigningkey){G.info("Setting GPG signing keyID for this Git repository");yield X.setConfig("user.signingkey",N.keyID,w.gitConfigGlobal);const O=w.gitCommitterEmail||N.email;const _=w.gitCommitterName||N.name;if(O!=N.email){G.setFailed(`Committer email "${w.gitCommitterEmail}" (name: "${w.gitCommitterName}") does not match GPG private key email "${N.email}" (name: "${N.name}")`);return}G.info(`Configuring Git committer (${_} <${O}>)`);yield X.setConfig("user.name",_,w.gitConfigGlobal);yield X.setConfig("user.email",O,w.gitConfigGlobal);if(w.gitCommitGpgsign){G.info("Sign all commits automatically");yield X.setConfig("commit.gpgsign","true",w.gitConfigGlobal)}if(w.gitTagGpgsign){G.info("Sign all tags automatically");yield X.setConfig("tag.gpgsign","true",w.gitConfigGlobal)}if(w.gitPushGpgsign){G.info("Sign all pushes automatically");yield X.setConfig("push.gpgsign",w.gitPushGpgsign,w.gitConfigGlobal)}}}catch(w){G.setFailed(w.message)}}))}function cleanup(){return j(this,void 0,void 0,(function*(){if(ae.fingerprint.length<=0){G.debug("Primary key fingerprint is not defined. Skipping cleanup.");return}try{G.info(`Removing key ${ae.fingerprint}`);yield ee.deleteKey(ae.fingerprint);G.info("Killing GnuPG agent");yield ee.killAgent()}catch(w){G.warning(w.message)}}))}if(!ae.IsPost){run()}else{cleanup()}},728:function(w,O,_){"use strict";var N=this&&this.__createBinding||(Object.create?function(w,O,_,N){if(N===undefined)N=_;var F=Object.getOwnPropertyDescriptor(O,_);if(!F||("get"in F?!O.__esModule:F.writable||F.configurable)){F={enumerable:true,get:function(){return O[_]}}}Object.defineProperty(w,N,F)}:function(w,O,_,N){if(N===undefined)N=_;w[N]=O[_]});var F=this&&this.__setModuleDefault||(Object.create?function(w,O){Object.defineProperty(w,"default",{enumerable:true,value:O})}:function(w,O){w["default"]=O});var H=this&&this.__importStar||function(w){if(w&&w.__esModule)return w;var O={};if(w!=null)for(var _ in w)if(_!=="default"&&Object.prototype.hasOwnProperty.call(w,_))N(O,w,_);F(O,w);return O};var j=this&&this.__awaiter||function(w,O,_,N){function adopt(w){return w instanceof _?w:new _((function(O){O(w)}))}return new(_||(_=Promise))((function(_,F){function fulfilled(w){try{step(N.next(w))}catch(w){F(w)}}function rejected(w){try{step(N["throw"](w))}catch(w){F(w)}}function step(w){w.done?_(w.value):adopt(w.value).then(fulfilled,rejected)}step((N=N.apply(w,O||[])).next())}))};var G=this&&this.__importDefault||function(w){return w&&w.__esModule?w:{default:w}};Object.defineProperty(O,"__esModule",{value:true});O.isArmored=O.generateKeyPair=O.readPrivateKey=void 0;const z=H(_(42));const X=G(_(764));const readPrivateKey=w=>j(void 0,void 0,void 0,(function*(){const _=yield z.readKey({armoredKey:(yield(0,O.isArmored)(w))?w:Buffer.from(w,"base64").toString()});const N=yield _.getPrimaryUser().then((w=>{var O;return(0,X.default)((O=w.user.userID)===null||O===void 0?void 0:O.userID)[0]}));return{fingerprint:_.getFingerprint().toUpperCase(),keyID:_.getKeyID().toHex().toUpperCase(),name:N.name,email:N.address,creationTime:_.getCreationTime()}}));O.readPrivateKey=readPrivateKey;const generateKeyPair=(w,O,_,N)=>j(void 0,void 0,void 0,(function*(){const F=yield z.generateKey({userIDs:[{name:w,email:O}],passphrase:_,type:N});return{publicKey:F.publicKey.replace(/\r\n/g,"\n").trim(),privateKey:F.privateKey.replace(/\r\n/g,"\n").trim()}}));O.generateKeyPair=generateKeyPair;const isArmored=w=>j(void 0,void 0,void 0,(function*(){return w.trimLeft().startsWith("---")}));O.isArmored=isArmored},963:function(w,O,_){"use strict";var N=this&&this.__createBinding||(Object.create?function(w,O,_,N){if(N===undefined)N=_;var F=Object.getOwnPropertyDescriptor(O,_);if(!F||("get"in F?!O.__esModule:F.writable||F.configurable)){F={enumerable:true,get:function(){return O[_]}}}Object.defineProperty(w,N,F)}:function(w,O,_,N){if(N===undefined)N=_;w[N]=O[_]});var F=this&&this.__setModuleDefault||(Object.create?function(w,O){Object.defineProperty(w,"default",{enumerable:true,value:O})}:function(w,O){w["default"]=O});var H=this&&this.__importStar||function(w){if(w&&w.__esModule)return w;var O={};if(w!=null)for(var _ in w)if(_!=="default"&&Object.prototype.hasOwnProperty.call(w,_))N(O,w,_);F(O,w);return O};Object.defineProperty(O,"__esModule",{value:true});O.setFingerprint=O.fingerprint=O.IsPost=void 0;const j=H(_(186));O.IsPost=!!process.env["STATE_isPost"];O.fingerprint=process.env["STATE_fingerprint"]||"";function setFingerprint(w){j.saveState("fingerprint",w)}O.setFingerprint=setFingerprint;if(!O.IsPost){j.saveState("isPost","true")}},491:w=>{"use strict";w.exports=require("assert")},81:w=>{"use strict";w.exports=require("child_process")},113:w=>{"use strict";w.exports=require("crypto")},361:w=>{"use strict";w.exports=require("events")},147:w=>{"use strict";w.exports=require("fs")},685:w=>{"use strict";w.exports=require("http")},687:w=>{"use strict";w.exports=require("https")},188:w=>{"use strict";w.exports=require("module")},808:w=>{"use strict";w.exports=require("net")},5:w=>{"use strict";w.exports=require("node:crypto")},37:w=>{"use strict";w.exports=require("os")},17:w=>{"use strict";w.exports=require("path")},576:w=>{"use strict";w.exports=require("string_decoder")},512:w=>{"use strict";w.exports=require("timers")},404:w=>{"use strict";w.exports=require("tls")},310:w=>{"use strict";w.exports=require("url")},837:w=>{"use strict";w.exports=require("util")},42:(w,O,_)=>{"use strict";
/*! OpenPGP.js v6.1.0 - 2025-01-30 - this is LGPL licensed code, see LICENSE/our website https://openpgpjs.org/ for more information. */const N="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};var F=_(188),H=_(5),j="undefined"!=typeof document?document.currentScript:null;function i(w){var O=Object.create(null);return w&&Object.keys(w).forEach((function(_){if("default"!==_){var N=Object.getOwnPropertyDescriptor(w,_);Object.defineProperty(O,_,N.get?N:{enumerable:!0,get:function(){return w[_]}})}})),O.default=w,Object.freeze(O)}function s(w,O){return O.forEach((function(O){O&&"string"!=typeof O&&!Array.isArray(O)&&Object.keys(O).forEach((function(_){if("default"!==_&&!(_ in w)){var N=Object.getOwnPropertyDescriptor(O,_);Object.defineProperty(w,_,N.get?N:{enumerable:!0,get:function(){return O[_]}})}}))})),Object.freeze(w)}var G=i(H);const z=Symbol("doneWritingPromise"),X=Symbol("doneWritingResolve"),ee=Symbol("doneWritingReject"),se=Symbol("readingIndex");class l extends Array{constructor(){super(),Object.setPrototypeOf(this,l.prototype),this[z]=new Promise(((w,O)=>{this[X]=w,this[ee]=O})),this[z].catch((()=>{}))}}function y(w){return w&&w.getReader&&Array.isArray(w)}function f(w){if(!y(w)){const O=w.getWriter(),_=O.releaseLock;return O.releaseLock=()=>{O.closed.catch((function(){})),_.call(O)},O}this.stream=w}function g(w){if(y(w))return"array";if(N.ReadableStream&&N.ReadableStream.prototype.isPrototypeOf(w))return"web";if(w&&!(N.ReadableStream&&w instanceof N.ReadableStream)&&"function"==typeof w._read&&"object"==typeof w._readableState)throw Error("Native Node streams are no longer supported: please manually convert the stream to a WebStream, using e.g. `stream.Readable.toWeb`");return!(!w||!w.getReader)&&"web-like"}function p(w){return Uint8Array.prototype.isPrototypeOf(w)}function d(w){if(1===w.length)return w[0];let O=0;for(let _=0;_<w.length;_++){if(!p(w[_]))throw Error("concatUint8Array: Data must be in the form of a Uint8Array");O+=w[_].length}const _=new Uint8Array(O);let N=0;return w.forEach((function(w){_.set(w,N),N+=w.length})),_}l.prototype.getReader=function(){return void 0===this[se]&&(this[se]=0),{read:async()=>(await this[z],this[se]===this.length?{value:void 0,done:!0}:{value:this[this[se]++],done:!1})}},l.prototype.readToEnd=async function(w){await this[z];const O=w(this.slice(this[se]));return this.length=0,O},l.prototype.clone=function(){const w=new l;return w[z]=this[z].then((()=>{w.push(...this)})),w},f.prototype.write=async function(w){this.stream.push(w)},f.prototype.close=async function(){this.stream[X]()},f.prototype.abort=async function(w){return this.stream[ee](w),w},f.prototype.releaseLock=function(){},"object"==typeof N.process&&N.process.versions;const ae=new WeakSet,Ae=Symbol("externalBuffer");function m(w){if(this.stream=w,w[Ae]&&(this[Ae]=w[Ae].slice()),y(w)){const O=w.getReader();return this._read=O.read.bind(O),this._releaseLock=()=>{},void(this._cancel=()=>{})}if(g(w)){const O=w.getReader();return this._read=O.read.bind(O),this._releaseLock=()=>{O.closed.catch((function(){})),O.releaseLock()},void(this._cancel=O.cancel.bind(O))}let O=!1;this._read=async()=>O||ae.has(w)?{value:void 0,done:!0}:(O=!0,{value:w,done:!1}),this._releaseLock=()=>{if(O)try{ae.add(w)}catch(w){}}}function b(w){return g(w)?w:new ReadableStream({start(O){O.enqueue(w),O.close()}})}function k(w){if(g(w))return w;const O=new l;return(async()=>{const _=M(O);await _.write(w),await _.close()})(),O}function E(w){return w.some((w=>g(w)&&!y(w)))?function(w){w=w.map(b);const O=B((async function(w){await Promise.all(N.map((O=>R(O,w))))}));let _=Promise.resolve();const N=w.map(((N,F)=>K(N,((N,H)=>(_=_.then((()=>v(N,O.writable,{preventClose:F!==w.length-1}))),_)))));return O.readable}(w):w.some((w=>y(w)))?function(w){const O=new l;let _=Promise.resolve();return w.forEach(((N,F)=>(_=_.then((()=>v(N,O,{preventClose:F!==w.length-1}))),_))),O}(w):"string"==typeof w[0]?w.join(""):d(w)}async function v(w,O,{preventClose:_=!1,preventAbort:N=!1,preventCancel:F=!1}={}){if(g(w)&&!y(w)){w=b(w);try{if(w[Ae]){const _=M(O);for(let O=0;O<w[Ae].length;O++)await _.ready,await _.write(w[Ae][O]);_.releaseLock()}await w.pipeTo(O,{preventClose:_,preventAbort:N,preventCancel:F})}catch(w){}return}const H=L(w=k(w)),j=M(O);try{for(;;){await j.ready;const{done:w,value:O}=await H.read();if(w){_||await j.close();break}await j.write(O)}}catch(w){N||await j.abort(w)}finally{H.releaseLock(),j.releaseLock()}}function I(w,O){const _=new TransformStream(O);return v(w,_.writable),_.readable}function B(w){let O,_,N,F=!1,H=!1;return{readable:new ReadableStream({start(w){N=w},pull(){O?O():F=!0},async cancel(O){H=!0,w&&await w(O),_&&_(O)}},{highWaterMark:0}),writable:new WritableStream({write:async function(w){if(H)throw Error("Stream is cancelled");N.enqueue(w),F?F=!1:(await new Promise(((w,N)=>{O=w,_=N})),O=null,_=null)},close:N.close.bind(N),abort:N.error.bind(N)})}}function S(w,O=(()=>{}),_=(()=>{})){if(y(w)){const N=new l;return(async()=>{const F=M(N);try{const N=await Q(w),H=O(N),j=_();let G;G=void 0!==H&&void 0!==j?E([H,j]):void 0!==H?H:j,await F.write(G),await F.close()}catch(w){await F.abort(w)}})(),N}if(g(w))return I(w,{async transform(w,_){try{const N=await O(w);void 0!==N&&_.enqueue(N)}catch(w){_.error(w)}},async flush(w){try{const O=await _();void 0!==O&&w.enqueue(O)}catch(O){w.error(O)}}});const N=O(w),F=_();return void 0!==N&&void 0!==F?E([N,F]):void 0!==N?N:F}function K(w,O){if(g(w)&&!y(w)){let _;const N=new TransformStream({start(w){_=w}}),F=v(w,N.writable),H=B((async function(w){_.error(w),await F,await new Promise(setTimeout)}));return O(N.readable,H.writable),H.readable}w=k(w);const _=new l;return O(w,_),_}function C(w,O){let _;const N=K(w,((w,F)=>{const H=L(w);H.remainder=()=>(H.releaseLock(),v(w,F),N),_=O(H)}));return _}function D(w){if(y(w))return w.clone();if(g(w)){const O=function(w){if(y(w))throw Error("ArrayStream cannot be tee()d, use clone() instead");if(g(w)){const O=b(w).tee();return O[0][Ae]=O[1][Ae]=w[Ae],O}return[x(w),x(w)]}(w);return P(w,O[0]),O[1]}return x(w)}function U(w){return y(w)?D(w):g(w)?new ReadableStream({start(O){const _=K(w,(async(w,_)=>{const N=L(w),F=M(_);try{for(;;){await F.ready;const{done:_,value:H}=await N.read();if(_){try{O.close()}catch(w){}return void await F.close()}try{O.enqueue(H)}catch(w){}await F.write(H)}}catch(w){O.error(w),await F.abort(w)}}));P(w,_)}}):x(w)}function P(w,O){Object.entries(Object.getOwnPropertyDescriptors(w.constructor.prototype)).forEach((([_,N])=>{"constructor"!==_&&(N.value?N.value=N.value.bind(O):N.get=N.get.bind(O),Object.defineProperty(w,_,N))}))}function x(w,O=0,_=1/0){if(y(w))throw Error("Not implemented");if(g(w)){if(O>=0&&_>=0){let N=0;return I(w,{transform(w,F){N<_?(N+w.length>=O&&F.enqueue(x(w,Math.max(O-N,0),_-N)),N+=w.length):F.terminate()}})}if(O<0&&(_<0||_===1/0)){let N=[];return S(w,(w=>{w.length>=-O?N=[w]:N.push(w)}),(()=>x(E(N),O,_)))}if(0===O&&_<0){let N;return S(w,(w=>{const F=N?E([N,w]):w;if(F.length>=-_)return N=x(F,_),x(F,O,_);N=F}))}return console.warn(`stream.slice(input, ${O}, ${_}) not implemented efficiently.`),T((async()=>x(await Q(w),O,_)))}return w[Ae]&&(w=E(w[Ae].concat([w]))),p(w)?w.subarray(O,_===1/0?w.length:_):w.slice(O,_)}async function Q(w,O=E){return y(w)?w.readToEnd(O):g(w)?L(w).readToEnd(O):w}async function R(w,O){if(g(w)){if(w.cancel){const _=await w.cancel(O);return await new Promise(setTimeout),_}if(w.destroy)return w.destroy(O),await new Promise(setTimeout),O}}function T(w){const O=new l;return(async()=>{const _=M(O);try{await _.write(await w()),await _.close()}catch(w){await _.abort(w)}})(),O}function L(w){return new m(w)}function M(w){return new f(w)}m.prototype.read=async function(){if(this[Ae]&&this[Ae].length){return{done:!1,value:this[Ae].shift()}}return this._read()},m.prototype.releaseLock=function(){this[Ae]&&(this.stream[Ae]=this[Ae]),this._releaseLock()},m.prototype.cancel=function(w){return this._cancel(w)},m.prototype.readLine=async function(){let w,O=[];for(;!w;){let{done:_,value:N}=await this.read();if(N+="",_)return O.length?E(O):void 0;const F=N.indexOf("\n")+1;F&&(w=E(O.concat(N.substr(0,F))),O=[]),F!==N.length&&O.push(N.substr(F))}return this.unshift(...O),w},m.prototype.readByte=async function(){const{done:w,value:O}=await this.read();if(w)return;const _=O[0];return this.unshift(x(O,1)),_},m.prototype.readBytes=async function(w){const O=[];let _=0;for(;;){const{done:N,value:F}=await this.read();if(N)return O.length?E(O):void 0;if(O.push(F),_+=F.length,_>=w){const _=E(O);return this.unshift(x(_,w)),x(_,0,w)}}},m.prototype.peekBytes=async function(w){const O=await this.readBytes(w);return this.unshift(O),O},m.prototype.unshift=function(...w){this[Ae]||(this[Ae]=[]),1===w.length&&p(w[0])&&this[Ae].length&&w[0].length&&this[Ae][0].byteOffset>=w[0].length?this[Ae][0]=new Uint8Array(this[Ae][0].buffer,this[Ae][0].byteOffset-w[0].length,this[Ae][0].byteLength+w[0].length):this[Ae].unshift(...w.filter((w=>w&&w.length)))},m.prototype.readToEnd=async function(w=E){const O=[];for(;;){const{done:w,value:_}=await this.read();if(w)break;O.push(_)}return w(O)};const be=Symbol("byValue");var ve={curve:{nistP256:"nistP256",p256:"nistP256",nistP384:"nistP384",p384:"nistP384",nistP521:"nistP521",p521:"nistP521",secp256k1:"secp256k1",ed25519Legacy:"ed25519Legacy",ed25519:"ed25519Legacy",curve25519Legacy:"curve25519Legacy",curve25519:"curve25519Legacy",brainpoolP256r1:"brainpoolP256r1",brainpoolP384r1:"brainpoolP384r1",brainpoolP512r1:"brainpoolP512r1"},s2k:{simple:0,salted:1,iterated:3,argon2:4,gnu:101},publicKey:{rsaEncryptSign:1,rsaEncrypt:2,rsaSign:3,elgamal:16,dsa:17,ecdh:18,ecdsa:19,eddsaLegacy:22,aedh:23,aedsa:24,x25519:25,x448:26,ed25519:27,ed448:28},symmetric:{idea:1,tripledes:2,cast5:3,blowfish:4,aes128:7,aes192:8,aes256:9,twofish:10},compression:{uncompressed:0,zip:1,zlib:2,bzip2:3},hash:{md5:1,sha1:2,ripemd:3,sha256:8,sha384:9,sha512:10,sha224:11,sha3_256:12,sha3_512:14},webHash:{"SHA-1":2,"SHA-256":8,"SHA-384":9,"SHA-512":10},aead:{eax:1,ocb:2,gcm:3,experimentalGCM:100},packet:{publicKeyEncryptedSessionKey:1,signature:2,symEncryptedSessionKey:3,onePassSignature:4,secretKey:5,publicKey:6,secretSubkey:7,compressedData:8,symmetricallyEncryptedData:9,marker:10,literalData:11,trust:12,userID:13,publicSubkey:14,userAttribute:17,symEncryptedIntegrityProtectedData:18,modificationDetectionCode:19,aeadEncryptedData:20,padding:21},literal:{binary:98,text:116,utf8:117,mime:109},signature:{binary:0,text:1,standalone:2,certGeneric:16,certPersona:17,certCasual:18,certPositive:19,certRevocation:48,subkeyBinding:24,keyBinding:25,key:31,keyRevocation:32,subkeyRevocation:40,timestamp:64,thirdParty:80},signatureSubpacket:{signatureCreationTime:2,signatureExpirationTime:3,exportableCertification:4,trustSignature:5,regularExpression:6,revocable:7,keyExpirationTime:9,placeholderBackwardsCompatibility:10,preferredSymmetricAlgorithms:11,revocationKey:12,issuerKeyID:16,notationData:20,preferredHashAlgorithms:21,preferredCompressionAlgorithms:22,keyServerPreferences:23,preferredKeyServer:24,primaryUserID:25,policyURI:26,keyFlags:27,signersUserID:28,reasonForRevocation:29,features:30,signatureTarget:31,embeddedSignature:32,issuerFingerprint:33,preferredAEADAlgorithms:34,preferredCipherSuites:39},keyFlags:{certifyKeys:1,signData:2,encryptCommunication:4,encryptStorage:8,splitPrivateKey:16,authentication:32,sharedPrivateKey:128},armor:{multipartSection:0,multipartLast:1,signed:2,message:3,publicKey:4,privateKey:5,signature:6},reasonForRevocation:{noReason:0,keySuperseded:1,keyCompromised:2,keyRetired:3,userIDInvalid:32},features:{modificationDetection:1,aead:2,v5Keys:4,seipdv2:8},write:function(w,O){if("number"==typeof O&&(O=this.read(w,O)),void 0!==w[O])return w[O];throw Error("Invalid enum value.")},read:function(w,O){if(w[be]||(w[be]=[],Object.entries(w).forEach((([O,_])=>{w[be][_]=O}))),void 0!==w[be][O])return w[be][O];throw Error("Invalid enum value.")}},Se={preferredHashAlgorithm:ve.hash.sha512,preferredSymmetricAlgorithm:ve.symmetric.aes256,preferredCompressionAlgorithm:ve.compression.uncompressed,aeadProtect:!1,parseAEADEncryptedV4KeysAsLegacy:!1,preferredAEADAlgorithm:ve.aead.gcm,aeadChunkSizeByte:12,v6Keys:!1,enableParsingV5Entities:!1,s2kType:ve.s2k.iterated,s2kIterationCountByte:224,s2kArgon2Params:{passes:3,parallelism:4,memoryExponent:16},allowUnauthenticatedMessages:!1,allowUnauthenticatedStream:!1,minRSABits:2047,passwordCollisionCheck:!1,allowInsecureDecryptionWithSigningKeys:!1,allowInsecureVerificationWithReformattedKeys:!1,allowMissingKeyFlags:!1,constantTimePKCS1Decryption:!1,constantTimePKCS1DecryptionSupportedSymmetricAlgorithms:new Set([ve.symmetric.aes128,ve.symmetric.aes192,ve.symmetric.aes256]),ignoreUnsupportedPackets:!0,ignoreMalformedPackets:!1,additionalAllowedPackets:[],showVersion:!1,showComment:!1,versionString:"OpenPGP.js 6.1.0",commentString:"https://openpgpjs.org",maxUserIDLength:5120,knownNotations:[],nonDeterministicSignaturesViaNotation:!0,useEllipticFallback:!0,rejectHashAlgorithms:new Set([ve.hash.md5,ve.hash.ripemd]),rejectMessageHashAlgorithms:new Set([ve.hash.md5,ve.hash.ripemd,ve.hash.sha1]),rejectPublicKeyAlgorithms:new Set([ve.publicKey.elgamal,ve.publicKey.dsa]),rejectCurves:new Set([ve.curve.secp256k1])};const Ie=(()=>{try{return"development"===process.env.NODE_ENV}catch(w){}return!1})(),Be={isString:function(w){return"string"==typeof w||w instanceof String},nodeRequire:F.createRequire("undefined"==typeof document?_(310).pathToFileURL(__filename).href:j&&"SCRIPT"===j.tagName.toUpperCase()&&j.src||new URL("openpgp.min.cjs",document.baseURI).href),isArray:function(w){return w instanceof Array},isUint8Array:p,isStream:g,getNobleCurve:async(w,O)=>{if(!Se.useEllipticFallback)throw Error("This curve is only supported in the full build of OpenPGP.js");const{nobleCurves:_}=await Promise.resolve().then((function(){return Bl}));switch(w){case ve.publicKey.ecdh:case ve.publicKey.ecdsa:{const w=_.get(O);if(!w)throw Error("Unsupported curve");return w}case ve.publicKey.x448:return _.get("x448");case ve.publicKey.ed448:return _.get("ed448");default:throw Error("Unsupported curve")}},readNumber:function(w){let O=0;for(let _=0;_<w.length;_++)O+=256**_*w[w.length-1-_];return O},writeNumber:function(w,O){const _=new Uint8Array(O);for(let N=0;N<O;N++)_[N]=w>>8*(O-N-1)&255;return _},readDate:function(w){const O=Be.readNumber(w);return new Date(1e3*O)},writeDate:function(w){const O=Math.floor(w.getTime()/1e3);return Be.writeNumber(O,4)},normalizeDate:function(w=Date.now()){return null===w||w===1/0?w:new Date(1e3*Math.floor(+w/1e3))},readMPI:function(w){const O=(w[0]<<8|w[1])+7>>>3;return Be.readExactSubarray(w,2,2+O)},readExactSubarray:function(w,O,_){if(w.length<_-O)throw Error("Input array too short");return w.subarray(O,_)},leftPad(w,O){if(w.length>O)throw Error("Input array too long");const _=new Uint8Array(O),N=O-w.length;return _.set(w,N),_},uint8ArrayToMPI:function(w){const O=Be.uint8ArrayBitLength(w);if(0===O)throw Error("Zero MPI");const _=w.subarray(w.length-Math.ceil(O/8)),N=new Uint8Array([(65280&O)>>8,255&O]);return Be.concatUint8Array([N,_])},uint8ArrayBitLength:function(w){let O;for(O=0;O<w.length&&0===w[O];O++);if(O===w.length)return 0;const _=w.subarray(O);return 8*(_.length-1)+Be.nbits(_[0])},hexToUint8Array:function(w){const O=new Uint8Array(w.length>>1);for(let _=0;_<w.length>>1;_++)O[_]=parseInt(w.substr(_<<1,2),16);return O},uint8ArrayToHex:function(w){const O="0123456789abcdef";let _="";return w.forEach((w=>{_+=O[w>>4]+O[15&w]})),_},stringToUint8Array:function(w){return S(w,(w=>{if(!Be.isString(w))throw Error("stringToUint8Array: Data must be in the form of a string");const O=new Uint8Array(w.length);for(let _=0;_<w.length;_++)O[_]=w.charCodeAt(_);return O}))},uint8ArrayToString:function(w){const O=[],_=16384,N=(w=new Uint8Array(w)).length;for(let F=0;F<N;F+=_)O.push(String.fromCharCode.apply(String,w.subarray(F,F+_<N?F+_:N)));return O.join("")},encodeUTF8:function(w){const O=new TextEncoder("utf-8");function r(w,_=!1){return O.encode(w,{stream:!_})}return S(w,r,(()=>r("",!0)))},decodeUTF8:function(w){const O=new TextDecoder("utf-8");function r(w,_=!1){return O.decode(w,{stream:!_})}return S(w,r,(()=>r(new Uint8Array,!0)))},concat:E,concatUint8Array:d,equalsUint8Array:function(w,O){if(!Be.isUint8Array(w)||!Be.isUint8Array(O))throw Error("Data must be in the form of a Uint8Array");if(w.length!==O.length)return!1;for(let _=0;_<w.length;_++)if(w[_]!==O[_])return!1;return!0},writeChecksum:function(w){let O=0;for(let _=0;_<w.length;_++)O=O+w[_]&65535;return Be.writeNumber(O,2)},printDebug:function(w){Ie&&console.log("[OpenPGP.js debug]",w)},printDebugError:function(w){Ie&&console.error("[OpenPGP.js debug]",w)},nbits:function(w){let O=1,_=w>>>16;return 0!==_&&(w=_,O+=16),_=w>>8,0!==_&&(w=_,O+=8),_=w>>4,0!==_&&(w=_,O+=4),_=w>>2,0!==_&&(w=_,O+=2),_=w>>1,0!==_&&(w=_,O+=1),O},double:function(w){const O=new Uint8Array(w.length),_=w.length-1;for(let N=0;N<_;N++)O[N]=w[N]<<1^w[N+1]>>7;return O[_]=w[_]<<1^135*(w[0]>>7),O},shiftRight:function(w,O){if(O)for(let _=w.length-1;_>=0;_--)w[_]>>=O,_>0&&(w[_]|=w[_-1]<<8-O);return w},getWebCrypto:function(){const w=void 0!==N&&N.crypto&&N.crypto.subtle||this.getNodeCrypto()?.webcrypto.subtle;if(!w)throw Error("The WebCrypto API is not available");return w},getNodeCrypto:function(){return this.nodeRequire("crypto")},getNodeZlib:function(){return this.nodeRequire("zlib")},getNodeBuffer:function(){return(this.nodeRequire("buffer")||{}).Buffer},getHardwareConcurrency:function(){if("undefined"!=typeof navigator)return navigator.hardwareConcurrency||1;return this.nodeRequire("os").cpus().length},isEmailAddress:function(w){if(!Be.isString(w))return!1;return/^[^\p{C}\p{Z}@<>\\]+@[^\p{C}\p{Z}@<>\\]+[^\p{C}\p{Z}\p{P}]$/u.test(w)},canonicalizeEOL:function(w){let O=!1;return S(w,(w=>{let _;O&&(w=Be.concatUint8Array([new Uint8Array([13]),w])),13===w[w.length-1]?(O=!0,w=w.subarray(0,-1)):O=!1;const N=[];for(let O=0;_=w.indexOf(10,O)+1,_;O=_)13!==w[_-2]&&N.push(_);if(!N.length)return w;const F=new Uint8Array(w.length+N.length);let H=0;for(let O=0;O<N.length;O++){const _=w.subarray(N[O-1]||0,N[O]);F.set(_,H),H+=_.length,F[H-1]=13,F[H]=10,H++}return F.set(w.subarray(N[N.length-1]||0),H),F}),(()=>O?new Uint8Array([13]):void 0))},nativeEOL:function(w){let O=!1;return S(w,(w=>{let _;13===(w=O&&10!==w[0]?Be.concatUint8Array([new Uint8Array([13]),w]):new Uint8Array(w))[w.length-1]?(O=!0,w=w.subarray(0,-1)):O=!1;let N=0;for(let O=0;O!==w.length;O=_){_=w.indexOf(13,O)+1,_||(_=w.length);const F=_-(10===w[_]?1:0);O&&w.copyWithin(N,O,F),N+=F-O}return w.subarray(0,N)}),(()=>O?new Uint8Array([13]):void 0))},removeTrailingSpaces:function(w){return w.split("\n").map((w=>{let O=w.length-1;for(;O>=0&&(" "===w[O]||"\t"===w[O]||"\r"===w[O]);O--);return w.substr(0,O+1)})).join("\n")},wrapError:function(w,O){if(!O)return Error(w);try{O.message=w+": "+O.message}catch(w){}return O},constructAllowedPackets:function(w){const O={};return w.forEach((w=>{if(!w.tag)throw Error("Invalid input: expected a packet class");O[w.tag]=w})),O},anyPromise:function(w){return new Promise((async(O,_)=>{let N;await Promise.all(w.map((async w=>{try{O(await w)}catch(w){N=w}}))),_(N)}))},selectUint8Array:function(w,O,_){const N=Math.max(O.length,_.length),F=new Uint8Array(N);let H=0;for(let N=0;N<F.length;N++)F[N]=O[N]&256-w|_[N]&255+w,H+=w&N<O.length|1-w&N<_.length;return F.subarray(0,H)},selectUint8:function(w,O,_){return O&256-w|_&255+w},isAES:function(w){return w===ve.symmetric.aes128||w===ve.symmetric.aes192||w===ve.symmetric.aes256}},Pe=Be.getNodeBuffer();let xe,De;function q(w){let O=new Uint8Array;return S(w,(w=>{O=Be.concatUint8Array([O,w]);const _=[],N=Math.floor(O.length/45),F=45*N,H=xe(O.subarray(0,F));for(let w=0;w<N;w++)_.push(H.substr(60*w,60)),_.push("\n");return O=O.subarray(F),_.join("")}),(()=>O.length?xe(O)+"\n":""))}function V(w){let O="";return S(w,(w=>{O+=w;let _=0;const N=[" ","\t","\r","\n"];for(let w=0;w<N.length;w++){const F=N[w];for(let w=O.indexOf(F);-1!==w;w=O.indexOf(F,w+1))_++}let F=O.length;for(;F>0&&(F-_)%4!=0;F--)N.includes(O[F])&&_--;const H=De(O.substr(0,F));return O=O.substr(F),H}),(()=>De(O)))}function J(w){return V(w.replace(/-/g,"+").replace(/_/g,"/"))}function Y(w,O){let _=q(w).replace(/[\r\n]/g,"");return _=_.replace(/[+]/g,"-").replace(/[/]/g,"_").replace(/[=]/g,""),_}function Z(w){const O=w.match(/^-----BEGIN PGP (MESSAGE, PART \d+\/\d+|MESSAGE, PART \d+|SIGNED MESSAGE|MESSAGE|PUBLIC KEY BLOCK|PRIVATE KEY BLOCK|SIGNATURE)-----$/m);if(!O)throw Error("Unknown ASCII armor type");return/MESSAGE, PART \d+\/\d+/.test(O[1])?ve.armor.multipartSection:/MESSAGE, PART \d+/.test(O[1])?ve.armor.multipartLast:/SIGNED MESSAGE/.test(O[1])?ve.armor.signed:/MESSAGE/.test(O[1])?ve.armor.message:/PUBLIC KEY BLOCK/.test(O[1])?ve.armor.publicKey:/PRIVATE KEY BLOCK/.test(O[1])?ve.armor.privateKey:/SIGNATURE/.test(O[1])?ve.armor.signature:void 0}function W(w,O){let _="";return O.showVersion&&(_+="Version: "+O.versionString+"\n"),O.showComment&&(_+="Comment: "+O.commentString+"\n"),w&&(_+="Comment: "+w+"\n"),_+="\n",_}function $(w){const O=function(w){let O=13501623;return S(w,(w=>{const _=Oe?Math.floor(w.length/4):0,N=new Uint32Array(w.buffer,w.byteOffset,_);for(let w=0;w<_;w++)O^=N[w],O=Ue[0][O>>24&255]^Ue[1][O>>16&255]^Ue[2][O>>8&255]^Ue[3][255&O];for(let N=4*_;N<w.length;N++)O=O>>8^Ue[0][255&O^w[N]]}),(()=>new Uint8Array([O,O>>8,O>>16])))}(w);return q(O)}Pe?(xe=w=>Pe.from(w).toString("base64"),De=w=>{const O=Pe.from(w,"base64");return new Uint8Array(O.buffer,O.byteOffset,O.byteLength)}):(xe=w=>btoa(Be.uint8ArrayToString(w)),De=w=>Be.stringToUint8Array(atob(w)));const Ue=[Array(255),Array(255),Array(255),Array(255)];for(let w=0;w<=255;w++){let O=w<<16;for(let w=0;w<8;w++)O=O<<1^(8388608&O?8801531:0);Ue[0][w]=(16711680&O)>>16|65280&O|(255&O)<<16}for(let w=0;w<=255;w++)Ue[1][w]=Ue[0][w]>>8^Ue[0][255&Ue[0][w]];for(let w=0;w<=255;w++)Ue[2][w]=Ue[1][w]>>8^Ue[0][255&Ue[1][w]];for(let w=0;w<=255;w++)Ue[3][w]=Ue[2][w]>>8^Ue[0][255&Ue[2][w]];const Oe=function(){const w=new ArrayBuffer(2);return new DataView(w).setInt16(0,255,!0),255===new Int16Array(w)[0]}();function te(w){for(let O=0;O<w.length;O++)/^([^\s:]|[^\s:][^:]*[^\s:]): .+$/.test(w[O])||Be.printDebugError(Error("Improperly formatted armor header: "+w[O])),/^(Version|Comment|MessageID|Hash|Charset): .+$/.test(w[O])||Be.printDebugError(Error("Unknown header: "+w[O]))}function re(w){let O=w;const _=w.lastIndexOf("=");return _>=0&&_!==w.length-1&&(O=w.slice(0,_)),O}function ne(w){return new Promise((async(O,_)=>{try{const N=/^-----[^-]+-----$/m,F=/^[ \f\r\t\u00a0\u2000-\u200a\u202f\u205f\u3000]*$/;let H;const j=[];let G,z,X=j,ee=[];const se=V(K(w,(async(w,ae)=>{const Ae=L(w);try{for(;;){let w=await Ae.readLine();if(void 0===w)throw Error("Misformed armored text");if(w=Be.removeTrailingSpaces(w.replace(/[\r\n]/g,"")),H)if(G)z||H!==ve.armor.signed||(N.test(w)?(ee=ee.join("\r\n"),z=!0,te(X),X=[],G=!1):ee.push(w.replace(/^- /,"")));else if(N.test(w)&&_(Error("Mandatory blank line missing between armor headers and armor data")),F.test(w)){if(te(X),G=!0,z||H!==ve.armor.signed){O({text:ee,data:se,headers:j,type:H});break}}else X.push(w);else N.test(w)&&(H=Z(w))}}catch(w){return void _(w)}const be=M(ae);try{for(;;){await be.ready;const{done:w,value:O}=await Ae.read();if(w)throw Error("Misformed armored text");const _=O+"";if(-1!==_.indexOf("=")||-1!==_.indexOf("-")){let w=await Ae.readToEnd();w.length||(w=""),w=_+w,w=Be.removeTrailingSpaces(w.replace(/\r/g,""));const O=w.split(N);if(1===O.length)throw Error("Misformed armored text");const F=re(O[0].slice(0,-1));await be.write(F);break}await be.write(_)}await be.ready,await be.close()}catch(w){await be.abort(w)}})))}catch(w){_(w)}})).then((async w=>(y(w.data)&&(w.data=await Q(w.data)),w)))}function ie(w,O,_,N,F,H=!1,j=Se){let G,z;w===ve.armor.signed&&(G=O.text,z=O.hash,O=O.data);const X=H&&U(O),ee=[];switch(w){case ve.armor.multipartSection:ee.push("-----BEGIN PGP MESSAGE, PART "+_+"/"+N+"-----\n"),ee.push(W(F,j)),ee.push(q(O)),X&&ee.push("=",$(X)),ee.push("-----END PGP MESSAGE, PART "+_+"/"+N+"-----\n");break;case ve.armor.multipartLast:ee.push("-----BEGIN PGP MESSAGE, PART "+_+"-----\n"),ee.push(W(F,j)),ee.push(q(O)),X&&ee.push("=",$(X)),ee.push("-----END PGP MESSAGE, PART "+_+"-----\n");break;case ve.armor.signed:ee.push("-----BEGIN PGP SIGNED MESSAGE-----\n"),ee.push(z?`Hash: ${z}\n\n`:"\n"),ee.push(G.replace(/^-/gm,"- -")),ee.push("\n-----BEGIN PGP SIGNATURE-----\n"),ee.push(W(F,j)),ee.push(q(O)),X&&ee.push("=",$(X)),ee.push("-----END PGP SIGNATURE-----\n");break;case ve.armor.message:ee.push("-----BEGIN PGP MESSAGE-----\n"),ee.push(W(F,j)),ee.push(q(O)),X&&ee.push("=",$(X)),ee.push("-----END PGP MESSAGE-----\n");break;case ve.armor.publicKey:ee.push("-----BEGIN PGP PUBLIC KEY BLOCK-----\n"),ee.push(W(F,j)),ee.push(q(O)),X&&ee.push("=",$(X)),ee.push("-----END PGP PUBLIC KEY BLOCK-----\n");break;case ve.armor.privateKey:ee.push("-----BEGIN PGP PRIVATE KEY BLOCK-----\n"),ee.push(W(F,j)),ee.push(q(O)),X&&ee.push("=",$(X)),ee.push("-----END PGP PRIVATE KEY BLOCK-----\n");break;case ve.armor.signature:ee.push("-----BEGIN PGP SIGNATURE-----\n"),ee.push(W(F,j)),ee.push(q(O)),X&&ee.push("=",$(X)),ee.push("-----END PGP SIGNATURE-----\n")}return Be.concat(ee)}const _e=BigInt(0),Re=BigInt(1);function oe(w){const O="0123456789ABCDEF";let _="";return w.forEach((w=>{_+=O[w>>4]+O[15&w]})),BigInt("0x0"+_)}function ce(w,O){const _=w%O;return _<_e?_+O:_}function he(w,O,_){if(_===_e)throw Error("Modulo cannot be zero");if(_===Re)return BigInt(0);if(O<_e)throw Error("Unsopported negative exponent");let N=O,F=w;F%=_;let H=BigInt(1);for(;N>_e;){const w=N&Re;N>>=Re;H=w?H*F%_:H,F=F*F%_}return H}function ue(w){return w>=_e?w:-w}function le(w,O){const{gcd:_,x:N}=function(w,O){let _=BigInt(0),N=BigInt(1),F=BigInt(1),H=BigInt(0),j=ue(w),G=ue(O);const z=w<_e,X=O<_e;for(;G!==_e;){const w=j/G;let O=_;_=F-w*_,F=O,O=N,N=H-w*N,H=O,O=G,G=j%G,j=O}return{x:z?-F:F,y:X?-H:H,gcd:j}}(w,O);if(_!==Re)throw Error("Inverse does not exist");return ce(N+O,O)}function ye(w){const O=Number(w);if(O>Number.MAX_SAFE_INTEGER)throw Error("Number can only safely store up to 53 bits");return O}function fe(w,O){return(w>>BigInt(O)&Re)===_e?0:1}function ge(w){const O=w<_e?BigInt(-1):_e;let _=1,N=w;for(;(N>>=Re)!==O;)_++;return _}function pe(w){const O=w<_e?BigInt(-1):_e,_=BigInt(8);let N=1,F=w;for(;(F>>=_)!==O;)N++;return N}function de(w,O="be",_){let N=w.toString(16);N.length%2==1&&(N="0"+N);const F=N.length/2,H=new Uint8Array(_||F),j=_?_-F:0;let G=0;for(;G<F;)H[G+j]=parseInt(N.slice(2*G,2*G+2),16),G++;return"be"!==O&&H.reverse(),H}const Te=Be.getNodeCrypto();function we(w){const O="undefined"!=typeof crypto?crypto:Te?.webcrypto;if(O?.getRandomValues){const _=new Uint8Array(w);return O.getRandomValues(_)}throw Error("No secure random number generator available.")}function me(w,O){if(O<w)throw Error("Illegal parameter value: max <= min");const _=O-w;return ce(oe(we(pe(_)+8)),_)+w}const Qe=BigInt(1);function ke(w,O,_){const N=BigInt(30),F=Qe<<BigInt(w-1),H=[1,6,5,4,3,2,1,4,3,2,1,2,1,4,3,2,1,2,1,4,3,2,1,6,5,4,3,2,1,2];let j=me(F,F<<Qe),G=ye(ce(j,N));do{j+=BigInt(H[G]),G=(G+H[G])%H.length,ge(j)>w&&(j=ce(j,F<<Qe),j+=F,G=ye(ce(j,N)))}while(!Ee(j,O,_));return j}function Ee(w,O,_){return(!O||function(w,O){let _=w,N=O;for(;N!==_e;){const w=N;N=_%N,_=w}return _}(w-Qe,O)===Qe)&&(!!function(w){const O=BigInt(0);return Me.every((_=>ce(w,_)!==O))}(w)&&(!!function(w,O=BigInt(2)){return he(O,w-Qe,w)===Qe}(w)&&!!function(w,O){const _=ge(w);O||(O=Math.max(1,_/48|0));const N=w-Qe;let F=0;for(;!fe(N,F);)F++;const H=w>>BigInt(F);for(;O>0;O--){let O,_=he(me(BigInt(2),N),H,w);if(_!==Qe&&_!==N){for(O=1;O<F;O++){if(_=ce(_*_,w),_===Qe)return!1;if(_===N)break}if(O===F)return!1}}return!0}(w,_)))}const Me=[7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999].map((w=>BigInt(w)));const Le=Be.getWebCrypto(),je=Be.getNodeCrypto(),qe=je&&je.getHashes();function Ke(w){if(je&&qe.includes(w))return async function(O){const _=je.createHash(w);return S(O,(w=>{_.update(w)}),(()=>new Uint8Array(_.digest())))}}function Ce(w,O){const r=async()=>{const{nobleHashes:O}=await Promise.resolve().then((function(){return hf})),_=O.get(w);if(!_)throw Error("Unsupported hash");return _};return async function(w){if(y(w)&&(w=await Q(w)),Be.isStream(w)){const O=(await r()).create();return S(w,(w=>{O.update(w)}),(()=>O.digest()))}if(Le&&O)return new Uint8Array(await Le.digest(O,w));return(await r())(w)}}const et=Ke("md5")||Ce("md5"),tt=Ke("sha1")||Ce("sha1","SHA-1"),rt=Ke("sha224")||Ce("sha224"),st=Ke("sha256")||Ce("sha256","SHA-256"),at=Ke("sha384")||Ce("sha384","SHA-384"),ot=Ke("sha512")||Ce("sha512","SHA-512"),ct=Ke("ripemd160")||Ce("ripemd160"),ut=Ke("sha3-256")||Ce("sha3_256"),ht=Ke("sha3-512")||Ce("sha3_512");function Ne(w,O){switch(w){case ve.hash.md5:return et(O);case ve.hash.sha1:return tt(O);case ve.hash.ripemd:return ct(O);case ve.hash.sha256:return st(O);case ve.hash.sha384:return at(O);case ve.hash.sha512:return ot(O);case ve.hash.sha224:return rt(O);case ve.hash.sha3_256:return ut(O);case ve.hash.sha3_512:return ht(O);default:throw Error("Unsupported hash function")}}function Fe(w){switch(w){case ve.hash.md5:return 16;case ve.hash.sha1:case ve.hash.ripemd:return 20;case ve.hash.sha256:return 32;case ve.hash.sha384:return 48;case ve.hash.sha512:return 64;case ve.hash.sha224:return 28;case ve.hash.sha3_256:return 32;case ve.hash.sha3_512:return 64;default:throw Error("Invalid hash algorithm.")}}const lt=[];function He(w,O){const _=w.length;if(_>O-11)throw Error("Message too long");const N=function(w){const O=new Uint8Array(w);let _=0;for(;_<w;){const N=we(w-_);for(let w=0;w<N.length;w++)0!==N[w]&&(O[_++]=N[w])}return O}(O-_-3),F=new Uint8Array(O);return F[1]=2,F.set(N,2),F.set(w,O-_),F}function ze(w,O){let _=2,N=1;for(let O=_;O<w.length;O++)N&=0!==w[O],_+=N;const F=_-2,H=w.subarray(_+1),j=0===w[0]&2===w[1]&F>=8&!N;if(O)return Be.selectUint8Array(j,H,O);if(j)return H;throw Error("Decryption error")}function Ge(w,O,_){let N;if(O.length!==Fe(w))throw Error("Invalid hash length");const F=new Uint8Array(lt[w].length);for(N=0;N<lt[w].length;N++)F[N]=lt[w][N];const H=F.length+O.length;if(_<H+11)throw Error("Intended encoded message length too short");const j=new Uint8Array(_-H-3).fill(255),G=new Uint8Array(_);return G[1]=1,G.set(j,2),G.set(F,_-H),G.set(O,_-O.length),G}lt[1]=[48,32,48,12,6,8,42,134,72,134,247,13,2,5,5,0,4,16],lt[2]=[48,33,48,9,6,5,43,14,3,2,26,5,0,4,20],lt[3]=[48,33,48,9,6,5,43,36,3,2,1,5,0,4,20],lt[8]=[48,49,48,13,6,9,96,134,72,1,101,3,4,2,1,5,0,4,32],lt[9]=[48,65,48,13,6,9,96,134,72,1,101,3,4,2,2,5,0,4,48],lt[10]=[48,81,48,13,6,9,96,134,72,1,101,3,4,2,3,5,0,4,64],lt[11]=[48,45,48,13,6,9,96,134,72,1,101,3,4,2,4,5,0,4,28];const ft=Be.getWebCrypto(),yt=Be.getNodeCrypto(),Ut=BigInt(1);async function Ve(w,O,_,N,F,H,j,G,z){if(Fe(w)>=_.length)throw Error("Digest size cannot exceed key modulus size");if(O&&!Be.isStream(O))if(Be.getWebCrypto())try{return await async function(w,O,_,N,F,H,j,G){const z=await We(_,N,F,H,j,G),X={name:"RSASSA-PKCS1-v1_5",hash:{name:w}},ee=await ft.importKey("jwk",z,X,!1,["sign"]);return new Uint8Array(await ft.sign("RSASSA-PKCS1-v1_5",ee,O))}(ve.read(ve.webHash,w),O,_,N,F,H,j,G)}catch(w){Be.printDebugError(w)}else if(Be.getNodeCrypto())return async function(w,O,_,N,F,H,j,G){const z=yt.createSign(ve.read(ve.hash,w));z.write(O),z.end();const X=await We(_,N,F,H,j,G);return new Uint8Array(z.sign({key:X,format:"jwk",type:"pkcs1"}))}(w,O,_,N,F,H,j,G);return async function(w,O,_,N){O=oe(O);const F=oe(Ge(w,N,pe(O)));return _=oe(_),de(he(F,_,O),"be",pe(O))}(w,_,F,z)}async function Je(w,O,_,N,F,H){if(O&&!Be.isStream(O))if(Be.getWebCrypto())try{return await async function(w,O,_,N,F){const H=$e(N,F),j=await ft.importKey("jwk",H,{name:"RSASSA-PKCS1-v1_5",hash:{name:w}},!1,["verify"]);return ft.verify("RSASSA-PKCS1-v1_5",j,_,O)}(ve.read(ve.webHash,w),O,_,N,F)}catch(w){Be.printDebugError(w)}else if(Be.getNodeCrypto())return async function(w,O,_,N,F){const H=$e(N,F),j={key:H,format:"jwk",type:"pkcs1"},G=yt.createVerify(ve.read(ve.hash,w));G.write(O),G.end();try{return G.verify(j,_)}catch(w){return!1}}(w,O,_,N,F);return async function(w,O,_,N,F){if(_=oe(_),O=oe(O),N=oe(N),O>=_)throw Error("Signature size cannot exceed modulus size");const H=de(he(O,N,_),"be",pe(_)),j=Ge(w,F,pe(_));return Be.equalsUint8Array(H,j)}(w,_,N,F,H)}async function Ye(w,O,_){return Be.getNodeCrypto()?async function(w,O,_){const N=$e(O,_),F={key:N,format:"jwk",type:"pkcs1",padding:yt.constants.RSA_PKCS1_PADDING};return new Uint8Array(yt.publicEncrypt(F,w))}(w,O,_):async function(w,O,_){if(O=oe(O),w=oe(He(w,pe(O))),_=oe(_),w>=O)throw Error("Message size cannot exceed modulus size");return de(he(w,_,O),"be",pe(O))}(w,O,_)}async function Ze(w,O,_,N,F,H,j,G){if(Be.getNodeCrypto()&&!G)try{return await async function(w,O,_,N,F,H,j){const G=await We(O,_,N,F,H,j),z={key:G,format:"jwk",type:"pkcs1",padding:yt.constants.RSA_PKCS1_PADDING};try{return new Uint8Array(yt.privateDecrypt(z,w))}catch(w){throw Error("Decryption error")}}(w,O,_,N,F,H,j)}catch(w){Be.printDebugError(w)}return async function(w,O,_,N,F,H,j,G){if(w=oe(w),O=oe(O),_=oe(_),N=oe(N),F=oe(F),H=oe(H),j=oe(j),w>=O)throw Error("Data too large.");const z=ce(N,H-Ut),X=ce(N,F-Ut),ee=me(BigInt(2),O),se=he(le(ee,O),_,O);w=ce(w*se,O);const ae=he(w,X,F),Ae=he(w,z,H),be=ce(j*(Ae-ae),H);let ve=be*F+ae;return ve=ce(ve*ee,O),ze(de(ve,"be",pe(O)),G)}(w,O,_,N,F,H,j,G)}async function We(w,O,_,N,F,H){const j=oe(N),G=oe(F),z=oe(_);let X=ce(z,G-Ut),ee=ce(z,j-Ut);return ee=de(ee),X=de(X),{kty:"RSA",n:Y(w),e:Y(O),d:Y(_),p:Y(F),q:Y(N),dp:Y(X),dq:Y(ee),qi:Y(H),ext:!0}}function $e(w,O){return{kty:"RSA",n:Y(w),e:Y(O),ext:!0}}function Xe(w,O){return{n:J(w.n),e:de(O),d:J(w.d),p:J(w.q),q:J(w.p),u:J(w.qi)}}const Ft=BigInt(1);const jt=G&&"object"==typeof G&&"webcrypto"in G?G.webcrypto:void 0,Gt={};var nt=function(w){var O,_=new Float64Array(16);if(w)for(O=0;O<w.length;O++)_[O]=w[O];return _},it=function(){throw Error("no PRNG")},lr=new Uint8Array(32);lr[0]=9;var Sr=nt(),Cr=nt([1]),Kr=nt([56129,1]),Or=nt([30883,4953,19914,30187,55467,16705,2637,112,59544,30585,16505,36039,65139,11119,27886,20995]),Rr=nt([61785,9906,39828,60374,45398,33411,5274,224,53552,61171,33010,6542,64743,22239,55772,9222]),Tr=nt([54554,36645,11616,51542,42930,38181,51040,26924,56412,64982,57905,49316,21502,52590,14035,8553]),Qr=nt([26200,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214]),Lr=nt([41136,18958,6951,50414,58488,44335,6150,12099,55207,15867,153,11085,57099,20417,9344,11139]);function gt(w,O,_,N){w[O]=_>>24&255,w[O+1]=_>>16&255,w[O+2]=_>>8&255,w[O+3]=255&_,w[O+4]=N>>24&255,w[O+5]=N>>16&255,w[O+6]=N>>8&255,w[O+7]=255&N}function pt(w,O,_,N){return function(w,O,_,N,F){var H,j=0;for(H=0;H<F;H++)j|=w[O+H]^_[N+H];return(1&j-1>>>8)-1}(w,O,_,N,32)}function dt(w,O){var _;for(_=0;_<16;_++)w[_]=0|O[_]}function At(w){var O,_,N=1;for(O=0;O<16;O++)_=w[O]+N+65535,N=Math.floor(_/65536),w[O]=_-65536*N;w[0]+=N-1+37*(N-1)}function wt(w,O,_){for(var N,F=~(_-1),H=0;H<16;H++)N=F&(w[H]^O[H]),w[H]^=N,O[H]^=N}function mt(w,O){var _,N,F,H=nt(),j=nt();for(_=0;_<16;_++)j[_]=O[_];for(At(j),At(j),At(j),N=0;N<2;N++){for(H[0]=j[0]-65517,_=1;_<15;_++)H[_]=j[_]-65535-(H[_-1]>>16&1),H[_-1]&=65535;H[15]=j[15]-32767-(H[14]>>16&1),F=H[15]>>16&1,H[14]&=65535,wt(j,H,1-F)}for(_=0;_<16;_++)w[2*_]=255&j[_],w[2*_+1]=j[_]>>8}function bt(w,O){var _=new Uint8Array(32),N=new Uint8Array(32);return mt(_,w),mt(N,O),pt(_,0,N,0)}function kt(w){var O=new Uint8Array(32);return mt(O,w),1&O[0]}function Et(w,O){var _;for(_=0;_<16;_++)w[_]=O[2*_]+(O[2*_+1]<<8);w[15]&=32767}function vt(w,O,_){for(var N=0;N<16;N++)w[N]=O[N]+_[N]}function It(w,O,_){for(var N=0;N<16;N++)w[N]=O[N]-_[N]}function Bt(w,O,_){var N,F,H=0,j=0,G=0,z=0,X=0,ee=0,se=0,ae=0,Ae=0,be=0,ve=0,Se=0,Ie=0,Be=0,Pe=0,xe=0,De=0,Ue=0,Oe=0,_e=0,Re=0,Te=0,Qe=0,Me=0,Le=0,je=0,qe=0,et=0,tt=0,rt=0,st=0,at=_[0],ot=_[1],ct=_[2],ut=_[3],ht=_[4],lt=_[5],ft=_[6],yt=_[7],Ut=_[8],Ft=_[9],jt=_[10],Gt=_[11],lr=_[12],Sr=_[13],Cr=_[14],Kr=_[15];H+=(N=O[0])*at,j+=N*ot,G+=N*ct,z+=N*ut,X+=N*ht,ee+=N*lt,se+=N*ft,ae+=N*yt,Ae+=N*Ut,be+=N*Ft,ve+=N*jt,Se+=N*Gt,Ie+=N*lr,Be+=N*Sr,Pe+=N*Cr,xe+=N*Kr,j+=(N=O[1])*at,G+=N*ot,z+=N*ct,X+=N*ut,ee+=N*ht,se+=N*lt,ae+=N*ft,Ae+=N*yt,be+=N*Ut,ve+=N*Ft,Se+=N*jt,Ie+=N*Gt,Be+=N*lr,Pe+=N*Sr,xe+=N*Cr,De+=N*Kr,G+=(N=O[2])*at,z+=N*ot,X+=N*ct,ee+=N*ut,se+=N*ht,ae+=N*lt,Ae+=N*ft,be+=N*yt,ve+=N*Ut,Se+=N*Ft,Ie+=N*jt,Be+=N*Gt,Pe+=N*lr,xe+=N*Sr,De+=N*Cr,Ue+=N*Kr,z+=(N=O[3])*at,X+=N*ot,ee+=N*ct,se+=N*ut,ae+=N*ht,Ae+=N*lt,be+=N*ft,ve+=N*yt,Se+=N*Ut,Ie+=N*Ft,Be+=N*jt,Pe+=N*Gt,xe+=N*lr,De+=N*Sr,Ue+=N*Cr,Oe+=N*Kr,X+=(N=O[4])*at,ee+=N*ot,se+=N*ct,ae+=N*ut,Ae+=N*ht,be+=N*lt,ve+=N*ft,Se+=N*yt,Ie+=N*Ut,Be+=N*Ft,Pe+=N*jt,xe+=N*Gt,De+=N*lr,Ue+=N*Sr,Oe+=N*Cr,_e+=N*Kr,ee+=(N=O[5])*at,se+=N*ot,ae+=N*ct,Ae+=N*ut,be+=N*ht,ve+=N*lt,Se+=N*ft,Ie+=N*yt,Be+=N*Ut,Pe+=N*Ft,xe+=N*jt,De+=N*Gt,Ue+=N*lr,Oe+=N*Sr,_e+=N*Cr,Re+=N*Kr,se+=(N=O[6])*at,ae+=N*ot,Ae+=N*ct,be+=N*ut,ve+=N*ht,Se+=N*lt,Ie+=N*ft,Be+=N*yt,Pe+=N*Ut,xe+=N*Ft,De+=N*jt,Ue+=N*Gt,Oe+=N*lr,_e+=N*Sr,Re+=N*Cr,Te+=N*Kr,ae+=(N=O[7])*at,Ae+=N*ot,be+=N*ct,ve+=N*ut,Se+=N*ht,Ie+=N*lt,Be+=N*ft,Pe+=N*yt,xe+=N*Ut,De+=N*Ft,Ue+=N*jt,Oe+=N*Gt,_e+=N*lr,Re+=N*Sr,Te+=N*Cr,Qe+=N*Kr,Ae+=(N=O[8])*at,be+=N*ot,ve+=N*ct,Se+=N*ut,Ie+=N*ht,Be+=N*lt,Pe+=N*ft,xe+=N*yt,De+=N*Ut,Ue+=N*Ft,Oe+=N*jt,_e+=N*Gt,Re+=N*lr,Te+=N*Sr,Qe+=N*Cr,Me+=N*Kr,be+=(N=O[9])*at,ve+=N*ot,Se+=N*ct,Ie+=N*ut,Be+=N*ht,Pe+=N*lt,xe+=N*ft,De+=N*yt,Ue+=N*Ut,Oe+=N*Ft,_e+=N*jt,Re+=N*Gt,Te+=N*lr,Qe+=N*Sr,Me+=N*Cr,Le+=N*Kr,ve+=(N=O[10])*at,Se+=N*ot,Ie+=N*ct,Be+=N*ut,Pe+=N*ht,xe+=N*lt,De+=N*ft,Ue+=N*yt,Oe+=N*Ut,_e+=N*Ft,Re+=N*jt,Te+=N*Gt,Qe+=N*lr,Me+=N*Sr,Le+=N*Cr,je+=N*Kr,Se+=(N=O[11])*at,Ie+=N*ot,Be+=N*ct,Pe+=N*ut,xe+=N*ht,De+=N*lt,Ue+=N*ft,Oe+=N*yt,_e+=N*Ut,Re+=N*Ft,Te+=N*jt,Qe+=N*Gt,Me+=N*lr,Le+=N*Sr,je+=N*Cr,qe+=N*Kr,Ie+=(N=O[12])*at,Be+=N*ot,Pe+=N*ct,xe+=N*ut,De+=N*ht,Ue+=N*lt,Oe+=N*ft,_e+=N*yt,Re+=N*Ut,Te+=N*Ft,Qe+=N*jt,Me+=N*Gt,Le+=N*lr,je+=N*Sr,qe+=N*Cr,et+=N*Kr,Be+=(N=O[13])*at,Pe+=N*ot,xe+=N*ct,De+=N*ut,Ue+=N*ht,Oe+=N*lt,_e+=N*ft,Re+=N*yt,Te+=N*Ut,Qe+=N*Ft,Me+=N*jt,Le+=N*Gt,je+=N*lr,qe+=N*Sr,et+=N*Cr,tt+=N*Kr,Pe+=(N=O[14])*at,xe+=N*ot,De+=N*ct,Ue+=N*ut,Oe+=N*ht,_e+=N*lt,Re+=N*ft,Te+=N*yt,Qe+=N*Ut,Me+=N*Ft,Le+=N*jt,je+=N*Gt,qe+=N*lr,et+=N*Sr,tt+=N*Cr,rt+=N*Kr,xe+=(N=O[15])*at,j+=38*(Ue+=N*ct),G+=38*(Oe+=N*ut),z+=38*(_e+=N*ht),X+=38*(Re+=N*lt),ee+=38*(Te+=N*ft),se+=38*(Qe+=N*yt),ae+=38*(Me+=N*Ut),Ae+=38*(Le+=N*Ft),be+=38*(je+=N*jt),ve+=38*(qe+=N*Gt),Se+=38*(et+=N*lr),Ie+=38*(tt+=N*Sr),Be+=38*(rt+=N*Cr),Pe+=38*(st+=N*Kr),H=(N=(H+=38*(De+=N*ot))+(F=1)+65535)-65536*(F=Math.floor(N/65536)),j=(N=j+F+65535)-65536*(F=Math.floor(N/65536)),G=(N=G+F+65535)-65536*(F=Math.floor(N/65536)),z=(N=z+F+65535)-65536*(F=Math.floor(N/65536)),X=(N=X+F+65535)-65536*(F=Math.floor(N/65536)),ee=(N=ee+F+65535)-65536*(F=Math.floor(N/65536)),se=(N=se+F+65535)-65536*(F=Math.floor(N/65536)),ae=(N=ae+F+65535)-65536*(F=Math.floor(N/65536)),Ae=(N=Ae+F+65535)-65536*(F=Math.floor(N/65536)),be=(N=be+F+65535)-65536*(F=Math.floor(N/65536)),ve=(N=ve+F+65535)-65536*(F=Math.floor(N/65536)),Se=(N=Se+F+65535)-65536*(F=Math.floor(N/65536)),Ie=(N=Ie+F+65535)-65536*(F=Math.floor(N/65536)),Be=(N=Be+F+65535)-65536*(F=Math.floor(N/65536)),Pe=(N=Pe+F+65535)-65536*(F=Math.floor(N/65536)),xe=(N=xe+F+65535)-65536*(F=Math.floor(N/65536)),H=(N=(H+=F-1+37*(F-1))+(F=1)+65535)-65536*(F=Math.floor(N/65536)),j=(N=j+F+65535)-65536*(F=Math.floor(N/65536)),G=(N=G+F+65535)-65536*(F=Math.floor(N/65536)),z=(N=z+F+65535)-65536*(F=Math.floor(N/65536)),X=(N=X+F+65535)-65536*(F=Math.floor(N/65536)),ee=(N=ee+F+65535)-65536*(F=Math.floor(N/65536)),se=(N=se+F+65535)-65536*(F=Math.floor(N/65536)),ae=(N=ae+F+65535)-65536*(F=Math.floor(N/65536)),Ae=(N=Ae+F+65535)-65536*(F=Math.floor(N/65536)),be=(N=be+F+65535)-65536*(F=Math.floor(N/65536)),ve=(N=ve+F+65535)-65536*(F=Math.floor(N/65536)),Se=(N=Se+F+65535)-65536*(F=Math.floor(N/65536)),Ie=(N=Ie+F+65535)-65536*(F=Math.floor(N/65536)),Be=(N=Be+F+65535)-65536*(F=Math.floor(N/65536)),Pe=(N=Pe+F+65535)-65536*(F=Math.floor(N/65536)),xe=(N=xe+F+65535)-65536*(F=Math.floor(N/65536)),H+=F-1+37*(F-1),w[0]=H,w[1]=j,w[2]=G,w[3]=z,w[4]=X,w[5]=ee,w[6]=se,w[7]=ae,w[8]=Ae,w[9]=be,w[10]=ve,w[11]=Se,w[12]=Ie,w[13]=Be,w[14]=Pe,w[15]=xe}function St(w,O){Bt(w,O,O)}function Kt(w,O){var _,N=nt();for(_=0;_<16;_++)N[_]=O[_];for(_=253;_>=0;_--)St(N,N),2!==_&&4!==_&&Bt(N,N,O);for(_=0;_<16;_++)w[_]=N[_]}function Ct(w,O,_){var N,F,H=new Uint8Array(32),j=new Float64Array(80),G=nt(),z=nt(),X=nt(),ee=nt(),se=nt(),ae=nt();for(F=0;F<31;F++)H[F]=O[F];for(H[31]=127&O[31]|64,H[0]&=248,Et(j,_),F=0;F<16;F++)z[F]=j[F],ee[F]=G[F]=X[F]=0;for(G[0]=ee[0]=1,F=254;F>=0;--F)wt(G,z,N=H[F>>>3]>>>(7&F)&1),wt(X,ee,N),vt(se,G,X),It(G,G,X),vt(X,z,ee),It(z,z,ee),St(ee,se),St(ae,G),Bt(G,X,G),Bt(X,z,se),vt(se,G,X),It(G,G,X),St(z,G),It(X,ee,ae),Bt(G,X,Kr),vt(G,G,ee),Bt(X,X,G),Bt(G,ee,ae),Bt(ee,z,j),St(z,se),wt(G,z,N),wt(X,ee,N);for(F=0;F<16;F++)j[F+16]=G[F],j[F+32]=X[F],j[F+48]=z[F],j[F+64]=ee[F];var Ae=j.subarray(32),be=j.subarray(16);return Kt(Ae,Ae),Bt(be,be,Ae),mt(w,be),0}function Dt(w,O){return Ct(w,O,lr)}var Fr=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function Pt(w,O,_,N){for(var F,H,j,G,z,X,ee,se,ae,Ae,be,ve,Se,Ie,Be,Pe,xe,De,Ue,Oe,_e,Re,Te,Qe,Me,Le,je=new Int32Array(16),qe=new Int32Array(16),et=w[0],tt=w[1],rt=w[2],st=w[3],at=w[4],ot=w[5],ct=w[6],ut=w[7],ht=O[0],lt=O[1],ft=O[2],yt=O[3],Ut=O[4],Ft=O[5],jt=O[6],Gt=O[7],lr=0;N>=128;){for(Ue=0;Ue<16;Ue++)Oe=8*Ue+lr,je[Ue]=_[Oe+0]<<24|_[Oe+1]<<16|_[Oe+2]<<8|_[Oe+3],qe[Ue]=_[Oe+4]<<24|_[Oe+5]<<16|_[Oe+6]<<8|_[Oe+7];for(Ue=0;Ue<80;Ue++)if(F=et,H=tt,j=rt,G=st,z=at,X=ot,ee=ct,ut,ae=ht,Ae=lt,be=ft,ve=yt,Se=Ut,Ie=Ft,Be=jt,Gt,Te=65535&(Re=Gt),Qe=Re>>>16,Me=65535&(_e=ut),Le=_e>>>16,Te+=65535&(Re=(Ut>>>14|at<<18)^(Ut>>>18|at<<14)^(at>>>9|Ut<<23)),Qe+=Re>>>16,Me+=65535&(_e=(at>>>14|Ut<<18)^(at>>>18|Ut<<14)^(Ut>>>9|at<<23)),Le+=_e>>>16,Te+=65535&(Re=Ut&Ft^~Ut&jt),Qe+=Re>>>16,Me+=65535&(_e=at&ot^~at&ct),Le+=_e>>>16,_e=Fr[2*Ue],Te+=65535&(Re=Fr[2*Ue+1]),Qe+=Re>>>16,Me+=65535&_e,Le+=_e>>>16,_e=je[Ue%16],Qe+=(Re=qe[Ue%16])>>>16,Me+=65535&_e,Le+=_e>>>16,Me+=(Qe+=(Te+=65535&Re)>>>16)>>>16,Te=65535&(Re=De=65535&Te|Qe<<16),Qe=Re>>>16,Me=65535&(_e=xe=65535&Me|(Le+=Me>>>16)<<16),Le=_e>>>16,Te+=65535&(Re=(ht>>>28|et<<4)^(et>>>2|ht<<30)^(et>>>7|ht<<25)),Qe+=Re>>>16,Me+=65535&(_e=(et>>>28|ht<<4)^(ht>>>2|et<<30)^(ht>>>7|et<<25)),Le+=_e>>>16,Qe+=(Re=ht&lt^ht&ft^lt&ft)>>>16,Me+=65535&(_e=et&tt^et&rt^tt&rt),Le+=_e>>>16,se=65535&(Me+=(Qe+=(Te+=65535&Re)>>>16)>>>16)|(Le+=Me>>>16)<<16,Pe=65535&Te|Qe<<16,Te=65535&(Re=ve),Qe=Re>>>16,Me=65535&(_e=G),Le=_e>>>16,Qe+=(Re=De)>>>16,Me+=65535&(_e=xe),Le+=_e>>>16,tt=F,rt=H,st=j,at=G=65535&(Me+=(Qe+=(Te+=65535&Re)>>>16)>>>16)|(Le+=Me>>>16)<<16,ot=z,ct=X,ut=ee,et=se,lt=ae,ft=Ae,yt=be,Ut=ve=65535&Te|Qe<<16,Ft=Se,jt=Ie,Gt=Be,ht=Pe,Ue%16==15)for(Oe=0;Oe<16;Oe++)_e=je[Oe],Te=65535&(Re=qe[Oe]),Qe=Re>>>16,Me=65535&_e,Le=_e>>>16,_e=je[(Oe+9)%16],Te+=65535&(Re=qe[(Oe+9)%16]),Qe+=Re>>>16,Me+=65535&_e,Le+=_e>>>16,xe=je[(Oe+1)%16],Te+=65535&(Re=((De=qe[(Oe+1)%16])>>>1|xe<<31)^(De>>>8|xe<<24)^(De>>>7|xe<<25)),Qe+=Re>>>16,Me+=65535&(_e=(xe>>>1|De<<31)^(xe>>>8|De<<24)^xe>>>7),Le+=_e>>>16,xe=je[(Oe+14)%16],Qe+=(Re=((De=qe[(Oe+14)%16])>>>19|xe<<13)^(xe>>>29|De<<3)^(De>>>6|xe<<26))>>>16,Me+=65535&(_e=(xe>>>19|De<<13)^(De>>>29|xe<<3)^xe>>>6),Le+=_e>>>16,Le+=(Me+=(Qe+=(Te+=65535&Re)>>>16)>>>16)>>>16,je[Oe]=65535&Me|Le<<16,qe[Oe]=65535&Te|Qe<<16;Te=65535&(Re=ht),Qe=Re>>>16,Me=65535&(_e=et),Le=_e>>>16,_e=w[0],Qe+=(Re=O[0])>>>16,Me+=65535&_e,Le+=_e>>>16,Le+=(Me+=(Qe+=(Te+=65535&Re)>>>16)>>>16)>>>16,w[0]=et=65535&Me|Le<<16,O[0]=ht=65535&Te|Qe<<16,Te=65535&(Re=lt),Qe=Re>>>16,Me=65535&(_e=tt),Le=_e>>>16,_e=w[1],Qe+=(Re=O[1])>>>16,Me+=65535&_e,Le+=_e>>>16,Le+=(Me+=(Qe+=(Te+=65535&Re)>>>16)>>>16)>>>16,w[1]=tt=65535&Me|Le<<16,O[1]=lt=65535&Te|Qe<<16,Te=65535&(Re=ft),Qe=Re>>>16,Me=65535&(_e=rt),Le=_e>>>16,_e=w[2],Qe+=(Re=O[2])>>>16,Me+=65535&_e,Le+=_e>>>16,Le+=(Me+=(Qe+=(Te+=65535&Re)>>>16)>>>16)>>>16,w[2]=rt=65535&Me|Le<<16,O[2]=ft=65535&Te|Qe<<16,Te=65535&(Re=yt),Qe=Re>>>16,Me=65535&(_e=st),Le=_e>>>16,_e=w[3],Qe+=(Re=O[3])>>>16,Me+=65535&_e,Le+=_e>>>16,Le+=(Me+=(Qe+=(Te+=65535&Re)>>>16)>>>16)>>>16,w[3]=st=65535&Me|Le<<16,O[3]=yt=65535&Te|Qe<<16,Te=65535&(Re=Ut),Qe=Re>>>16,Me=65535&(_e=at),Le=_e>>>16,_e=w[4],Qe+=(Re=O[4])>>>16,Me+=65535&_e,Le+=_e>>>16,Le+=(Me+=(Qe+=(Te+=65535&Re)>>>16)>>>16)>>>16,w[4]=at=65535&Me|Le<<16,O[4]=Ut=65535&Te|Qe<<16,Te=65535&(Re=Ft),Qe=Re>>>16,Me=65535&(_e=ot),Le=_e>>>16,_e=w[5],Qe+=(Re=O[5])>>>16,Me+=65535&_e,Le+=_e>>>16,Le+=(Me+=(Qe+=(Te+=65535&Re)>>>16)>>>16)>>>16,w[5]=ot=65535&Me|Le<<16,O[5]=Ft=65535&Te|Qe<<16,Te=65535&(Re=jt),Qe=Re>>>16,Me=65535&(_e=ct),Le=_e>>>16,_e=w[6],Qe+=(Re=O[6])>>>16,Me+=65535&_e,Le+=_e>>>16,Le+=(Me+=(Qe+=(Te+=65535&Re)>>>16)>>>16)>>>16,w[6]=ct=65535&Me|Le<<16,O[6]=jt=65535&Te|Qe<<16,Te=65535&(Re=Gt),Qe=Re>>>16,Me=65535&(_e=ut),Le=_e>>>16,_e=w[7],Qe+=(Re=O[7])>>>16,Me+=65535&_e,Le+=_e>>>16,Le+=(Me+=(Qe+=(Te+=65535&Re)>>>16)>>>16)>>>16,w[7]=ut=65535&Me|Le<<16,O[7]=Gt=65535&Te|Qe<<16,lr+=128,N-=128}return N}function xt(w,O,_){var N,F=new Int32Array(8),H=new Int32Array(8),j=new Uint8Array(256),G=_;for(F[0]=1779033703,F[1]=3144134277,F[2]=1013904242,F[3]=2773480762,F[4]=1359893119,F[5]=2600822924,F[6]=528734635,F[7]=1541459225,H[0]=4089235720,H[1]=2227873595,H[2]=4271175723,H[3]=1595750129,H[4]=2917565137,H[5]=725511199,H[6]=4215389547,H[7]=327033209,Pt(F,H,O,_),_%=128,N=0;N<_;N++)j[N]=O[G-_+N];for(j[_]=128,j[(_=256-128*(_<112?1:0))-9]=0,gt(j,_-8,G/536870912|0,G<<3),Pt(F,H,j,_),N=0;N<8;N++)gt(w,8*N,F[N],H[N]);return 0}function Qt(w,O){var _=nt(),N=nt(),F=nt(),H=nt(),j=nt(),G=nt(),z=nt(),X=nt(),ee=nt();It(_,w[1],w[0]),It(ee,O[1],O[0]),Bt(_,_,ee),vt(N,w[0],w[1]),vt(ee,O[0],O[1]),Bt(N,N,ee),Bt(F,w[3],O[3]),Bt(F,F,Rr),Bt(H,w[2],O[2]),vt(H,H,H),It(j,N,_),It(G,H,F),vt(z,H,F),vt(X,N,_),Bt(w[0],j,G),Bt(w[1],X,z),Bt(w[2],z,G),Bt(w[3],j,X)}function Rt(w,O,_){var N;for(N=0;N<4;N++)wt(w[N],O[N],_)}function Tt(w,O){var _=nt(),N=nt(),F=nt();Kt(F,O[2]),Bt(_,O[0],F),Bt(N,O[1],F),mt(w,N),w[31]^=kt(_)<<7}function Lt(w,O,_){var N,F;for(dt(w[0],Sr),dt(w[1],Cr),dt(w[2],Cr),dt(w[3],Sr),F=255;F>=0;--F)Rt(w,O,N=_[F/8|0]>>(7&F)&1),Qt(O,w),Qt(w,w),Rt(w,O,N)}function Mt(w,O){var _=[nt(),nt(),nt(),nt()];dt(_[0],Tr),dt(_[1],Qr),dt(_[2],Cr),Bt(_[3],Tr,Qr),Lt(w,_,O)}function Nt(w,O,_){var N,F=new Uint8Array(64),H=[nt(),nt(),nt(),nt()];for(_||it(O,32),xt(F,O,32),F[0]&=248,F[31]&=127,F[31]|=64,Mt(H,F),Tt(w,H),N=0;N<32;N++)O[N+32]=w[N];return 0}var jr=new Float64Array([237,211,245,92,26,99,18,88,214,156,247,162,222,249,222,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16]);function Ot(w,O){var _,N,F,H;for(N=63;N>=32;--N){for(_=0,F=N-32,H=N-12;F<H;++F)O[F]+=_-16*O[N]*jr[F-(N-32)],_=Math.floor((O[F]+128)/256),O[F]-=256*_;O[F]+=_,O[N]=0}for(_=0,F=0;F<32;F++)O[F]+=_-(O[31]>>4)*jr[F],_=O[F]>>8,O[F]&=255;for(F=0;F<32;F++)O[F]-=_*jr[F];for(N=0;N<32;N++)O[N+1]+=O[N]>>8,w[N]=255&O[N]}function Ht(w){var O,_=new Float64Array(64);for(O=0;O<64;O++)_[O]=w[O];for(O=0;O<64;O++)w[O]=0;Ot(w,_)}function zt(w,O){var _=nt(),N=nt(),F=nt(),H=nt(),j=nt(),G=nt(),z=nt();return dt(w[2],Cr),Et(w[1],O),St(F,w[1]),Bt(H,F,Or),It(F,F,w[2]),vt(H,w[2],H),St(j,H),St(G,j),Bt(z,G,j),Bt(_,z,F),Bt(_,_,H),function(w,O){var _,N=nt();for(_=0;_<16;_++)N[_]=O[_];for(_=250;_>=0;_--)St(N,N),1!==_&&Bt(N,N,O);for(_=0;_<16;_++)w[_]=N[_]}(_,_),Bt(_,_,F),Bt(_,_,H),Bt(_,_,H),Bt(w[0],_,H),St(N,w[0]),Bt(N,N,H),bt(N,F)&&Bt(w[0],w[0],Lr),St(N,w[0]),Bt(N,N,H),bt(N,F)?-1:(kt(w[0])===O[31]>>7&&It(w[0],Sr,w[0]),Bt(w[3],w[0],w[1]),0)}var qr=64;function _t(){for(var w=0;w<arguments.length;w++)if(!(arguments[w]instanceof Uint8Array))throw new TypeError("unexpected type, use Uint8Array")}Gt.scalarMult=function(w,O){if(_t(w,O),32!==w.length)throw Error("bad n size");if(32!==O.length)throw Error("bad p size");var _=new Uint8Array(32);return Ct(_,w,O),_},Gt.box={},Gt.box.keyPair=function(){var w=new Uint8Array(32),O=new Uint8Array(32);return function(w,O){it(O,32),Dt(w,O)}(w,O),{publicKey:w,secretKey:O}},Gt.box.keyPair.fromSecretKey=function(w){if(_t(w),32!==w.length)throw Error("bad secret key size");var O=new Uint8Array(32);return Dt(O,w),{publicKey:O,secretKey:new Uint8Array(w)}},Gt.sign=function(w,O){if(_t(w,O),64!==O.length)throw Error("bad secret key size");var _=new Uint8Array(qr+w.length);return function(w,O,_,N){var F,H,j=new Uint8Array(64),G=new Uint8Array(64),z=new Uint8Array(64),X=new Float64Array(64),ee=[nt(),nt(),nt(),nt()];xt(j,N,32),j[0]&=248,j[31]&=127,j[31]|=64;var se=_+64;for(F=0;F<_;F++)w[64+F]=O[F];for(F=0;F<32;F++)w[32+F]=j[32+F];for(xt(z,w.subarray(32),_+32),Ht(z),Mt(ee,z),Tt(w,ee),F=32;F<64;F++)w[F]=N[F];for(xt(G,w,_+64),Ht(G),F=0;F<64;F++)X[F]=0;for(F=0;F<32;F++)X[F]=z[F];for(F=0;F<32;F++)for(H=0;H<32;H++)X[F+H]+=G[F]*j[H];Ot(w.subarray(32),X)}(_,w,w.length,O),_},Gt.sign.detached=function(w,O){for(var _=Gt.sign(w,O),N=new Uint8Array(qr),F=0;F<N.length;F++)N[F]=_[F];return N},Gt.sign.detached.verify=function(w,O,_){if(_t(w,O,_),O.length!==qr)throw Error("bad signature size");if(32!==_.length)throw Error("bad public key size");var N,F=new Uint8Array(qr+w.length),H=new Uint8Array(qr+w.length);for(N=0;N<qr;N++)F[N]=O[N];for(N=0;N<w.length;N++)F[N+qr]=w[N];return function(w,O,_,N){var F,H=new Uint8Array(32),j=new Uint8Array(64),G=[nt(),nt(),nt(),nt()],z=[nt(),nt(),nt(),nt()];if(_<64)return-1;if(zt(z,N))return-1;for(F=0;F<_;F++)w[F]=O[F];for(F=0;F<32;F++)w[F+32]=N[F];if(xt(j,w,_),Ht(j),Lt(G,z,j),Mt(z,O.subarray(32)),Qt(G,z),Tt(H,G),_-=64,pt(O,0,H,0)){for(F=0;F<_;F++)w[F]=0;return-1}for(F=0;F<_;F++)w[F]=O[F+64];return _}(H,F,F.length,_)>=0},Gt.sign.keyPair=function(){var w=new Uint8Array(32),O=new Uint8Array(64);return Nt(w,O),{publicKey:w,secretKey:O}},Gt.sign.keyPair.fromSecretKey=function(w){if(_t(w),64!==w.length)throw Error("bad secret key size");for(var O=new Uint8Array(32),_=0;_<O.length;_++)O[_]=w[32+_];return{publicKey:O,secretKey:new Uint8Array(w)}},Gt.sign.keyPair.fromSeed=function(w){if(_t(w),32!==w.length)throw Error("bad seed size");for(var O=new Uint8Array(32),_=new Uint8Array(64),N=0;N<32;N++)_[N]=w[N];return Nt(O,_,!0),{publicKey:O,secretKey:_}},Gt.setPRNG=function(w){it=w},function(){if(jt&&jt.getRandomValues){Gt.setPRNG((function(w,O){var _,N=new Uint8Array(O);for(_=0;_<O;_+=65536)jt.getRandomValues(N.subarray(_,_+Math.min(O-_,65536)));for(_=0;_<O;_++)w[_]=N[_];!function(w){for(var O=0;O<w.length;O++)w[O]=0}(N)}))}}();const Vr={"2a8648ce3d030107":ve.curve.nistP256,"2b81040022":ve.curve.nistP384,"2b81040023":ve.curve.nistP521,"2b8104000a":ve.curve.secp256k1,"2b06010401da470f01":ve.curve.ed25519Legacy,"2b060104019755010501":ve.curve.curve25519Legacy,"2b2403030208010107":ve.curve.brainpoolP256r1,"2b240303020801010b":ve.curve.brainpoolP384r1,"2b240303020801010d":ve.curve.brainpoolP512r1};class qt{constructor(w){if(w instanceof qt)this.oid=w.oid;else if(Be.isArray(w)||Be.isUint8Array(w)){if(6===(w=new Uint8Array(w))[0]){if(w[1]!==w.length-2)throw Error("Length mismatch in DER encoded oid");w=w.subarray(2)}this.oid=w}else this.oid=""}read(w){if(w.length>=1){const O=w[0];if(w.length>=1+O)return this.oid=w.subarray(1,1+O),1+this.oid.length}throw Error("Invalid oid")}write(){return Be.concatUint8Array([new Uint8Array([this.oid.length]),this.oid])}toHex(){return Be.uint8ArrayToHex(this.oid)}getName(){const w=Vr[this.toHex()];if(!w)throw Error("Unknown curve object identifier.");return w}}function Vt(w){let O,_=0;const N=w[0];return N<192?([_]=w,O=1):N<255?(_=(w[0]-192<<8)+w[1]+192,O=2):255===N&&(_=Be.readNumber(w.subarray(1,5)),O=5),{len:_,offset:O}}function Jt(w){return w<192?new Uint8Array([w]):w>191&&w<8384?new Uint8Array([192+(w-192>>8),w-192&255]):Be.concatUint8Array([new Uint8Array([255]),Be.writeNumber(w,4)])}function Yt(w){if(w<0||w>30)throw Error("Partial Length power must be between 1 and 30");return new Uint8Array([224+w])}function Zt(w){return new Uint8Array([192|w])}function Wt(w,O){return Be.concatUint8Array([Zt(w),Jt(O)])}function $t(w){return[ve.packet.literalData,ve.packet.compressedData,ve.packet.symmetricallyEncryptedData,ve.packet.symEncryptedIntegrityProtectedData,ve.packet.aeadEncryptedData].includes(w)}async function Xt(w,O){const _=L(w);let N,F;try{const H=await _.peekBytes(2);if(!H||H.length<2||!(128&H[0]))throw Error("Error during parsing. This message / key probably does not conform to a valid OpenPGP format.");const j=await _.readByte();let G,z,X=-1,ee=-1;ee=0,64&j&&(ee=1),ee?X=63&j:(X=(63&j)>>2,z=3&j);const se=$t(X);let ae,Ae=null;if(se){if("array"===Be.isStream(w)){const w=new l;N=M(w),Ae=w}else{const w=new TransformStream;N=M(w.writable),Ae=w.readable}F=O({tag:X,packet:Ae})}else Ae=[];do{if(ee){const w=await _.readByte();if(ae=!1,w<192)G=w;else if(w>=192&&w<224)G=(w-192<<8)+await _.readByte()+192;else if(w>223&&w<255){if(G=1<<(31&w),ae=!0,!se)throw new TypeError("This packet type does not support partial lengths.")}else G=await _.readByte()<<24|await _.readByte()<<16|await _.readByte()<<8|await _.readByte()}else switch(z){case 0:G=await _.readByte();break;case 1:G=await _.readByte()<<8|await _.readByte();break;case 2:G=await _.readByte()<<24|await _.readByte()<<16|await _.readByte()<<8|await _.readByte();break;default:G=1/0}if(G>0){let w=0;for(;;){N&&await N.ready;const{done:O,value:F}=await _.read();if(O){if(G===1/0)break;throw Error("Unexpected end of packet")}const H=G===1/0?F:F.subarray(0,G-w);if(N?await N.write(H):Ae.push(H),w+=F.length,w>=G){_.unshift(F.subarray(G-w+F.length));break}}}}while(ae);const be=await _.peekBytes(se?1/0:2);return N?(await N.ready,await N.close()):(Ae=Be.concatUint8Array(Ae),await O({tag:X,packet:Ae})),!be||!be.length}catch(w){if(N)return await N.abort(w),!0;throw w}finally{N&&await F,_.releaseLock()}}class er extends Error{constructor(...w){super(...w),Error.captureStackTrace&&Error.captureStackTrace(this,er),this.name="UnsupportedError"}}class tr extends er{constructor(...w){super(...w),Error.captureStackTrace&&Error.captureStackTrace(this,er),this.name="UnknownPacketError"}}class rr{constructor(w,O){this.tag=w,this.rawContent=O}write(){return this.rawContent}}async function nr(w){switch(w){case ve.publicKey.ed25519:try{const w=Be.getWebCrypto(),O=await w.generateKey("Ed25519",!0,["sign","verify"]),_=await w.exportKey("jwk",O.privateKey),N=await w.exportKey("jwk",O.publicKey);return{A:new Uint8Array(J(N.x)),seed:J(_.d)}}catch(O){if("NotSupportedError"!==O.name&&"OperationError"!==O.name)throw O;const _=we(or(w)),{publicKey:N}=Gt.sign.keyPair.fromSeed(_);return{A:N,seed:_}}case ve.publicKey.ed448:{const w=await Be.getNobleCurve(ve.publicKey.ed448),O=w.utils.randomPrivateKey();return{A:w.getPublicKey(O),seed:O}}default:throw Error("Unsupported EdDSA algorithm")}}async function ir(w,O,_,N,F,H){if(Fe(O)<Fe(cr(w)))throw Error("Hash algorithm too weak for EdDSA.");switch(w){case ve.publicKey.ed25519:try{const O=Be.getWebCrypto(),_=ur(w,N,F),j=await O.importKey("jwk",_,"Ed25519",!1,["sign"]);return{RS:new Uint8Array(await O.sign("Ed25519",j,H))}}catch(w){if("NotSupportedError"!==w.name)throw w;const O=Be.concatUint8Array([F,N]);return{RS:Gt.sign.detached(H,O)}}case ve.publicKey.ed448:return{RS:(await Be.getNobleCurve(ve.publicKey.ed448)).sign(H,F)};default:throw Error("Unsupported EdDSA algorithm")}}async function sr(w,O,{RS:_},N,F,H){if(Fe(O)<Fe(cr(w)))throw Error("Hash algorithm too weak for EdDSA.");switch(w){case ve.publicKey.ed25519:try{const O=Be.getWebCrypto(),N=hr(w,F),j=await O.importKey("jwk",N,"Ed25519",!1,["verify"]);return await O.verify("Ed25519",j,_,H)}catch(w){if("NotSupportedError"!==w.name)throw w;return Gt.sign.detached.verify(H,_,F)}case ve.publicKey.ed448:return(await Be.getNobleCurve(ve.publicKey.ed448)).verify(_,H,F);default:throw Error("Unsupported EdDSA algorithm")}}async function ar(w,O,_){switch(w){case ve.publicKey.ed25519:{const{publicKey:w}=Gt.sign.keyPair.fromSeed(_);return Be.equalsUint8Array(O,w)}case ve.publicKey.ed448:{const w=(await Be.getNobleCurve(ve.publicKey.ed448)).getPublicKey(_);return Be.equalsUint8Array(O,w)}default:return!1}}function or(w){switch(w){case ve.publicKey.ed25519:return 32;case ve.publicKey.ed448:return 57;default:throw Error("Unsupported EdDSA algorithm")}}function cr(w){switch(w){case ve.publicKey.ed25519:return ve.hash.sha256;case ve.publicKey.ed448:return ve.hash.sha512;default:throw Error("Unknown EdDSA algo")}}const hr=(w,O)=>{if(w===ve.publicKey.ed25519){return{kty:"OKP",crv:"Ed25519",x:Y(O),ext:!0}}throw Error("Unsupported EdDSA algorithm")},ur=(w,O,_)=>{if(w===ve.publicKey.ed25519){const N=hr(w,O);return N.d=Y(_),N}throw Error("Unsupported EdDSA algorithm")};var nn=Object.freeze({__proto__:null,generate:nr,getPayloadSize:or,getPreferredHashAlgo:cr,sign:ir,validateParams:ar,verify:sr});function yr(w){return w instanceof Uint8Array||null!=w&&"object"==typeof w&&"Uint8Array"===w.constructor.name}function fr(w,...O){if(!yr(w))throw Error("Uint8Array expected");if(O.length>0&&!O.includes(w.length))throw Error(`Uint8Array expected of length ${O}, not of length=${w.length}`)}function gr(w,O=!0){if(w.destroyed)throw Error("Hash instance has been destroyed");if(O&&w.finished)throw Error("Hash#digest() has already been called")}function pr(w,O){fr(w);const _=O.outputLen;if(w.length<_)throw Error("digestInto() expects output buffer of length at least "+_)}
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const dr=w=>new Uint8Array(w.buffer,w.byteOffset,w.byteLength),Ar=w=>new Uint32Array(w.buffer,w.byteOffset,Math.floor(w.byteLength/4)),wr=w=>new DataView(w.buffer,w.byteOffset,w.byteLength);if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw Error("Non little-endian hardware is not supported");function mr(w){if("string"==typeof w)w=function(w){if("string"!=typeof w)throw Error("string expected, got "+typeof w);return new Uint8Array((new TextEncoder).encode(w))}(w);else{if(!yr(w))throw Error("Uint8Array expected, got "+typeof w);w=Ir(w)}return w}function br(w,O){if(w.length!==O.length)return!1;let _=0;for(let N=0;N<w.length;N++)_|=w[N]^O[N];return 0===_}const kr=(w,O)=>(Object.assign(O,w),O);function Er(w,O,_,N){if("function"==typeof w.setBigUint64)return w.setBigUint64(O,_,N);const F=BigInt(32),H=BigInt(4294967295),j=Number(_>>F&H),G=Number(_&H);w.setUint32(O+0,j,N),w.setUint32(O+4,G,N)}function vr(w){return w.byteOffset%4==0}function Ir(w){return Uint8Array.from(w)}function Br(...w){for(let O=0;O<w.length;O++)w[O].fill(0)}const sn=16,an=new Uint8Array(16),on=Ar(an),Dr=w=>(w>>>0&255)<<24|(w>>>8&255)<<16|(w>>>16&255)<<8|w>>>24&255;class Ur{constructor(w,O){this.blockLen=sn,this.outputLen=sn,this.s0=0,this.s1=0,this.s2=0,this.s3=0,this.finished=!1,fr(w=mr(w),16);const _=wr(w);let N=_.getUint32(0,!1),F=_.getUint32(4,!1),H=_.getUint32(8,!1),j=_.getUint32(12,!1);const G=[];for(let w=0;w<128;w++)G.push({s0:Dr(N),s1:Dr(F),s2:Dr(H),s3:Dr(j)}),({s0:N,s1:F,s2:H,s3:j}={s3:(ee=H)<<31|(se=j)>>>1,s2:(X=F)<<31|ee>>>1,s1:(z=N)<<31|X>>>1,s0:z>>>1^225<<24&-(1&se)});var z,X,ee,se;const ae=(w=>w>65536?8:w>1024?4:2)(O||1024);if(![1,2,4,8].includes(ae))throw Error(`ghash: wrong window size=${ae}, should be 2, 4 or 8`);this.W=ae;const Ae=128/ae,be=this.windowSize=2**ae,ve=[];for(let w=0;w<Ae;w++)for(let O=0;O<be;O++){let _=0,N=0,F=0,H=0;for(let j=0;j<ae;j++){if(!(O>>>ae-j-1&1))continue;const{s0:z,s1:X,s2:ee,s3:se}=G[ae*w+j];_^=z,N^=X,F^=ee,H^=se}ve.push({s0:_,s1:N,s2:F,s3:H})}this.t=ve}_updateBlock(w,O,_,N){w^=this.s0,O^=this.s1,_^=this.s2,N^=this.s3;const{W:F,t:H,windowSize:j}=this;let G=0,z=0,X=0,ee=0;const se=(1<<F)-1;let ae=0;for(const Ae of[w,O,_,N])for(let w=0;w<4;w++){const O=Ae>>>8*w&255;for(let w=8/F-1;w>=0;w--){const _=O>>>F*w&se,{s0:N,s1:Ae,s2:be,s3:ve}=H[ae*j+_];G^=N,z^=Ae,X^=be,ee^=ve,ae+=1}}this.s0=G,this.s1=z,this.s2=X,this.s3=ee}update(w){w=mr(w),gr(this);const O=Ar(w),_=Math.floor(w.length/sn),N=w.length%sn;for(let w=0;w<_;w++)this._updateBlock(O[4*w+0],O[4*w+1],O[4*w+2],O[4*w+3]);return N&&(an.set(w.subarray(_*sn)),this._updateBlock(on[0],on[1],on[2],on[3]),Br(on)),this}destroy(){const{t:w}=this;for(const O of w)O.s0=0,O.s1=0,O.s2=0,O.s3=0}digestInto(w){gr(this),pr(w,this),this.finished=!0;const{s0:O,s1:_,s2:N,s3:F}=this,H=Ar(w);return H[0]=O,H[1]=_,H[2]=N,H[3]=F,w}digest(){const w=new Uint8Array(sn);return this.digestInto(w),this.destroy(),w}}class Pr extends Ur{constructor(w,O){const _=function(w){w.reverse();const O=1&w[15];let _=0;for(let O=0;O<w.length;O++){const N=w[O];w[O]=N>>>1|_,_=(1&N)<<7}return w[0]^=225&-O,w}(Ir(w=mr(w)));super(_,O),Br(_)}update(w){w=mr(w),gr(this);const O=Ar(w),_=w.length%sn,N=Math.floor(w.length/sn);for(let w=0;w<N;w++)this._updateBlock(Dr(O[4*w+3]),Dr(O[4*w+2]),Dr(O[4*w+1]),Dr(O[4*w+0]));return _&&(an.set(w.subarray(N*sn)),this._updateBlock(Dr(on[3]),Dr(on[2]),Dr(on[1]),Dr(on[0])),Br(on)),this}digestInto(w){gr(this),pr(w,this),this.finished=!0;const{s0:O,s1:_,s2:N,s3:F}=this,H=Ar(w);return H[0]=O,H[1]=_,H[2]=N,H[3]=F,w.reverse()}}function xr(w){const t=(O,_)=>w(_,O.length).update(mr(O)).digest(),O=w(new Uint8Array(16),0);return t.outputLen=O.outputLen,t.blockLen=O.blockLen,t.create=(O,_)=>w(O,_),t}const ln=xr(((w,O)=>new Ur(w,O)));xr(((w,O)=>new Pr(w,O)));const fn=16,yn=new Uint8Array(fn),gn=283;function Mr(w){return w<<1^gn&-(w>>7)}function Nr(w,O){let _=0;for(;O>0;O>>=1)_^=w&-(1&O),w=Mr(w);return _}const mn=(()=>{const w=new Uint8Array(256);for(let O=0,_=1;O<256;O++,_^=Mr(_))w[O]=_;const O=new Uint8Array(256);O[0]=99;for(let _=0;_<255;_++){let N=w[255-_];N|=N<<8,O[w[_]]=255&(N^N>>4^N>>5^N>>6^N>>7^99)}return Br(w),O})(),En=mn.map(((w,O)=>mn.indexOf(O))),Hr=w=>w<<24|w>>>8,zr=w=>w<<8|w>>>24,Gr=w=>w<<24&4278190080|w<<8&16711680|w>>>8&65280|w>>>24&255;function _r(w,O){if(256!==w.length)throw Error("Wrong sbox length");const _=new Uint32Array(256).map(((_,N)=>O(w[N]))),N=_.map(zr),F=N.map(zr),H=F.map(zr),j=new Uint32Array(65536),G=new Uint32Array(65536),z=new Uint16Array(65536);for(let O=0;O<256;O++)for(let X=0;X<256;X++){const ee=256*O+X;j[ee]=_[O]^N[X],G[ee]=F[O]^H[X],z[ee]=w[O]<<8|w[X]}return{sbox:w,sbox2:z,T0:_,T1:N,T2:F,T3:H,T01:j,T23:G}}const In=_r(mn,(w=>Nr(w,3)<<24|w<<16|w<<8|Nr(w,2))),Rn=_r(En,(w=>Nr(w,11)<<24|Nr(w,13)<<16|Nr(w,9)<<8|Nr(w,14))),Tn=(()=>{const w=new Uint8Array(16);for(let O=0,_=1;O<16;O++,_=Mr(_))w[O]=_;return w})();function Jr(w){fr(w);const O=w.length;if(![16,24,32].includes(O))throw Error("aes: wrong key size: should be 16, 24 or 32, got: "+O);const{sbox2:_}=In,N=[];vr(w)||N.push(w=Ir(w));const F=Ar(w),H=F.length,a=w=>Wr(_,w,w,w,w),j=new Uint32Array(O+28);j.set(F);for(let w=H;w<j.length;w++){let O=j[w-1];w%H==0?O=a(Hr(O))^Tn[w/H-1]:H>6&&w%H==4&&(O=a(O)),j[w]=j[w-H]^O}return Br(...N),j}function Yr(w){const O=Jr(w),_=O.slice(),N=O.length,{sbox2:F}=In,{T0:H,T1:j,T2:G,T3:z}=Rn;for(let w=0;w<N;w+=4)for(let F=0;F<4;F++)_[w+F]=O[N-w-4+F];Br(O);for(let w=4;w<N-4;w++){const O=_[w],N=Wr(F,O,O,O,O);_[w]=H[255&N]^j[N>>>8&255]^G[N>>>16&255]^z[N>>>24]}return _}function Zr(w,O,_,N,F,H){return w[_<<8&65280|N>>>8&255]^O[F>>>8&65280|H>>>24&255]}function Wr(w,O,_,N,F){return w[255&O|65280&_]|w[N>>>16&255|F>>>16&65280]<<16}function $r(w,O,_,N,F){const{sbox2:H,T01:j,T23:G}=In;let z=0;O^=w[z++],_^=w[z++],N^=w[z++],F^=w[z++];const X=w.length/4-2;for(let H=0;H<X;H++){const H=w[z++]^Zr(j,G,O,_,N,F),X=w[z++]^Zr(j,G,_,N,F,O),ee=w[z++]^Zr(j,G,N,F,O,_),se=w[z++]^Zr(j,G,F,O,_,N);O=H,_=X,N=ee,F=se}return{s0:w[z++]^Wr(H,O,_,N,F),s1:w[z++]^Wr(H,_,N,F,O),s2:w[z++]^Wr(H,N,F,O,_),s3:w[z++]^Wr(H,F,O,_,N)}}function Xr(w,O,_,N,F){const{sbox2:H,T01:j,T23:G}=Rn;let z=0;O^=w[z++],_^=w[z++],N^=w[z++],F^=w[z++];const X=w.length/4-2;for(let H=0;H<X;H++){const H=w[z++]^Zr(j,G,O,F,N,_),X=w[z++]^Zr(j,G,_,O,F,N),ee=w[z++]^Zr(j,G,N,_,O,F),se=w[z++]^Zr(j,G,F,N,_,O);O=H,_=X,N=ee,F=se}return{s0:w[z++]^Wr(H,O,F,N,_),s1:w[z++]^Wr(H,_,O,F,N),s2:w[z++]^Wr(H,N,_,O,F),s3:w[z++]^Wr(H,F,N,_,O)}}function en(w,O){if(void 0===O)return new Uint8Array(w);if(fr(O),O.length<w)throw Error(`aes: wrong destination length, expected at least ${w}, got: ${O.length}`);if(!vr(O))throw Error("unaligned dst");return O}function tn(w,O,_,N){fr(O,fn),fr(_);const F=_.length;N=en(F,N);const H=O,j=Ar(H);let{s0:G,s1:z,s2:X,s3:ee}=$r(w,j[0],j[1],j[2],j[3]);const se=Ar(_),ae=Ar(N);for(let O=0;O+4<=se.length;O+=4){ae[O+0]=se[O+0]^G,ae[O+1]=se[O+1]^z,ae[O+2]=se[O+2]^X,ae[O+3]=se[O+3]^ee;let _=1;for(let w=H.length-1;w>=0;w--)_=_+(255&H[w])|0,H[w]=255&_,_>>>=8;({s0:G,s1:z,s2:X,s3:ee}=$r(w,j[0],j[1],j[2],j[3]))}const Ae=fn*Math.floor(se.length/4);if(Ae<F){const w=new Uint32Array([G,z,X,ee]),O=dr(w);for(let w=Ae,H=0;w<F;w++,H++)N[w]=_[w]^O[H];Br(w)}return N}function rn(w,O,_,N,F){fr(_,fn),fr(N),F=en(N.length,F);const H=_,j=Ar(H),G=wr(H),z=Ar(N),X=Ar(F),ee=O?0:12,se=N.length;let ae=G.getUint32(ee,O),{s0:Ae,s1:be,s2:ve,s3:Se}=$r(w,j[0],j[1],j[2],j[3]);for(let _=0;_+4<=z.length;_+=4)X[_+0]=z[_+0]^Ae,X[_+1]=z[_+1]^be,X[_+2]=z[_+2]^ve,X[_+3]=z[_+3]^Se,ae=ae+1>>>0,G.setUint32(ee,ae,O),({s0:Ae,s1:be,s2:ve,s3:Se}=$r(w,j[0],j[1],j[2],j[3]));const Ie=fn*Math.floor(z.length/4);if(Ie<se){const w=new Uint32Array([Ae,be,ve,Se]),O=dr(w);for(let w=Ie,_=0;w<se;w++,_++)F[w]=N[w]^O[_];Br(w)}return F}const Qn=kr({blockSize:16,nonceLength:16},(function(w,O){function r(_,N){if(fr(_),void 0!==N&&(fr(N),!vr(N)))throw Error("unaligned destination");const F=Jr(w),H=Ir(O),j=[F,H];vr(_)||j.push(_=Ir(_));const G=tn(F,H,_,N);return Br(...j),G}return fr(w),fr(O,fn),{encrypt:(w,O)=>r(w,O),decrypt:(w,O)=>r(w,O)}}));const Mn=kr({blockSize:16,nonceLength:16},(function(w,O,_={}){fr(w),fr(O,16);const N=!_.disablePadding;return{encrypt(_,F){const H=Jr(w),{b:j,o:G,out:z}=function(w,O,_){fr(w);let N=w.length;const F=N%fn;if(!O&&0!==F)throw Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");vr(w)||(w=Ir(w));const H=Ar(w);if(O){let w=fn-F;w||(w=fn),N+=w}const j=en(N,_);return{b:H,o:Ar(j),out:j}}(_,N,F);let X=O;const ee=[H];vr(X)||ee.push(X=Ir(X));const se=Ar(X);let ae=se[0],Ae=se[1],be=se[2],ve=se[3],Se=0;for(;Se+4<=j.length;)ae^=j[Se+0],Ae^=j[Se+1],be^=j[Se+2],ve^=j[Se+3],({s0:ae,s1:Ae,s2:be,s3:ve}=$r(H,ae,Ae,be,ve)),G[Se++]=ae,G[Se++]=Ae,G[Se++]=be,G[Se++]=ve;if(N){const w=function(w){const O=new Uint8Array(16),_=Ar(O);O.set(w);const N=fn-w.length;for(let w=fn-N;w<fn;w++)O[w]=N;return _}(_.subarray(4*Se));ae^=w[0],Ae^=w[1],be^=w[2],ve^=w[3],({s0:ae,s1:Ae,s2:be,s3:ve}=$r(H,ae,Ae,be,ve)),G[Se++]=ae,G[Se++]=Ae,G[Se++]=be,G[Se++]=ve}return Br(...ee),z},decrypt(_,F){!function(w){if(fr(w),w.length%fn!=0)throw Error("aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size 16")}(_);const H=Yr(w);let j=O;const G=[H];vr(j)||G.push(j=Ir(j));const z=Ar(j),X=en(_.length,F);vr(_)||G.push(_=Ir(_));const ee=Ar(_),se=Ar(X);let ae=z[0],Ae=z[1],be=z[2],ve=z[3];for(let w=0;w+4<=ee.length;){const O=ae,_=Ae,N=be,F=ve;ae=ee[w+0],Ae=ee[w+1],be=ee[w+2],ve=ee[w+3];const{s0:j,s1:G,s2:z,s3:X}=Xr(H,ae,Ae,be,ve);se[w++]=j^O,se[w++]=G^_,se[w++]=z^N,se[w++]=X^F}return Br(...G),function(w,O){if(!O)return w;const _=w.length;if(!_)throw Error("aes/pcks5: empty ciphertext not allowed");const N=w[_-1];if(N<=0||N>16)throw Error("aes/pcks5: wrong padding");const F=w.subarray(0,-N);for(let O=0;O<N;O++)if(w[_-O-1]!==N)throw Error("aes/pcks5: wrong padding");return F}(X,N)}}})),Ln=kr({blockSize:16,nonceLength:16},(function(w,O){function r(_,N,F){fr(_);const H=_.length;F=en(H,F);const j=Jr(w);let G=O;const z=[j];vr(G)||z.push(G=Ir(G)),vr(_)||z.push(_=Ir(_));const X=Ar(_),ee=Ar(F),se=N?ee:X,ae=Ar(G);let Ae=ae[0],be=ae[1],ve=ae[2],Se=ae[3];for(let w=0;w+4<=X.length;){const{s0:O,s1:_,s2:N,s3:F}=$r(j,Ae,be,ve,Se);ee[w+0]=X[w+0]^O,ee[w+1]=X[w+1]^_,ee[w+2]=X[w+2]^N,ee[w+3]=X[w+3]^F,Ae=se[w++],be=se[w++],ve=se[w++],Se=se[w++]}const Ie=fn*Math.floor(X.length/4);if(Ie<H){({s0:Ae,s1:be,s2:ve,s3:Se}=$r(j,Ae,be,ve,Se));const w=dr(new Uint32Array([Ae,be,ve,Se]));for(let O=Ie,N=0;O<H;O++,N++)F[O]=_[O]^w[N];Br(w)}return Br(...z),F}return fr(w),fr(O,16),{encrypt:(w,O)=>r(w,!0,O),decrypt:(w,O)=>r(w,!1,O)}}));const Nn=kr({blockSize:16,nonceLength:12,tagLength:16},(function(w,O,_){if(fr(w),fr(O),void 0!==_&&fr(_),O.length<8)throw Error("aes/gcm: invalid nonce length");const N=16;function i(w,O,N){const F=function(w,O,_,N,F){const H=null==F?0:F.length,j=w.create(_,N.length+H);F&&j.update(F),j.update(N);const G=new Uint8Array(16),z=wr(G);F&&Er(z,0,BigInt(8*H),O),Er(z,8,BigInt(8*N.length),O),j.update(G);const X=j.digest();return Br(G),X}(ln,!1,w,N,_);for(let w=0;w<O.length;w++)F[w]^=O[w];return F}function s(){const _=Jr(w),N=yn.slice(),F=yn.slice();if(rn(_,!1,F,F,N),12===O.length)F.set(O);else{const w=yn.slice();Er(wr(w),8,BigInt(8*O.length),!1);const _=ln.create(N).update(O).update(w);_.digestInto(F),_.destroy()}return{xk:_,authKey:N,counter:F,tagMask:rn(_,!1,F,yn)}}return{encrypt(w){fr(w);const{xk:O,authKey:_,counter:F,tagMask:H}=s(),j=new Uint8Array(w.length+N),G=[O,_,F,H];vr(w)||G.push(w=Ir(w)),rn(O,!1,F,w,j);const z=i(_,H,j.subarray(0,j.length-N));return G.push(z),j.set(z,w.length),Br(...G),j},decrypt(w){if(fr(w),w.length<N)throw Error("aes/gcm: ciphertext less than tagLen (16)");const{xk:O,authKey:_,counter:F,tagMask:H}=s(),j=[O,_,H,F];vr(w)||j.push(w=Ir(w));const G=w.subarray(0,-16),z=w.subarray(-16),X=i(_,H,G);if(j.push(X),!br(X,z))throw Error("aes/gcm: invalid ghash tag");const ee=rn(O,!1,F,G);return Br(...j),ee}}}));function cn(w){return null!=w&&"object"==typeof w&&(w instanceof Uint32Array||"Uint32Array"===w.constructor.name)}function hn(w,O){if(fr(O,16),!cn(w))throw Error("_encryptBlock accepts result of expandKeyLE");const _=Ar(O);let{s0:N,s1:F,s2:H,s3:j}=$r(w,_[0],_[1],_[2],_[3]);return _[0]=N,_[1]=F,_[2]=H,_[3]=j,O}function un(w,O){if(fr(O,16),!cn(w))throw Error("_decryptBlock accepts result of expandKeyLE");const _=Ar(O);let{s0:N,s1:F,s2:H,s3:j}=Xr(w,_[0],_[1],_[2],_[3]);return _[0]=N,_[1]=F,_[2]=H,_[3]=j,O}const Fn={encrypt(w,O){if(O.length>=2**32)throw Error("plaintext should be less than 4gb");const _=Jr(w);if(16===O.length)hn(_,O);else{const w=Ar(O);let N=w[0],F=w[1];for(let O=0,H=1;O<6;O++)for(let O=2;O<w.length;O+=2,H++){const{s0:j,s1:G,s2:z,s3:X}=$r(_,N,F,w[O],w[O+1]);N=j,F=G^Gr(H),w[O]=z,w[O+1]=X}w[0]=N,w[1]=F}_.fill(0)},decrypt(w,O){if(O.length-8>=2**32)throw Error("ciphertext should be less than 4gb");const _=Yr(w),N=O.length/8-1;if(1===N)un(_,O);else{const w=Ar(O);let F=w[0],H=w[1];for(let O=0,j=6*N;O<6;O++)for(let O=2*N;O>=1;O-=2,j--){H^=Gr(j);const{s0:N,s1:G,s2:z,s3:X}=Xr(_,F,H,w[O],w[O+1]);F=N,H=G,w[O]=z,w[O+1]=X}w[0]=F,w[1]=H}_.fill(0)}},Yn=new Uint8Array(8).fill(166),Zn=kr({blockSize:8},(w=>({encrypt(O){if(fr(O),!O.length||O.length%8!=0)throw Error("invalid plaintext length");if(8===O.length)throw Error("8-byte keys not allowed in AESKW, use AESKWP instead");const _=function(...w){let O=0;for(let _=0;_<w.length;_++){const N=w[_];fr(N),O+=N.length}const _=new Uint8Array(O);for(let O=0,N=0;O<w.length;O++){const F=w[O];_.set(F,N),N+=F.length}return _}(Yn,O);return Fn.encrypt(w,_),_},decrypt(O){if(fr(O),O.length%8!=0||O.length<24)throw Error("invalid ciphertext length");const _=Ir(O);if(Fn.decrypt(w,_),!br(_.subarray(0,8),Yn))throw Error("integrity check failed");return _.subarray(0,8).fill(0),_.subarray(8)}}))),ei={expandKeyLE:Jr,expandKeyDecLE:Yr,encrypt:$r,decrypt:Xr,encryptBlock:hn,decryptBlock:un,ctrCounter:tn,ctr32:rn};async function pn(w){switch(w){case ve.symmetric.aes128:case ve.symmetric.aes192:case ve.symmetric.aes256:throw Error("Not a legacy cipher");case ve.symmetric.cast5:case ve.symmetric.blowfish:case ve.symmetric.twofish:case ve.symmetric.tripledes:{const{legacyCiphers:O}=await Promise.resolve().then((function(){return yf})),_=ve.read(ve.symmetric,w),N=O.get(_);if(!N)throw Error("Unsupported cipher algorithm");return N}default:throw Error("Unsupported cipher algorithm")}}function dn(w){switch(w){case ve.symmetric.aes128:case ve.symmetric.aes192:case ve.symmetric.aes256:case ve.symmetric.twofish:return 16;case ve.symmetric.blowfish:case ve.symmetric.cast5:case ve.symmetric.tripledes:return 8;default:throw Error("Unsupported cipher")}}function An(w){switch(w){case ve.symmetric.aes128:case ve.symmetric.blowfish:case ve.symmetric.cast5:return 16;case ve.symmetric.aes192:case ve.symmetric.tripledes:return 24;case ve.symmetric.aes256:case ve.symmetric.twofish:return 32;default:throw Error("Unsupported cipher")}}function wn(w){return{keySize:An(w),blockSize:dn(w)}}const ii=Be.getWebCrypto();async function bn(w,O,_){const{keySize:N}=wn(w);if(!Be.isAES(w)||O.length!==N)throw Error("Unexpected algorithm or key size");try{const w=await ii.importKey("raw",O,{name:"AES-KW"},!1,["wrapKey"]),N=await ii.importKey("raw",_,{name:"HMAC",hash:"SHA-256"},!0,["sign"]),F=await ii.wrapKey("raw",N,w,{name:"AES-KW"});return new Uint8Array(F)}catch(w){if("NotSupportedError"!==w.name&&(24!==O.length||"OperationError"!==w.name))throw w;Be.printDebugError("Browser did not support operation: "+w.message)}return Zn(O).encrypt(_)}async function kn(w,O,_){const{keySize:N}=wn(w);if(!Be.isAES(w)||O.length!==N)throw Error("Unexpected algorithm or key size");let F;try{F=await ii.importKey("raw",O,{name:"AES-KW"},!1,["unwrapKey"])}catch(w){if("NotSupportedError"!==w.name&&(24!==O.length||"OperationError"!==w.name))throw w;return Be.printDebugError("Browser did not support operation: "+w.message),Zn(O).decrypt(_)}try{const w=await ii.unwrapKey("raw",_,F,{name:"AES-KW"},{name:"HMAC",hash:"SHA-256"},!0,["sign"]);return new Uint8Array(await ii.exportKey("raw",w))}catch(w){if("OperationError"===w.name)throw Error("Key Data Integrity failed");throw w}}const ai=Be.getWebCrypto();async function vn(w,O,_,N,F){const H=ve.read(ve.webHash,w);if(!H)throw Error("Hash algo not supported with HKDF");const j=await ai.importKey("raw",O,"HKDF",!1,["deriveBits"]),G=await ai.deriveBits({name:"HKDF",hash:H,salt:_,info:N},j,8*F);return new Uint8Array(G)}const oi={x25519:Be.encodeUTF8("OpenPGP X25519"),x448:Be.encodeUTF8("OpenPGP X448")};async function Bn(w){switch(w){case ve.publicKey.x25519:{const w=we(32),{publicKey:O}=Gt.box.keyPair.fromSecretKey(w);return{A:O,k:w}}case ve.publicKey.x448:{const w=await Be.getNobleCurve(ve.publicKey.x448),O=w.utils.randomPrivateKey();return{A:w.getPublicKey(O),k:O}}default:throw Error("Unsupported ECDH algorithm")}}async function Sn(w,O,_){switch(w){case ve.publicKey.x25519:{const{publicKey:w}=Gt.box.keyPair.fromSecretKey(_);return Be.equalsUint8Array(O,w)}case ve.publicKey.x448:{const w=(await Be.getNobleCurve(ve.publicKey.x448)).getPublicKey(_);return Be.equalsUint8Array(O,w)}default:return!1}}async function Kn(w,O,_){const{ephemeralPublicKey:N,sharedSecret:F}=await Un(w,_),H=Be.concatUint8Array([N,_,F]);switch(w){case ve.publicKey.x25519:{const w=ve.symmetric.aes128,{keySize:_}=wn(w),F=await vn(ve.hash.sha256,H,new Uint8Array,oi.x25519,_);return{ephemeralPublicKey:N,wrappedKey:await bn(w,F,O)}}case ve.publicKey.x448:{const w=ve.symmetric.aes256,{keySize:_}=wn(ve.symmetric.aes256),F=await vn(ve.hash.sha512,H,new Uint8Array,oi.x448,_);return{ephemeralPublicKey:N,wrappedKey:await bn(w,F,O)}}default:throw Error("Unsupported ECDH algorithm")}}async function Cn(w,O,_,N,F){const H=await Pn(w,O,N,F),j=Be.concatUint8Array([O,N,H]);switch(w){case ve.publicKey.x25519:{const w=ve.symmetric.aes128,{keySize:O}=wn(w);return kn(w,await vn(ve.hash.sha256,j,new Uint8Array,oi.x25519,O),_)}case ve.publicKey.x448:{const w=ve.symmetric.aes256,{keySize:O}=wn(ve.symmetric.aes256);return kn(w,await vn(ve.hash.sha512,j,new Uint8Array,oi.x448,O),_)}default:throw Error("Unsupported ECDH algorithm")}}function Dn(w){switch(w){case ve.publicKey.x25519:return 32;case ve.publicKey.x448:return 56;default:throw Error("Unsupported ECDH algorithm")}}async function Un(w,O){switch(w){case ve.publicKey.x25519:{const _=we(Dn(w)),N=Gt.scalarMult(_,O);xn(N);const{publicKey:F}=Gt.box.keyPair.fromSecretKey(_);return{ephemeralPublicKey:F,sharedSecret:N}}case ve.publicKey.x448:{const w=await Be.getNobleCurve(ve.publicKey.x448),_=w.utils.randomPrivateKey(),N=w.getSharedSecret(_,O);xn(N);return{ephemeralPublicKey:w.getPublicKey(_),sharedSecret:N}}default:throw Error("Unsupported ECDH algorithm")}}async function Pn(w,O,_,N){switch(w){case ve.publicKey.x25519:{const w=Gt.scalarMult(N,O);return xn(w),w}case ve.publicKey.x448:{const w=(await Be.getNobleCurve(ve.publicKey.x448)).getSharedSecret(N,O);return xn(w),w}default:throw Error("Unsupported ECDH algorithm")}}function xn(w){let O=0;for(let _=0;_<w.length;_++)O|=w[_];if(0===O)throw Error("Unexpected low order point")}var di=Object.freeze({__proto__:null,decrypt:Cn,encrypt:Kn,generate:Bn,generateEphemeralEncryptionMaterial:Un,getPayloadSize:Dn,recomputeSharedSecret:Pn,validateParams:Sn});const wi=Be.getWebCrypto(),Ai=Be.getNodeCrypto(),Pi={[ve.curve.nistP256]:"P-256",[ve.curve.nistP384]:"P-384",[ve.curve.nistP521]:"P-521"},xi=Ai?Ai.getCurves():[],_i=Ai?{[ve.curve.secp256k1]:xi.includes("secp256k1")?"secp256k1":void 0,[ve.curve.nistP256]:xi.includes("prime256v1")?"prime256v1":void 0,[ve.curve.nistP384]:xi.includes("secp384r1")?"secp384r1":void 0,[ve.curve.nistP521]:xi.includes("secp521r1")?"secp521r1":void 0,[ve.curve.ed25519Legacy]:xi.includes("ED25519")?"ED25519":void 0,[ve.curve.curve25519Legacy]:xi.includes("X25519")?"X25519":void 0,[ve.curve.brainpoolP256r1]:xi.includes("brainpoolP256r1")?"brainpoolP256r1":void 0,[ve.curve.brainpoolP384r1]:xi.includes("brainpoolP384r1")?"brainpoolP384r1":void 0,[ve.curve.brainpoolP512r1]:xi.includes("brainpoolP512r1")?"brainpoolP512r1":void 0}:{},Ri={[ve.curve.nistP256]:{oid:[6,8,42,134,72,206,61,3,1,7],keyType:ve.publicKey.ecdsa,hash:ve.hash.sha256,cipher:ve.symmetric.aes128,node:_i[ve.curve.nistP256],web:Pi[ve.curve.nistP256],payloadSize:32,sharedSize:256,wireFormatLeadingByte:4},[ve.curve.nistP384]:{oid:[6,5,43,129,4,0,34],keyType:ve.publicKey.ecdsa,hash:ve.hash.sha384,cipher:ve.symmetric.aes192,node:_i[ve.curve.nistP384],web:Pi[ve.curve.nistP384],payloadSize:48,sharedSize:384,wireFormatLeadingByte:4},[ve.curve.nistP521]:{oid:[6,5,43,129,4,0,35],keyType:ve.publicKey.ecdsa,hash:ve.hash.sha512,cipher:ve.symmetric.aes256,node:_i[ve.curve.nistP521],web:Pi[ve.curve.nistP521],payloadSize:66,sharedSize:528,wireFormatLeadingByte:4},[ve.curve.secp256k1]:{oid:[6,5,43,129,4,0,10],keyType:ve.publicKey.ecdsa,hash:ve.hash.sha256,cipher:ve.symmetric.aes128,node:_i[ve.curve.secp256k1],payloadSize:32,wireFormatLeadingByte:4},[ve.curve.ed25519Legacy]:{oid:[6,9,43,6,1,4,1,218,71,15,1],keyType:ve.publicKey.eddsaLegacy,hash:ve.hash.sha512,node:!1,payloadSize:32,wireFormatLeadingByte:64},[ve.curve.curve25519Legacy]:{oid:[6,10,43,6,1,4,1,151,85,1,5,1],keyType:ve.publicKey.ecdh,hash:ve.hash.sha256,cipher:ve.symmetric.aes128,node:!1,payloadSize:32,wireFormatLeadingByte:64},[ve.curve.brainpoolP256r1]:{oid:[6,9,43,36,3,3,2,8,1,1,7],keyType:ve.publicKey.ecdsa,hash:ve.hash.sha256,cipher:ve.symmetric.aes128,node:_i[ve.curve.brainpoolP256r1],payloadSize:32,wireFormatLeadingByte:4},[ve.curve.brainpoolP384r1]:{oid:[6,9,43,36,3,3,2,8,1,1,11],keyType:ve.publicKey.ecdsa,hash:ve.hash.sha384,cipher:ve.symmetric.aes192,node:_i[ve.curve.brainpoolP384r1],payloadSize:48,wireFormatLeadingByte:4},[ve.curve.brainpoolP512r1]:{oid:[6,9,43,36,3,3,2,8,1,1,13],keyType:ve.publicKey.ecdsa,hash:ve.hash.sha512,cipher:ve.symmetric.aes256,node:_i[ve.curve.brainpoolP512r1],payloadSize:64,wireFormatLeadingByte:4}};class On{constructor(w){try{this.name=w instanceof qt?w.getName():ve.write(ve.curve,w)}catch(w){throw new er("Unknown curve")}const O=Ri[this.name];this.keyType=O.keyType,this.oid=O.oid,this.hash=O.hash,this.cipher=O.cipher,this.node=O.node,this.web=O.web,this.payloadSize=O.payloadSize,this.sharedSize=O.sharedSize,this.wireFormatLeadingByte=O.wireFormatLeadingByte,this.web&&Be.getWebCrypto()?this.type="web":this.node&&Be.getNodeCrypto()?this.type="node":this.name===ve.curve.curve25519Legacy?this.type="curve25519Legacy":this.name===ve.curve.ed25519Legacy&&(this.type="ed25519Legacy")}async genKeyPair(){switch(this.type){case"web":try{return await async function(w,O){const _=await wi.generateKey({name:"ECDSA",namedCurve:Pi[w]},!0,["sign","verify"]),N=await wi.exportKey("jwk",_.privateKey);return{publicKey:qn(await wi.exportKey("jwk",_.publicKey),O),privateKey:J(N.d)}}(this.name,this.wireFormatLeadingByte)}catch(w){return Be.printDebugError("Browser did not support generating ec key "+w.message),jn(this.name)}case"node":return async function(w){const O=Ai.createECDH(_i[w]);return await O.generateKeys(),{publicKey:new Uint8Array(O.getPublicKey()),privateKey:new Uint8Array(O.getPrivateKey())}}(this.name);case"curve25519Legacy":{const{k:w,A:O}=await Bn(ve.publicKey.x25519),_=w.slice().reverse();_[0]=127&_[0]|64,_[31]&=248;return{publicKey:Be.concatUint8Array([new Uint8Array([this.wireFormatLeadingByte]),O]),privateKey:_}}case"ed25519Legacy":{const{seed:w,A:O}=await nr(ve.publicKey.ed25519);return{publicKey:Be.concatUint8Array([new Uint8Array([this.wireFormatLeadingByte]),O]),privateKey:w}}default:return jn(this.name)}}}async function Hn(w){const O=new On(w),{oid:_,hash:N,cipher:F}=O,H=await O.genKeyPair();return{oid:_,Q:H.publicKey,secret:Be.leftPad(H.privateKey,O.payloadSize),hash:N,cipher:F}}function zn(w){return Ri[w.getName()].hash}async function Gn(w,O,_,N){const F={[ve.curve.nistP256]:!0,[ve.curve.nistP384]:!0,[ve.curve.nistP521]:!0,[ve.curve.secp256k1]:!0,[ve.curve.curve25519Legacy]:w===ve.publicKey.ecdh,[ve.curve.brainpoolP256r1]:!0,[ve.curve.brainpoolP384r1]:!0,[ve.curve.brainpoolP512r1]:!0},H=O.getName();if(!F[H])return!1;if(H===ve.curve.curve25519Legacy){N=N.slice().reverse();const{publicKey:w}=Gt.box.keyPair.fromSecretKey(N);_=new Uint8Array(_);const O=new Uint8Array([64,...w]);return!!Be.equalsUint8Array(O,_)}const j=(await Be.getNobleCurve(ve.publicKey.ecdsa,H)).getPublicKey(N,!1);return!!Be.equalsUint8Array(j,_)}function _n(w,O){const{payloadSize:_,wireFormatLeadingByte:N,name:F}=w,H=F===ve.curve.curve25519Legacy||F===ve.curve.ed25519Legacy?_:2*_;if(O[0]!==N||O.length!==H+1)throw Error("Invalid point encoding")}async function jn(w){const O=await Be.getNobleCurve(ve.publicKey.ecdsa,w),_=O.utils.randomPrivateKey();return{publicKey:O.getPublicKey(_,!1),privateKey:_}}function qn(w,O){const _=J(w.x),N=J(w.y),F=new Uint8Array(_.length+N.length+1);return F[0]=O,F.set(_,1),F.set(N,_.length+1),F}function Vn(w,O,_){const N=w,F=_.slice(1,N+1),H=_.slice(N+1,2*N+1);return{kty:"EC",crv:O,x:Y(F),y:Y(H),ext:!0}}function Jn(w,O,_,N){const F=Vn(w,O,_);return F.d=Y(N),F}const Qi=Be.getWebCrypto(),Gi=Be.getNodeCrypto();async function Wn(w,O,_,N,F,H){const j=new On(w);if(_n(j,N),_&&!Be.isStream(_)){const H={publicKey:N,privateKey:F};switch(j.type){case"web":try{return await async function(w,O,_,N){const F=w.payloadSize,H=Jn(w.payloadSize,Pi[w.name],N.publicKey,N.privateKey),j=await Qi.importKey("jwk",H,{name:"ECDSA",namedCurve:Pi[w.name],hash:{name:ve.read(ve.webHash,w.hash)}},!1,["sign"]),G=new Uint8Array(await Qi.sign({name:"ECDSA",namedCurve:Pi[w.name],hash:{name:ve.read(ve.webHash,O)}},j,_));return{r:G.slice(0,F),s:G.slice(F,F<<1)}}(j,O,_,H)}catch(w){if("nistP521"!==j.name&&("DataError"===w.name||"OperationError"===w.name))throw w;Be.printDebugError("Browser did not support signing: "+w.message)}break;case"node":return async function(w,O,_,N){const F=Be.nodeRequire("eckey-utils"),H=Be.getNodeBuffer(),{privateKey:j}=F.generateDer({curveName:_i[w.name],privateKey:H.from(N)}),G=Gi.createSign(ve.read(ve.hash,O));G.write(_),G.end();const z=new Uint8Array(G.sign({key:j,format:"der",type:"sec1",dsaEncoding:"ieee-p1363"})),X=w.payloadSize;return{r:z.subarray(0,X),s:z.subarray(X,X<<1)}}(j,O,_,F)}}const G=(await Be.getNobleCurve(ve.publicKey.ecdsa,j.name)).sign(H,F,{lowS:!1});return{r:de(G.r,"be",j.payloadSize),s:de(G.s,"be",j.payloadSize)}}async function $n(w,O,_,N,F,H){const j=new On(w);_n(j,F);const o=async()=>0===H[0]&&Xn(j,_,H.subarray(1),F);if(N&&!Be.isStream(N))switch(j.type){case"web":try{const w=await async function(w,O,{r:_,s:N},F,H){const j=Vn(w.payloadSize,Pi[w.name],H),G=await Qi.importKey("jwk",j,{name:"ECDSA",namedCurve:Pi[w.name],hash:{name:ve.read(ve.webHash,w.hash)}},!1,["verify"]),z=Be.concatUint8Array([_,N]).buffer;return Qi.verify({name:"ECDSA",namedCurve:Pi[w.name],hash:{name:ve.read(ve.webHash,O)}},G,z,F)}(j,O,_,N,F);return w||o()}catch(w){if("nistP521"!==j.name&&("DataError"===w.name||"OperationError"===w.name))throw w;Be.printDebugError("Browser did not support verifying: "+w.message)}break;case"node":{const w=await async function(w,O,{r:_,s:N},F,H){const j=Be.nodeRequire("eckey-utils"),G=Be.getNodeBuffer(),{publicKey:z}=j.generateDer({curveName:_i[w.name],publicKey:G.from(H)}),X=Gi.createVerify(ve.read(ve.hash,O));X.write(F),X.end();const ee=Be.concatUint8Array([_,N]);try{return X.verify({key:z,format:"der",type:"spki",dsaEncoding:"ieee-p1363"},ee)}catch(w){return!1}}(j,O,_,N,F);return w||o()}}return await Xn(j,_,H,F)||o()}async function Xn(w,O,_,N){return(await Be.getNobleCurve(ve.publicKey.ecdsa,w.name)).verify(Be.concatUint8Array([O.r,O.s]),_,N,{lowS:!1})}var zi=Object.freeze({__proto__:null,sign:Wn,validateParams:async function(w,O,_){const N=new On(w);if(N.keyType!==ve.publicKey.ecdsa)return!1;switch(N.type){case"web":case"node":{const N=we(8),F=ve.hash.sha256,H=await Ne(F,N);try{const j=await Wn(w,F,N,O,_,H);return await $n(w,F,j,N,O,H)}catch(w){return!1}}default:return Gn(ve.publicKey.ecdsa,w,O,_)}},verify:$n});async function ti(w,O,_,N,F,H){if(_n(new On(w),N),Fe(O)<Fe(ve.hash.sha256))throw Error("Hash algorithm too weak for EdDSA.");const{RS:j}=await ir(ve.publicKey.ed25519,O,0,N.subarray(1),F,H);return{r:j.subarray(0,32),s:j.subarray(32)}}async function ri(w,O,{r:_,s:N},F,H,j){if(_n(new On(w),H),Fe(O)<Fe(ve.hash.sha256))throw Error("Hash algorithm too weak for EdDSA.");const G=Be.concatUint8Array([_,N]);return sr(ve.publicKey.ed25519,O,{RS:G},0,H.subarray(1),j)}async function ni(w,O,_){if(w.getName()!==ve.curve.ed25519Legacy)return!1;const{publicKey:N}=Gt.sign.keyPair.fromSeed(_),F=new Uint8Array([64,...N]);return Be.equalsUint8Array(O,F)}var qi=Object.freeze({__proto__:null,sign:ti,validateParams:ni,verify:ri});function si(w){const O=w.length;if(O>0){const _=w[O-1];if(_>=1){const N=w.subarray(O-_),F=new Uint8Array(_).fill(_);if(Be.equalsUint8Array(N,F))return w.subarray(0,O-_)}}throw Error("Invalid padding")}const $i=Be.getWebCrypto(),Yi=Be.getNodeCrypto();function ci(w,O,_,N){return Be.concatUint8Array([O.write(),new Uint8Array([w]),_.write(),Be.stringToUint8Array("Anonymous Sender    "),N])}async function hi(w,O,_,N,F=!1,H=!1){let j;if(F){for(j=0;j<O.length&&0===O[j];j++);O=O.subarray(j)}if(H){for(j=O.length-1;j>=0&&0===O[j];j--);O=O.subarray(0,j+1)}return(await Ne(w,Be.concatUint8Array([new Uint8Array([0,0,0,1]),O,N]))).subarray(0,_)}async function ui(w,O){switch(w.type){case"curve25519Legacy":{const{sharedSecret:_,ephemeralPublicKey:N}=await Un(ve.publicKey.x25519,O.subarray(1));return{publicKey:Be.concatUint8Array([new Uint8Array([w.wireFormatLeadingByte]),N]),sharedKey:_}}case"web":if(w.web&&Be.getWebCrypto())try{return await async function(w,O){const _=Vn(w.payloadSize,w.web,O);let N=$i.generateKey({name:"ECDH",namedCurve:w.web},!0,["deriveKey","deriveBits"]),F=$i.importKey("jwk",_,{name:"ECDH",namedCurve:w.web},!1,[]);[N,F]=await Promise.all([N,F]);let H=$i.deriveBits({name:"ECDH",namedCurve:w.web,public:F},N.privateKey,w.sharedSize),j=$i.exportKey("jwk",N.publicKey);[H,j]=await Promise.all([H,j]);const G=new Uint8Array(H),z=new Uint8Array(qn(j,w.wireFormatLeadingByte));return{publicKey:z,sharedKey:G}}(w,O)}catch(_){return Be.printDebugError(_),pi(w,O)}break;case"node":return async function(w,O){const _=Yi.createECDH(w.node);_.generateKeys();const N=new Uint8Array(_.computeSecret(O));return{publicKey:new Uint8Array(_.getPublicKey()),sharedKey:N}}(w,O);default:return pi(w,O)}}async function li(w,O,_,N,F){const H=function(w){const O=8-w.length%8,_=new Uint8Array(w.length+O).fill(O);return _.set(w),_}(_),j=new On(w);_n(j,N);const{publicKey:G,sharedKey:z}=await ui(j,N),X=ci(ve.publicKey.ecdh,w,O,F),{keySize:ee}=wn(O.cipher),se=await hi(O.hash,z,ee,X);return{publicKey:G,wrappedKey:await bn(O.cipher,se,H)}}async function yi(w,O,_,N){if(N.length!==w.payloadSize){const O=new Uint8Array(w.payloadSize);O.set(N,w.payloadSize-N.length),N=O}switch(w.type){case"curve25519Legacy":{const w=N.slice().reverse();return{secretKey:w,sharedKey:await Pn(ve.publicKey.x25519,O.subarray(1),_.subarray(1),w)}}case"web":if(w.web&&Be.getWebCrypto())try{return await async function(w,O,_,N){const F=Jn(w.payloadSize,w.web,_,N);let H=$i.importKey("jwk",F,{name:"ECDH",namedCurve:w.web},!0,["deriveKey","deriveBits"]);const j=Vn(w.payloadSize,w.web,O);let G=$i.importKey("jwk",j,{name:"ECDH",namedCurve:w.web},!0,[]);[H,G]=await Promise.all([H,G]);let z=$i.deriveBits({name:"ECDH",namedCurve:w.web,public:G},H,w.sharedSize),X=$i.exportKey("jwk",H);[z,X]=await Promise.all([z,X]);const ee=new Uint8Array(z);return{secretKey:J(X.d),sharedKey:ee}}(w,O,_,N)}catch(_){return Be.printDebugError(_),gi(w,O,N)}break;case"node":return async function(w,O,_){const N=Yi.createECDH(w.node);N.setPrivateKey(_);const F=new Uint8Array(N.computeSecret(O));return{secretKey:new Uint8Array(N.getPrivateKey()),sharedKey:F}}(w,O,N);default:return gi(w,O,N)}}async function fi(w,O,_,N,F,H,j){const G=new On(w);_n(G,F),_n(G,_);const{sharedKey:z}=await yi(G,_,F,H),X=ci(ve.publicKey.ecdh,w,O,j),{keySize:ee}=wn(O.cipher);let se;for(let _=0;_<3;_++)try{const w=await hi(O.hash,z,ee,X,1===_,2===_);return si(await kn(O.cipher,w,N))}catch(w){se=w}throw se}async function gi(w,O,_){return{secretKey:_,sharedKey:(await Be.getNobleCurve(ve.publicKey.ecdh,w.name)).getSharedSecret(_,O).subarray(1)}}async function pi(w,O){const _=await Be.getNobleCurve(ve.publicKey.ecdh,w.name),{publicKey:N,privateKey:F}=await w.genKeyPair();return{publicKey:N,sharedKey:_.getSharedSecret(F,O).subarray(1)}}var Wi=Object.freeze({__proto__:null,CurveWithOID:On,ecdh:Object.freeze({__proto__:null,decrypt:fi,encrypt:li,validateParams:async function(w,O,_){return Gn(ve.publicKey.ecdh,w,O,_)}}),ecdhX:di,ecdsa:zi,eddsa:nn,eddsaLegacy:qi,generate:Hn,getPreferredHashAlgo:zn});const Zi=BigInt(0),Xi=BigInt(1);class mi{constructor(w){w&&(this.data=w)}read(w){if(w.length>=1){const O=w[0];if(w.length>=1+O)return this.data=w.subarray(1,1+O),1+this.data.length}throw Error("Invalid symmetric key")}write(){return Be.concatUint8Array([new Uint8Array([this.data.length]),this.data])}}class bi{constructor(w){if(w){const{hash:O,cipher:_}=w;this.hash=O,this.cipher=_}else this.hash=null,this.cipher=null}read(w){if(w.length<4||3!==w[0]||1!==w[1])throw new er("Cannot read KDFParams");return this.hash=w[2],this.cipher=w[3],4}write(){return new Uint8Array([3,1,this.hash,this.cipher])}}class ki{static fromObject({wrappedKey:w,algorithm:O}){const _=new ki;return _.wrappedKey=w,_.algorithm=O,_}read(w){let O=0,_=w[O++];this.algorithm=_%2?w[O++]:null,_-=_%2,this.wrappedKey=Be.readExactSubarray(w,O,O+_),O+=_}write(){return Be.concatUint8Array([this.algorithm?new Uint8Array([this.wrappedKey.length+1,this.algorithm]):new Uint8Array([this.wrappedKey.length]),this.wrappedKey])}}async function Ei(w,O,_,N,F){switch(w){case ve.publicKey.rsaEncrypt:case ve.publicKey.rsaEncryptSign:{const{n:w,e:O}=_;return{c:await Ye(N,w,O)}}case ve.publicKey.elgamal:{const{p:w,g:O,y:F}=_;return async function(w,O,_,N){O=oe(O),_=oe(_),N=oe(N);const F=oe(He(w,pe(O))),H=me(Ft,O-Ft);return{c1:de(he(_,H,O)),c2:de(ce(he(N,H,O)*F,O))}}(N,w,O,F)}case ve.publicKey.ecdh:{const{oid:w,Q:O,kdfParams:H}=_,{publicKey:j,wrappedKey:G}=await li(w,H,N,O,F);return{V:j,C:new mi(G)}}case ve.publicKey.x25519:case ve.publicKey.x448:{if(O&&!Be.isAES(O))throw Error("X25519 and X448 keys can only encrypt AES session keys");const{A:F}=_,{ephemeralPublicKey:H,wrappedKey:j}=await Kn(w,N,F);return{ephemeralPublicKey:H,C:ki.fromObject({algorithm:O,wrappedKey:j})}}default:return[]}}async function vi(w,O,_,N,F,H){switch(w){case ve.publicKey.rsaEncryptSign:case ve.publicKey.rsaEncrypt:{const{c:w}=N,{n:F,e:j}=O,{d:G,p:z,q:X,u:ee}=_;return Ze(w,F,j,G,z,X,ee,H)}case ve.publicKey.elgamal:{const{c1:w,c2:F}=N;return async function(w,O,_,N,F){return w=oe(w),O=oe(O),_=oe(_),ze(de(ce(le(he(w,N=oe(N),_),_)*O,_),"be",pe(_)),F)}(w,F,O.p,_.x,H)}case ve.publicKey.ecdh:{const{oid:w,Q:H,kdfParams:j}=O,{d:G}=_,{V:z,C:X}=N;return fi(w,j,z,X.data,H,G,F)}case ve.publicKey.x25519:case ve.publicKey.x448:{const{A:F}=O,{k:H}=_,{ephemeralPublicKey:j,C:G}=N;if(null!==G.algorithm&&!Be.isAES(G.algorithm))throw Error("AES session key expected");return Cn(w,j,G.wrappedKey,F,H)}default:throw Error("Unknown public key encryption algorithm.")}}function Ii(w,O,_){let N=0;switch(w){case ve.publicKey.rsaEncrypt:case ve.publicKey.rsaEncryptSign:case ve.publicKey.rsaSign:{const w=Be.readMPI(O.subarray(N));N+=w.length+2;const _=Be.readMPI(O.subarray(N));N+=_.length+2;const F=Be.readMPI(O.subarray(N));N+=F.length+2;const H=Be.readMPI(O.subarray(N));return N+=H.length+2,{read:N,privateParams:{d:w,p:_,q:F,u:H}}}case ve.publicKey.dsa:case ve.publicKey.elgamal:{const w=Be.readMPI(O.subarray(N));return N+=w.length+2,{read:N,privateParams:{x:w}}}case ve.publicKey.ecdsa:case ve.publicKey.ecdh:{const F=Ui(w,_.oid);let H=Be.readMPI(O.subarray(N));return N+=H.length+2,H=Be.leftPad(H,F),{read:N,privateParams:{d:H}}}case ve.publicKey.eddsaLegacy:{const F=Ui(w,_.oid);if(_.oid.getName()!==ve.curve.ed25519Legacy)throw Error("Unexpected OID for eddsaLegacy");let H=Be.readMPI(O.subarray(N));return N+=H.length+2,H=Be.leftPad(H,F),{read:N,privateParams:{seed:H}}}case ve.publicKey.ed25519:case ve.publicKey.ed448:{const _=Ui(w),F=Be.readExactSubarray(O,N,N+_);return N+=F.length,{read:N,privateParams:{seed:F}}}case ve.publicKey.x25519:case ve.publicKey.x448:{const _=Ui(w),F=Be.readExactSubarray(O,N,N+_);return N+=F.length,{read:N,privateParams:{k:F}}}default:throw new er("Unknown public key encryption algorithm.")}}function Bi(w,O){const _=new Set([ve.publicKey.ed25519,ve.publicKey.x25519,ve.publicKey.ed448,ve.publicKey.x448]),N=Object.keys(O).map((N=>{const F=O[N];return Be.isUint8Array(F)?_.has(w)?F:Be.uint8ArrayToMPI(F):F.write()}));return Be.concatUint8Array(N)}function Si(w,O,_){switch(w){case ve.publicKey.rsaEncrypt:case ve.publicKey.rsaEncryptSign:case ve.publicKey.rsaSign:return async function(w,O){if(O=BigInt(O),Be.getWebCrypto()){const _={name:"RSASSA-PKCS1-v1_5",modulusLength:w,publicExponent:de(O),hash:{name:"SHA-1"}},N=await ft.generateKey(_,!0,["sign","verify"]);return Xe(await ft.exportKey("jwk",N.privateKey),O)}if(Be.getNodeCrypto()){const _={modulusLength:w,publicExponent:ye(O),publicKeyEncoding:{type:"pkcs1",format:"jwk"},privateKeyEncoding:{type:"pkcs1",format:"jwk"}},N=await new Promise(((w,O)=>{yt.generateKeyPair("rsa",_,((_,N,F)=>{_?O(_):w(F)}))}));return Xe(N,O)}let _,N,F;do{N=ke(w-(w>>1),O,40),_=ke(w>>1,O,40),F=_*N}while(ge(F)!==w);const H=(_-Ut)*(N-Ut);return N<_&&([_,N]=[N,_]),{n:de(F),e:de(O),d:de(le(O,H)),p:de(_),q:de(N),u:de(le(_,N))}}(O,65537).then((({n:w,e:O,d:_,p:N,q:F,u:H})=>({privateParams:{d:_,p:N,q:F,u:H},publicParams:{n:w,e:O}})));case ve.publicKey.ecdsa:return Hn(_).then((({oid:w,Q:O,secret:_})=>({privateParams:{d:_},publicParams:{oid:new qt(w),Q:O}})));case ve.publicKey.eddsaLegacy:return Hn(_).then((({oid:w,Q:O,secret:_})=>({privateParams:{seed:_},publicParams:{oid:new qt(w),Q:O}})));case ve.publicKey.ecdh:return Hn(_).then((({oid:w,Q:O,secret:_,hash:N,cipher:F})=>({privateParams:{d:_},publicParams:{oid:new qt(w),Q:O,kdfParams:new bi({hash:N,cipher:F})}})));case ve.publicKey.ed25519:case ve.publicKey.ed448:return nr(w).then((({A:w,seed:O})=>({privateParams:{seed:O},publicParams:{A:w}})));case ve.publicKey.x25519:case ve.publicKey.x448:return Bn(w).then((({A:w,k:O})=>({privateParams:{k:O},publicParams:{A:w}})));case ve.publicKey.dsa:case ve.publicKey.elgamal:throw Error("Unsupported algorithm for key generation.");default:throw Error("Unknown public key algorithm.")}}async function Ki(w,O,_){if(!O||!_)throw Error("Missing key parameters");switch(w){case ve.publicKey.rsaEncrypt:case ve.publicKey.rsaEncryptSign:case ve.publicKey.rsaSign:{const{n:w,e:N}=O,{d:F,p:H,q:j,u:G}=_;return async function(w,O,_,N,F,H){if(w=oe(w),(N=oe(N))*(F=oe(F))!==w)return!1;const j=BigInt(2);if(ce(N*(H=oe(H)),F)!==BigInt(1))return!1;O=oe(O),_=oe(_);const G=me(j,j<<BigInt(Math.floor(ge(w)/3))),z=G*_*O;return!(ce(z,N-Ut)!==G||ce(z,F-Ut)!==G)}(w,N,F,H,j,G)}case ve.publicKey.dsa:{const{p:w,q:N,g:F,y:H}=O,{x:j}=_;return async function(w,O,_,N,F){if(w=oe(w),O=oe(O),_=oe(_),N=oe(N),_<=Xi||_>=w)return!1;if(ce(w-Xi,O)!==Zi)return!1;if(he(_,O,w)!==Xi)return!1;const H=BigInt(ge(O));if(H<BigInt(150)||!Ee(O,null,32))return!1;F=oe(F);const j=BigInt(2);return N===he(_,O*me(j<<H-Xi,j<<H)+F,w)}(w,N,F,H,j)}case ve.publicKey.elgamal:{const{p:w,g:N,y:F}=O,{x:H}=_;return async function(w,O,_,N){if(w=oe(w),O=oe(O),_=oe(_),O<=Ft||O>=w)return!1;const F=BigInt(ge(w));if(F<BigInt(1023))return!1;if(he(O,w-Ft,w)!==Ft)return!1;let H=O,j=BigInt(1);const G=BigInt(2),z=G<<BigInt(17);for(;j<z;){if(H=ce(H*O,w),H===Ft)return!1;j++}N=oe(N);const X=me(G<<F-Ft,G<<F);return _===he(O,(w-Ft)*X+N,w)}(w,N,F,H)}case ve.publicKey.ecdsa:case ve.publicKey.ecdh:{const N=Wi[ve.read(ve.publicKey,w)],{oid:F,Q:H}=O,{d:j}=_;return N.validateParams(F,H,j)}case ve.publicKey.eddsaLegacy:{const{Q:w,oid:N}=O,{seed:F}=_;return ni(N,w,F)}case ve.publicKey.ed25519:case ve.publicKey.ed448:{const{A:N}=O,{seed:F}=_;return ar(w,N,F)}case ve.publicKey.x25519:case ve.publicKey.x448:{const{A:N}=O,{k:F}=_;return Sn(w,N,F)}default:throw Error("Unknown public key algorithm.")}}function Ci(w){const{keySize:O}=wn(w);return we(O)}function Di(w){try{w.getName()}catch(w){throw new er("Unknown curve OID")}}function Ui(w,O){switch(w){case ve.publicKey.ecdsa:case ve.publicKey.ecdh:case ve.publicKey.eddsaLegacy:return new On(O).payloadSize;case ve.publicKey.ed25519:case ve.publicKey.ed448:return or(w);case ve.publicKey.x25519:case ve.publicKey.x448:return Dn(w);default:throw Error("Unknown elliptic algo")}}const es=Be.getWebCrypto(),ts=Be.getNodeCrypto(),rs=ts?ts.getCiphers():[],ns={idea:rs.includes("idea-cfb")?"idea-cfb":void 0,tripledes:rs.includes("des-ede3-cfb")?"des-ede3-cfb":void 0,cast5:rs.includes("cast5-cfb")?"cast5-cfb":void 0,blowfish:rs.includes("bf-cfb")?"bf-cfb":void 0,aes128:rs.includes("aes-128-cfb")?"aes-128-cfb":void 0,aes192:rs.includes("aes-192-cfb")?"aes-192-cfb":void 0,aes256:rs.includes("aes-256-cfb")?"aes-256-cfb":void 0};async function Ti(w){const{blockSize:O}=wn(w),_=await we(O),N=new Uint8Array([_[_.length-2],_[_.length-1]]);return Be.concat([_,N])}async function Li(w,O,_,N,F){const H=ve.read(ve.symmetric,w);if(Be.getNodeCrypto()&&ns[H])return function(w,O,_,N){const F=ve.read(ve.symmetric,w),H=new ts.createCipheriv(ns[F],O,N);return S(_,(w=>new Uint8Array(H.update(w))))}(w,O,_,N);if(Be.isAES(w))return async function(w,O,_,N){if(es&&await Ni.isSupported(w)){const F=new Ni(w,O,N);return Be.isStream(_)?S(_,(w=>F.encryptChunk(w)),(()=>F.finish())):F.encrypt(_)}if(Be.isStream(_)){const F=new Fi(!0,w,O,N);return S(_,(w=>F.processChunk(w)),(()=>F.finish()))}return Ln(O,N).encrypt(_)}(w,O,_,N);const j=new(await pn(w))(O),G=j.blockSize,z=N.slice();let X=new Uint8Array;const u=w=>{w&&(X=Be.concatUint8Array([X,w]));const O=new Uint8Array(X.length);let _,N=0;for(;w?X.length>=G:X.length;){const w=j.encrypt(z);for(_=0;_<G;_++)z[_]=X[_]^w[_],O[N++]=z[_];X=X.subarray(G)}return O.subarray(0,N)};return S(_,u,u)}async function Mi(w,O,_,N){const F=ve.read(ve.symmetric,w);if(ts&&ns[F])return function(w,O,_,N){const F=ve.read(ve.symmetric,w),H=new ts.createDecipheriv(ns[F],O,N);return S(_,(w=>new Uint8Array(H.update(w))))}(w,O,_,N);if(Be.isAES(w))return async function(w,O,_,N){if(Be.isStream(_)){const F=new Fi(!1,w,O,N);return S(_,(w=>F.processChunk(w)),(()=>F.finish()))}return Ln(O,N).decrypt(_)}(w,O,_,N);const H=new(await pn(w))(O),j=H.blockSize;let G=N,z=new Uint8Array;const h=w=>{w&&(z=Be.concatUint8Array([z,w]));const O=new Uint8Array(z.length);let _,N=0;for(;w?z.length>=j:z.length;){const w=H.encrypt(G);for(G=z.subarray(0,j),_=0;_<j;_++)O[N++]=G[_]^w[_];z=z.subarray(j)}return O.subarray(0,N)};return S(_,h,h)}class Ni{constructor(w,O,_){const{blockSize:N}=wn(w);this.key=O,this.prevBlock=_,this.nextBlock=new Uint8Array(N),this.i=0,this.blockSize=N,this.zeroBlock=new Uint8Array(this.blockSize)}static async isSupported(w){const{keySize:O}=wn(w);return es.importKey("raw",new Uint8Array(O),"aes-cbc",!1,["encrypt"]).then((()=>!0),(()=>!1))}async _runCBC(w,O){const _="AES-CBC";this.keyRef=this.keyRef||await es.importKey("raw",this.key,_,!1,["encrypt"]);const N=await es.encrypt({name:_,iv:O||this.zeroBlock},this.keyRef,w);return new Uint8Array(N).subarray(0,w.length)}async encryptChunk(w){const O=this.nextBlock.length-this.i,_=w.subarray(0,O);if(this.nextBlock.set(_,this.i),this.i+w.length>=2*this.blockSize){const _=(w.length-O)%this.blockSize,N=Be.concatUint8Array([this.nextBlock,w.subarray(O,w.length-_)]),F=Be.concatUint8Array([this.prevBlock,N.subarray(0,N.length-this.blockSize)]),H=await this._runCBC(F);return Oi(H,N),this.prevBlock=H.slice(-this.blockSize),_>0&&this.nextBlock.set(w.subarray(-_)),this.i=_,H}let N;if(this.i+=_.length,this.i===this.nextBlock.length){const O=this.nextBlock;N=await this._runCBC(this.prevBlock),Oi(N,O),this.prevBlock=N.slice(),this.i=0;const F=w.subarray(_.length);this.nextBlock.set(F,this.i),this.i+=F.length}else N=new Uint8Array;return N}async finish(){let w;if(0===this.i)w=new Uint8Array;else{this.nextBlock=this.nextBlock.subarray(0,this.i);const O=this.nextBlock,_=await this._runCBC(this.prevBlock);Oi(_,O),w=_.subarray(0,O.length)}return this.clearSensitiveData(),w}clearSensitiveData(){this.nextBlock.fill(0),this.prevBlock.fill(0),this.keyRef=null,this.key=null}async encrypt(w){const O=(await this._runCBC(Be.concatUint8Array([new Uint8Array(this.blockSize),w]),this.iv)).subarray(0,w.length);return Oi(O,w),this.clearSensitiveData(),O}}class Fi{constructor(w,O,_,N){this.forEncryption=w;const{blockSize:F}=wn(O);this.key=ei.expandKeyLE(_),N.byteOffset%4!=0&&(N=N.slice()),this.prevBlock=Hi(N),this.nextBlock=new Uint8Array(F),this.i=0,this.blockSize=F}_runCFB(w){const O=Hi(w),_=new Uint8Array(w.length),N=Hi(_);for(let w=0;w+4<=N.length;w+=4){const{s0:_,s1:F,s2:H,s3:j}=ei.encrypt(this.key,this.prevBlock[0],this.prevBlock[1],this.prevBlock[2],this.prevBlock[3]);N[w+0]=O[w+0]^_,N[w+1]=O[w+1]^F,N[w+2]=O[w+2]^H,N[w+3]=O[w+3]^j,this.prevBlock=(this.forEncryption?N:O).slice(w,w+4)}return _}async processChunk(w){const O=this.nextBlock.length-this.i,_=w.subarray(0,O);if(this.nextBlock.set(_,this.i),this.i+w.length>=2*this.blockSize){const _=(w.length-O)%this.blockSize,N=Be.concatUint8Array([this.nextBlock,w.subarray(O,w.length-_)]),F=this._runCFB(N);return _>0&&this.nextBlock.set(w.subarray(-_)),this.i=_,F}let N;if(this.i+=_.length,this.i===this.nextBlock.length){N=this._runCFB(this.nextBlock),this.i=0;const O=w.subarray(_.length);this.nextBlock.set(O,this.i),this.i+=O.length}else N=new Uint8Array;return N}async finish(){let w;if(0===this.i)w=new Uint8Array;else{w=this._runCFB(this.nextBlock).subarray(0,this.i)}return this.clearSensitiveData(),w}clearSensitiveData(){this.nextBlock.fill(0),this.prevBlock.fill(0),this.key.fill(0)}}function Oi(w,O){const _=Math.min(w.length,O.length);for(let N=0;N<_;N++)w[N]=w[N]^O[N]}const Hi=w=>new Uint32Array(w.buffer,w.byteOffset,Math.floor(w.byteLength/4));const os=Be.getWebCrypto(),cs=Be.getNodeCrypto(),hs=16;function ji(w,O){const _=w.length-hs;for(let N=0;N<hs;N++)w[N+_]^=O[N];return w}const fs=new Uint8Array(hs);async function Vi(w){const O=await Ji(w),_=Be.double(await O(fs)),N=Be.double(_);return async function(w){return(await O(function(w,O,_){if(w.length&&w.length%hs==0)return ji(w,O);const N=new Uint8Array(w.length+(hs-w.length%hs));return N.set(w),N[w.length]=128,ji(N,_)}(w,_,N))).subarray(-hs)}}async function Ji(w){if(Be.getNodeCrypto())return async function(O){const _=new cs.createCipheriv("aes-"+8*w.length+"-cbc",w,fs).update(O);return new Uint8Array(_)};if(Be.getWebCrypto())try{return w=await os.importKey("raw",w,{name:"AES-CBC",length:8*w.length},!1,["encrypt"]),async function(O){const _=await os.encrypt({name:"AES-CBC",iv:fs,length:8*hs},w,O);return new Uint8Array(_).subarray(0,_.byteLength-hs)}}catch(O){if("NotSupportedError"!==O.name&&(24!==w.length||"OperationError"!==O.name))throw O;Be.printDebugError("Browser did not support operation: "+O.message)}return async function(O){return Mn(w,fs,{disablePadding:!0}).encrypt(O)}}const ds=Be.getWebCrypto(),gs=Be.getNodeCrypto(),ws=Be.getNodeBuffer(),ms=16,As=ms,bs=ms,Ss=new Uint8Array(ms),Ks=new Uint8Array(ms);Ks[ms-1]=1;const Us=new Uint8Array(ms);async function is(w){const O=await Vi(w);return function(w,_){return O(Be.concatUint8Array([w,_]))}}async function ss(w){if(Be.getNodeCrypto())return async function(O,_){const N=new gs.createCipheriv("aes-"+8*w.length+"-ctr",w,_),F=ws.concat([N.update(O),N.final()]);return new Uint8Array(F)};if(Be.getWebCrypto())try{const O=await ds.importKey("raw",w,{name:"AES-CTR",length:8*w.length},!1,["encrypt"]);return async function(w,_){const N=await ds.encrypt({name:"AES-CTR",counter:_,length:8*ms},O,w);return new Uint8Array(N)}}catch(O){if("NotSupportedError"!==O.name&&(24!==w.length||"OperationError"!==O.name))throw O;Be.printDebugError("Browser did not support operation: "+O.message)}return async function(O,_){return Qn(w,_).encrypt(O)}}async function as(w,O){if(w!==ve.symmetric.aes128&&w!==ve.symmetric.aes192&&w!==ve.symmetric.aes256)throw Error("EAX mode supports only AES cipher");const[_,N]=await Promise.all([is(O),ss(O)]);return{encrypt:async function(w,O,F){const[H,j]=await Promise.all([_(Ss,O),_(Ks,F)]),G=await N(w,H),z=await _(Us,G);for(let w=0;w<bs;w++)z[w]^=j[w]^H[w];return Be.concatUint8Array([G,z])},decrypt:async function(w,O,F){if(w.length<bs)throw Error("Invalid EAX ciphertext");const H=w.subarray(0,-bs),j=w.subarray(-bs),[G,z,X]=await Promise.all([_(Ss,O),_(Ks,F),_(Us,H)]),ee=X;for(let w=0;w<bs;w++)ee[w]^=z[w]^G[w];if(!Be.equalsUint8Array(j,ee))throw Error("Authentication tag mismatch");return await N(H,G)}}}Us[ms-1]=2,as.getNonce=function(w,O){const _=w.slice();for(let w=0;w<O.length;w++)_[8+w]^=O[w];return _},as.blockLength=ms,as.ivLength=As,as.tagLength=bs;const _s=16,Rs=15,Ts=16;function us(w){let O=0;for(let _=1;!(w&_);_<<=1)O++;return O}function ls(w,O){for(let _=0;_<w.length;_++)w[_]^=O[_];return w}function ys(w,O){return ls(w.slice(),O)}const Qs=new Uint8Array(_s),Ms=new Uint8Array([1]);async function ps(w,O){const{keySize:_}=wn(w);if(!Be.isAES(w)||O.length!==_)throw Error("Unexpected algorithm or key size");let N=0;const F=Mn(O,Qs,{disablePadding:!0}),s=w=>F.encrypt(w),a=w=>F.decrypt(w);let H;function c(w,O,_,F){const j=O.length/_s|0;!function(w,O){const _=Be.nbits(Math.max(w.length,O.length)/_s|0)-1;for(let w=N+1;w<=_;w++)H[w]=Be.double(H[w-1]);N=_}(O,F);const G=Be.concatUint8Array([Qs.subarray(0,Rs-_.length),Ms,_]),z=63&G[_s-1];G[_s-1]&=192;const X=s(G),ee=Be.concatUint8Array([X,ys(X.subarray(0,8),X.subarray(1,9))]),se=Be.shiftRight(ee.subarray(0+(z>>3),17+(z>>3)),8-(7&z)).subarray(1),ae=new Uint8Array(_s),Ae=new Uint8Array(O.length+Ts);let be,ve=0;for(be=0;be<j;be++)ls(se,H[us(be+1)]),Ae.set(ls(w(ys(se,O)),se),ve),ls(ae,w===s?O:Ae.subarray(ve)),O=O.subarray(_s),ve+=_s;if(O.length){ls(se,H.x);const _=s(se);Ae.set(ys(O,_),ve);const N=new Uint8Array(_s);N.set(w===s?O:Ae.subarray(ve,-Ts),0),N[O.length]=128,ls(ae,N),ve+=O.length}const Se=ls(s(ls(ls(ae,se),H.$)),function(w){if(!w.length)return Qs;const O=w.length/_s|0,_=new Uint8Array(_s),N=new Uint8Array(_s);for(let F=0;F<O;F++)ls(_,H[us(F+1)]),ls(N,s(ys(_,w))),w=w.subarray(_s);if(w.length){ls(_,H.x);const O=new Uint8Array(_s);O.set(w,0),O[w.length]=128,ls(O,_),ls(N,s(O))}return N}(F));return Ae.set(Se,ve),Ae}return function(){const w=s(Qs),O=Be.double(w);H=[],H[0]=Be.double(O),H.x=w,H.$=O}(),{encrypt:async function(w,O,_){return c(s,w,O,_)},decrypt:async function(w,O,_){if(w.length<Ts)throw Error("Invalid OCB ciphertext");const N=w.subarray(-Ts);w=w.subarray(0,-Ts);const F=c(a,w,O,_);if(Be.equalsUint8Array(N,F.subarray(-Ts)))return F.subarray(0,-Ts);throw Error("Authentication tag mismatch")}}}ps.getNonce=function(w,O){const _=w.slice();for(let w=0;w<O.length;w++)_[7+w]^=O[w];return _},ps.blockLength=_s,ps.ivLength=Rs,ps.tagLength=Ts;const Ls=Be.getWebCrypto(),Ns=Be.getNodeCrypto(),Fs=Be.getNodeBuffer(),Hs=16,js="AES-GCM";async function ks(w,O){if(w!==ve.symmetric.aes128&&w!==ve.symmetric.aes192&&w!==ve.symmetric.aes256)throw Error("GCM mode supports only AES cipher");if(Be.getNodeCrypto())return{encrypt:async function(w,_,N=new Uint8Array){const F=new Ns.createCipheriv("aes-"+8*O.length+"-gcm",O,_);F.setAAD(N);const H=Fs.concat([F.update(w),F.final(),F.getAuthTag()]);return new Uint8Array(H)},decrypt:async function(w,_,N=new Uint8Array){const F=new Ns.createDecipheriv("aes-"+8*O.length+"-gcm",O,_);F.setAAD(N),F.setAuthTag(w.slice(w.length-Hs,w.length));const H=Fs.concat([F.update(w.slice(0,w.length-Hs)),F.final()]);return new Uint8Array(H)}};if(Be.getWebCrypto())try{const w=await Ls.importKey("raw",O,{name:js},!1,["encrypt","decrypt"]),_=navigator.userAgent.match(/Version\/13\.\d(\.\d)* Safari/)||navigator.userAgent.match(/Version\/(13|14)\.\d(\.\d)* Mobile\/\S* Safari/);return{encrypt:async function(N,F,H=new Uint8Array){if(_&&!N.length)return Nn(O,F,H).encrypt(N);const j=await Ls.encrypt({name:js,iv:F,additionalData:H,tagLength:8*Hs},w,N);return new Uint8Array(j)},decrypt:async function(N,F,H=new Uint8Array){if(_&&N.length===Hs)return Nn(O,F,H).decrypt(N);try{const O=await Ls.decrypt({name:js,iv:F,additionalData:H,tagLength:8*Hs},w,N);return new Uint8Array(O)}catch(w){if("OperationError"===w.name)throw Error("Authentication tag mismatch")}}}}catch(w){if("NotSupportedError"!==w.name&&(24!==O.length||"OperationError"!==w.name))throw w;Be.printDebugError("Browser did not support operation: "+w.message)}return{encrypt:async function(w,_,N){return Nn(O,_,N).encrypt(w)},decrypt:async function(w,_,N){return Nn(O,_,N).decrypt(w)}}}function Es(w,O=!1){switch(w){case ve.aead.eax:return as;case ve.aead.ocb:return ps;case ve.aead.gcm:return ks;case ve.aead.experimentalGCM:if(!O)throw Error("Unexpected non-standard `experimentalGCM` AEAD algorithm provided in `config.preferredAEADAlgorithm`: use `gcm` instead");return ks;default:throw Error("Unsupported AEAD mode")}}async function vs(w,O,_,N,F,H){switch(w){case ve.publicKey.rsaEncryptSign:case ve.publicKey.rsaEncrypt:case ve.publicKey.rsaSign:{const{n:w,e:j}=N;return Je(O,F,Be.leftPad(_.s,w.length),w,j,H)}case ve.publicKey.dsa:{const{g:w,p:O,q:F,y:j}=N,{r:G,s:z}=_;return async function(w,O,_,N,F,H,j,G){if(O=oe(O),_=oe(_),H=oe(H),j=oe(j),F=oe(F),G=oe(G),O<=Zi||O>=j||_<=Zi||_>=j)return Be.printDebug("invalid DSA Signature"),!1;const z=ce(oe(N.subarray(0,pe(j))),j),X=le(_,j);if(X===Zi)return Be.printDebug("invalid DSA Signature"),!1;F=ce(F,H),G=ce(G,H);const ee=ce(z*X,j),se=ce(O*X,j);return ce(ce(he(F,ee,H)*he(G,se,H),H),j)===O}(0,G,z,H,w,O,F,j)}case ve.publicKey.ecdsa:{const{oid:w,Q:j}=N,G=new On(w).payloadSize;return $n(w,O,{r:Be.leftPad(_.r,G),s:Be.leftPad(_.s,G)},F,j,H)}case ve.publicKey.eddsaLegacy:{const{oid:w,Q:F}=N,j=new On(w).payloadSize;return ri(w,O,{r:Be.leftPad(_.r,j),s:Be.leftPad(_.s,j)},0,F,H)}case ve.publicKey.ed25519:case ve.publicKey.ed448:{const{A:F}=N;return sr(w,O,_,0,F,H)}default:throw Error("Unknown signature algorithm.")}}async function Is(w,O,_,N,F,H){if(!_||!N)throw Error("Missing key parameters");switch(w){case ve.publicKey.rsaEncryptSign:case ve.publicKey.rsaEncrypt:case ve.publicKey.rsaSign:{const{n:w,e:j}=_,{d:G,p:z,q:X,u:ee}=N;return{s:await Ve(O,F,w,j,G,z,X,ee,H)}}case ve.publicKey.dsa:{const{g:w,p:O,q:F}=_,{x:j}=N;return async function(w,O,_,N,F,H){const j=BigInt(0);let G,z,X,ee;N=oe(N),F=oe(F),_=oe(_),H=oe(H),_=ce(_,N),H=ce(H,F);const se=ce(oe(O.subarray(0,pe(F))),F);for(;;){if(G=me(Xi,F),z=ce(he(_,G,N),F),z===j)continue;const w=ce(H*z,F);if(ee=ce(se+w,F),X=ce(le(G,F)*ee,F),X!==j)break}return{r:de(z,"be",pe(N)),s:de(X,"be",pe(N))}}(0,H,w,O,F,j)}case ve.publicKey.elgamal:throw Error("Signing with Elgamal is not defined in the OpenPGP standard.");case ve.publicKey.ecdsa:{const{oid:w,Q:j}=_,{d:G}=N;return Wn(w,O,F,j,G,H)}case ve.publicKey.eddsaLegacy:{const{oid:w,Q:F}=_,{seed:j}=N;return ti(w,O,0,F,j,H)}case ve.publicKey.ed25519:case ve.publicKey.ed448:{const{A:F}=_,{seed:j}=N;return ir(w,O,0,F,j,H)}default:throw Error("Unknown signature algorithm.")}}ks.getNonce=function(w,O){const _=w.slice();for(let w=0;w<O.length;w++)_[4+w]^=O[w];return _},ks.blockLength=16,ks.ivLength=12,ks.tagLength=Hs;class Bs extends Error{constructor(...w){super(...w),Error.captureStackTrace&&Error.captureStackTrace(this,Bs),this.name="Argon2OutOfMemoryError"}}let Gs,zs;class Cs{constructor(w=Se){const{passes:O,parallelism:_,memoryExponent:N}=w.s2kArgon2Params;this.type="argon2",this.salt=null,this.t=O,this.p=_,this.encodedM=N}generateSalt(){this.salt=we(16)}read(w){let O=0;return this.salt=w.subarray(O,O+16),O+=16,this.t=w[O++],this.p=w[O++],this.encodedM=w[O++],O}write(){const w=[new Uint8Array([ve.write(ve.s2k,this.type)]),this.salt,new Uint8Array([this.t,this.p,this.encodedM])];return Be.concatUint8Array(w)}async produceKey(w,O){const _=2<<this.encodedM-1;try{Gs=Gs||(await Promise.resolve().then((function(){return Rf}))).default,zs=zs||Gs();const N=await zs,F=N({version:19,type:2,password:Be.encodeUTF8(w),salt:this.salt,tagLength:O,memorySize:_,parallelism:this.p,passes:this.t});return _>1048576&&(zs=Gs(),zs.catch((()=>{}))),F}catch(w){throw w.message&&(w.message.includes("Unable to grow instance memory")||w.message.includes("failed to grow memory")||w.message.includes("WebAssembly.Memory.grow")||w.message.includes("Out of memory"))?new Bs("Could not allocate required memory for Argon2"):w}}}class Ds{constructor(w,O=Se){this.algorithm=ve.hash.sha256,this.type=ve.read(ve.s2k,w),this.c=O.s2kIterationCountByte,this.salt=null}generateSalt(){switch(this.type){case"salted":case"iterated":this.salt=we(8)}}getCount(){return 16+(15&this.c)<<6+(this.c>>4)}read(w){let O=0;switch(this.algorithm=w[O++],this.type){case"simple":break;case"salted":this.salt=w.subarray(O,O+8),O+=8;break;case"iterated":this.salt=w.subarray(O,O+8),O+=8,this.c=w[O++];break;case"gnu":if("GNU"!==Be.uint8ArrayToString(w.subarray(O,O+3)))throw new er("Unknown s2k type.");O+=3;if(1001!==1e3+w[O++])throw new er("Unknown s2k gnu protection mode.");this.type="gnu-dummy";break;default:throw new er("Unknown s2k type.")}return O}write(){if("gnu-dummy"===this.type)return new Uint8Array([101,0,...Be.stringToUint8Array("GNU"),1]);const w=[new Uint8Array([ve.write(ve.s2k,this.type),this.algorithm])];switch(this.type){case"simple":break;case"salted":w.push(this.salt);break;case"iterated":w.push(this.salt),w.push(new Uint8Array([this.c]));break;case"gnu":throw Error("GNU s2k type not supported.");default:throw Error("Unknown s2k type.")}return Be.concatUint8Array(w)}async produceKey(w,O){w=Be.encodeUTF8(w);const _=[];let N=0,F=0;for(;N<O;){let O;switch(this.type){case"simple":O=Be.concatUint8Array([new Uint8Array(F),w]);break;case"salted":O=Be.concatUint8Array([new Uint8Array(F),this.salt,w]);break;case"iterated":{const _=Be.concatUint8Array([this.salt,w]);let N=_.length;const H=Math.max(this.getCount(),N);O=new Uint8Array(F+H),O.set(_,F);for(let w=F+N;w<H;w+=N,N*=2)O.copyWithin(w,F,w);break}case"gnu":throw Error("GNU s2k type not supported.");default:throw Error("Unknown s2k type.")}const H=await Ne(this.algorithm,O);_.push(H),N+=H.length,F++}return Be.concatUint8Array(_).subarray(0,O)}}const qs=new Set([ve.s2k.argon2,ve.s2k.iterated]);function Ps(w,O=Se){switch(w){case ve.s2k.argon2:return new Cs(O);case ve.s2k.iterated:case ve.s2k.gnu:case ve.s2k.salted:case ve.s2k.simple:return new Ds(w,O);default:throw new er("Unsupported S2K type")}}function xs(w){const{s2kType:O}=w;if(!qs.has(O))throw Error("The provided `config.s2kType` value is not allowed");return Ps(O,w)}var $s=F.createRequire("/");try{$s("worker_threads").Worker}catch(N){}var Vs=Uint8Array,Js=Uint16Array,Ys=Uint32Array,Ws=new Vs([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Xs=new Vs([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),ea=new Vs([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Os=function(w,O){for(var _=new Js(31),N=0;N<31;++N)_[N]=O+=1<<w[N-1];var F=new Ys(_[30]);for(N=1;N<30;++N)for(var H=_[N];H<_[N+1];++H)F[H]=H-_[N]<<5|N;return[_,F]},ta=Os(Ws,2),ra=ta[0],ca=ta[1];ra[28]=258,ca[258]=28;for(var wa=Os(Xs,0),ma=wa[0],va=wa[1],Ea=new Js(32768),ka=0;ka<32768;++ka){var Ia=(43690&ka)>>>1|(21845&ka)<<1;Ia=(61680&(Ia=(52428&Ia)>>>2|(13107&Ia)<<2))>>>4|(3855&Ia)<<4,Ea[ka]=((65280&Ia)>>>8|(255&Ia)<<8)>>>1}var Zs=function(w,O,_){for(var N=w.length,F=0,H=new Js(O);F<N;++F)w[F]&&++H[w[F]-1];var j,G=new Js(O);for(F=0;F<O;++F)G[F]=G[F-1]+H[F-1]<<1;if(_){j=new Js(1<<O);var z=15-O;for(F=0;F<N;++F)if(w[F])for(var X=F<<4|w[F],ee=O-w[F],se=G[w[F]-1]++<<ee,ae=se|(1<<ee)-1;se<=ae;++se)j[Ea[se]>>>z]=X}else for(j=new Js(N),F=0;F<N;++F)w[F]&&(j[F]=Ea[G[w[F]-1]++]>>>15-w[F]);return j},Ba=new Vs(288);for(ka=0;ka<144;++ka)Ba[ka]=8;for(ka=144;ka<256;++ka)Ba[ka]=9;for(ka=256;ka<280;++ka)Ba[ka]=7;for(ka=280;ka<288;++ka)Ba[ka]=8;var Ca=new Vs(32);for(ka=0;ka<32;++ka)Ca[ka]=5;var Da=Zs(Ba,9,0),Ua=Zs(Ba,9,1),_a=Zs(Ca,5,0),Ma=Zs(Ca,5,1),na=function(w){for(var O=w[0],_=1;_<w.length;++_)w[_]>O&&(O=w[_]);return O},ia=function(w,O,_){var N=O/8|0;return(w[N]|w[N+1]<<8)>>(7&O)&_},sa=function(w,O){var _=O/8|0;return(w[_]|w[_+1]<<8|w[_+2]<<16)>>(7&O)},aa=function(w){return(w+7)/8|0},oa=function(w,O,_){(null==O||O<0)&&(O=0),(null==_||_>w.length)&&(_=w.length);var N=new(2==w.BYTES_PER_ELEMENT?Js:4==w.BYTES_PER_ELEMENT?Ys:Vs)(_-O);return N.set(w.subarray(O,_)),N},Ga=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],ha=function(w,O,_){var N=Error(O||Ga[w]);if(N.code=w,Error.captureStackTrace&&Error.captureStackTrace(N,ha),!_)throw N;return N},ua=function(w,O,_){_<<=7&O;var N=O/8|0;w[N]|=_,w[N+1]|=_>>>8},la=function(w,O,_){_<<=7&O;var N=O/8|0;w[N]|=_,w[N+1]|=_>>>8,w[N+2]|=_>>>16},ya=function(w,O){for(var _=[],N=0;N<w.length;++N)w[N]&&_.push({s:N,f:w[N]});var F=_.length,H=_.slice();if(!F)return[Va,0];if(1==F){var j=new Vs(_[0].s+1);return j[_[0].s]=1,[j,1]}_.sort((function(w,O){return w.f-O.f})),_.push({s:-1,f:25001});var G=_[0],z=_[1],X=0,ee=1,se=2;for(_[0]={s:-1,f:G.f+z.f,l:G,r:z};ee!=F-1;)G=_[_[X].f<_[se].f?X++:se++],z=_[X!=ee&&_[X].f<_[se].f?X++:se++],_[ee++]={s:-1,f:G.f+z.f,l:G,r:z};var ae=H[0].s;for(N=1;N<F;++N)H[N].s>ae&&(ae=H[N].s);var Ae=new Js(ae+1),be=fa(_[ee-1],Ae,0);if(be>O){N=0;var ve=0,Se=be-O,Ie=1<<Se;for(H.sort((function(w,O){return Ae[O.s]-Ae[w.s]||w.f-O.f}));N<F;++N){var Be=H[N].s;if(!(Ae[Be]>O))break;ve+=Ie-(1<<be-Ae[Be]),Ae[Be]=O}for(ve>>>=Se;ve>0;){var Pe=H[N].s;Ae[Pe]<O?ve-=1<<O-Ae[Pe]++-1:++N}for(;N>=0&&ve;--N){var xe=H[N].s;Ae[xe]==O&&(--Ae[xe],++ve)}be=O}return[new Vs(Ae),be]},fa=function(w,O,_){return-1==w.s?Math.max(fa(w.l,O,_+1),fa(w.r,O,_+1)):O[w.s]=_},ga=function(w){for(var O=w.length;O&&!w[--O];);for(var _=new Js(++O),N=0,F=w[0],H=1,a=function(w){_[N++]=w},j=1;j<=O;++j)if(w[j]==F&&j!=O)++H;else{if(!F&&H>2){for(;H>138;H-=138)a(32754);H>2&&(a(H>10?H-11<<5|28690:H-3<<5|12305),H=0)}else if(H>3){for(a(F),--H;H>6;H-=6)a(8304);H>2&&(a(H-3<<5|8208),H=0)}for(;H--;)a(F);H=1,F=w[j]}return[_.subarray(0,N),O]},pa=function(w,O){for(var _=0,N=0;N<O.length;++N)_+=w[N]*O[N];return _},da=function(w,O,_){var N=_.length,F=aa(O+2);w[F]=255&N,w[F+1]=N>>>8,w[F+2]=255^w[F],w[F+3]=255^w[F+1];for(var H=0;H<N;++H)w[F+H+4]=_[H];return 8*(F+4+N)},Aa=function(w,O,_,N,F,H,j,G,z,X,ee){ua(O,ee++,_),++F[256];for(var se=ya(F,15),ae=se[0],Ae=se[1],be=ya(H,15),ve=be[0],Se=be[1],Ie=ga(ae),Be=Ie[0],Pe=Ie[1],xe=ga(ve),De=xe[0],Ue=xe[1],Oe=new Js(19),_e=0;_e<Be.length;++_e)Oe[31&Be[_e]]++;for(_e=0;_e<De.length;++_e)Oe[31&De[_e]]++;for(var Re=ya(Oe,7),Te=Re[0],Qe=Re[1],Me=19;Me>4&&!Te[ea[Me-1]];--Me);var Le,je,qe,et,tt=X+5<<3,rt=pa(F,Ba)+pa(H,Ca)+j,st=pa(F,ae)+pa(H,ve)+j+14+3*Me+pa(Oe,Te)+(2*Oe[16]+3*Oe[17]+7*Oe[18]);if(tt<=rt&&tt<=st)return da(O,ee,w.subarray(z,z+X));if(ua(O,ee,1+(st<rt)),ee+=2,st<rt){Le=Zs(ae,Ae,0),je=ae,qe=Zs(ve,Se,0),et=ve;var at=Zs(Te,Qe,0);ua(O,ee,Pe-257),ua(O,ee+5,Ue-1),ua(O,ee+10,Me-4),ee+=14;for(_e=0;_e<Me;++_e)ua(O,ee+3*_e,Te[ea[_e]]);ee+=3*Me;for(var ot=[Be,De],ct=0;ct<2;++ct){var ut=ot[ct];for(_e=0;_e<ut.length;++_e){var ht=31&ut[_e];ua(O,ee,at[ht]),ee+=Te[ht],ht>15&&(ua(O,ee,ut[_e]>>>5&127),ee+=ut[_e]>>>12)}}}else Le=Da,je=Ba,qe=_a,et=Ca;for(_e=0;_e<G;++_e)if(N[_e]>255){ht=N[_e]>>>18&31;la(O,ee,Le[ht+257]),ee+=je[ht+257],ht>7&&(ua(O,ee,N[_e]>>>23&31),ee+=Ws[ht]);var lt=31&N[_e];la(O,ee,qe[lt]),ee+=et[lt],lt>3&&(la(O,ee,N[_e]>>>5&8191),ee+=Xs[lt])}else la(O,ee,Le[N[_e]]),ee+=je[N[_e]];return la(O,ee,Le[256]),ee+je[256]},za=new Ys([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),Va=new Vs(0),ba=function(w,O,_,N,F){return function(w,O,_,N,F,H){var j=w.length,G=new Vs(N+j+5*(1+Math.ceil(j/7e3))+F),z=G.subarray(N,G.length-F),X=0;if(!O||j<8)for(var ee=0;ee<=j;ee+=65535){var se=ee+65535;se>=j&&(z[X>>3]=H),X=da(z,X+1,w.subarray(ee,se))}else{for(var ae=za[O-1],Ae=ae>>>13,be=8191&ae,ve=(1<<_)-1,Se=new Js(32768),Ie=new Js(ve+1),Be=Math.ceil(_/3),Pe=2*Be,b=function(O){return(w[O]^w[O+1]<<Be^w[O+2]<<Pe)&ve},xe=new Ys(25e3),De=new Js(288),Ue=new Js(32),Oe=0,_e=0,Re=(ee=0,0),Te=0,Qe=0;ee<j;++ee){var Me=b(ee),Le=32767&ee,je=Ie[Me];if(Se[Le]=je,Ie[Me]=Le,Te<=ee){var qe=j-ee;if((Oe>7e3||Re>24576)&&qe>423){X=Aa(w,z,0,xe,De,Ue,_e,Re,Qe,ee-Qe,X),Re=Oe=_e=0,Qe=ee;for(var et=0;et<286;++et)De[et]=0;for(et=0;et<30;++et)Ue[et]=0}var tt=2,rt=0,st=be,at=Le-je&32767;if(qe>2&&Me==b(ee-at))for(var ot=Math.min(Ae,qe)-1,ct=Math.min(32767,ee),ut=Math.min(258,qe);at<=ct&&--st&&Le!=je;){if(w[ee+tt]==w[ee+tt-at]){for(var ht=0;ht<ut&&w[ee+ht]==w[ee+ht-at];++ht);if(ht>tt){if(tt=ht,rt=at,ht>ot)break;var lt=Math.min(at,ht-2),ft=0;for(et=0;et<lt;++et){var yt=ee-at+et+32768&32767,Ut=yt-Se[yt]+32768&32767;Ut>ft&&(ft=Ut,je=yt)}}}at+=(Le=je)-(je=Se[Le])+32768&32767}if(rt){xe[Re++]=268435456|ca[tt]<<18|va[rt];var Ft=31&ca[tt],jt=31&va[rt];_e+=Ws[Ft]+Xs[jt],++De[257+Ft],++Ue[jt],Te=ee+tt,++Oe}else xe[Re++]=w[ee],++De[w[ee]]}}X=Aa(w,z,H,xe,De,Ue,_e,Re,Qe,ee-Qe,X),!H&&7&X&&(X=da(z,X+1,Va))}return oa(G,0,N+aa(X)+F)}(w,null==O.level?6:O.level,null==O.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(w.length)))):12+O.mem,_,N,!F)},Xa=function(){function e(w,O){O||"function"!=typeof w||(O=w,w={}),this.ondata=O,this.o=w||{}}return e.prototype.p=function(w,O){this.ondata(ba(w,this.o,0,0,!O),O)},e.prototype.push=function(w,O){this.ondata||ha(5),this.d&&ha(4),this.d=O,this.p(w,O||!1)},e}(),oo=function(){function e(w){this.s={},this.p=new Vs(0),this.ondata=w}return e.prototype.e=function(w){this.ondata||ha(5),this.d&&ha(4);var O=this.p.length,_=new Vs(O+w.length);_.set(this.p),_.set(w,O),this.p=_},e.prototype.c=function(w){this.d=this.s.i=w||!1;var O=this.s.b,_=function(w,O,_){var N=w.length;if(!N||_&&_.f&&!_.l)return O||new Vs(0);var F=!O||_,H=!_||_.i;_||(_={}),O||(O=new Vs(3*N));var a=function(w){var _=O.length;if(w>_){var N=new Vs(Math.max(2*_,w));N.set(O),O=N}},j=_.f||0,G=_.p||0,z=_.b||0,X=_.l,ee=_.d,se=_.m,ae=_.n,Ae=8*N;do{if(!X){j=ia(w,G,1);var be=ia(w,G+1,3);if(G+=3,!be){var ve=w[(Te=aa(G)+4)-4]|w[Te-3]<<8,Se=Te+ve;if(Se>N){H&&ha(0);break}F&&a(z+ve),O.set(w.subarray(Te,Se),z),_.b=z+=ve,_.p=G=8*Se,_.f=j;continue}if(1==be)X=Ua,ee=Ma,se=9,ae=5;else if(2==be){var Ie=ia(w,G,31)+257,Be=ia(w,G+10,15)+4,Pe=Ie+ia(w,G+5,31)+1;G+=14;for(var xe=new Vs(Pe),De=new Vs(19),Ue=0;Ue<Be;++Ue)De[ea[Ue]]=ia(w,G+3*Ue,7);G+=3*Be;var Oe=na(De),_e=(1<<Oe)-1,Re=Zs(De,Oe,1);for(Ue=0;Ue<Pe;){var Te,Qe=Re[ia(w,G,_e)];if(G+=15&Qe,(Te=Qe>>>4)<16)xe[Ue++]=Te;else{var Me=0,Le=0;for(16==Te?(Le=3+ia(w,G,3),G+=2,Me=xe[Ue-1]):17==Te?(Le=3+ia(w,G,7),G+=3):18==Te&&(Le=11+ia(w,G,127),G+=7);Le--;)xe[Ue++]=Me}}var je=xe.subarray(0,Ie),qe=xe.subarray(Ie);se=na(je),ae=na(qe),X=Zs(je,se,1),ee=Zs(qe,ae,1)}else ha(1);if(G>Ae){H&&ha(0);break}}F&&a(z+131072);for(var et=(1<<se)-1,tt=(1<<ae)-1,rt=G;;rt=G){var st=(Me=X[sa(w,G)&et])>>>4;if((G+=15&Me)>Ae){H&&ha(0);break}if(Me||ha(2),st<256)O[z++]=st;else{if(256==st){rt=G,X=null;break}var at=st-254;if(st>264){var ot=Ws[Ue=st-257];at=ia(w,G,(1<<ot)-1)+ra[Ue],G+=ot}var ct=ee[sa(w,G)&tt],ut=ct>>>4;if(ct||ha(3),G+=15&ct,qe=ma[ut],ut>3&&(ot=Xs[ut],qe+=sa(w,G)&(1<<ot)-1,G+=ot),G>Ae){H&&ha(0);break}F&&a(z+131072);for(var ht=z+at;z<ht;z+=4)O[z]=O[z-qe],O[z+1]=O[z+1-qe],O[z+2]=O[z+2-qe],O[z+3]=O[z+3-qe];z=ht}}_.l=X,_.p=rt,_.b=z,_.f=j,X&&(j=1,_.m=se,_.d=ee,_.n=ae)}while(!j);return z==O.length?O:oa(O,0,z)}(this.p,this.o,this.s);this.ondata(oa(_,O,this.s.b),this.d),this.o=oa(_,this.s.b-32768),this.s.b=this.o.length,this.p=oa(this.p,this.s.p/8|0),this.s.p&=7},e.prototype.push=function(w,O){this.e(w),this.c(O)},e}(),Co=function(){function e(w,O){var _,N;this.c=(_=1,N=0,{p:function(w){for(var O=_,F=N,H=0|w.length,j=0;j!=H;){for(var G=Math.min(j+2655,H);j<G;++j)F+=O+=w[j];O=(65535&O)+15*(O>>16),F=(65535&F)+15*(F>>16)}_=O,N=F},d:function(){return(255&(_%=65521))<<24|_>>>8<<16|(255&(N%=65521))<<8|N>>>8}}),this.v=1,Xa.call(this,w,O)}return e.prototype.push=function(w,O){Xa.prototype.push.call(this,w,O)},e.prototype.p=function(w,O){this.c.p(w);var _=ba(w,this.o,this.v&&2,O&&4,!O);this.v&&(function(w,O){var _=O.level,N=0==_?0:_<6?1:9==_?3:2;w[0]=120,w[1]=N<<6|(N?32-2*N:1)}(_,this.o),this.v=0),O&&function(w,O,_){for(;_;++O)w[O]=_,_>>>=8}(_,_.length-4,this.c.d()),this.ondata(_,O)},e}(),Ko=function(){function e(w){this.v=1,oo.call(this,w)}return e.prototype.push=function(w,O){if(oo.prototype.e.call(this,w),this.v){if(this.p.length<2&&!O)return;this.p=this.p.subarray(2),this.v=0}O&&(this.p.length<4&&ha(6,"invalid zlib data"),this.p=this.p.subarray(0,-4)),oo.prototype.c.call(this,O)},e}(),Do="undefined"!=typeof TextDecoder&&new TextDecoder;try{Do.decode(Va,{stream:!0}),1}catch(N){}class Sa{static get tag(){return ve.packet.literalData}constructor(w=new Date){this.format=ve.literal.utf8,this.date=Be.normalizeDate(w),this.text=null,this.data=null,this.filename=""}setText(w,O=ve.literal.utf8){this.format=O,this.text=w,this.data=null}getText(w=!1){return(null===this.text||Be.isStream(this.text))&&(this.text=Be.decodeUTF8(Be.nativeEOL(this.getBytes(w)))),this.text}setBytes(w,O){this.format=O,this.data=w,this.text=null}getBytes(w=!1){return null===this.data&&(this.data=Be.canonicalizeEOL(Be.encodeUTF8(this.text))),w?U(this.data):this.data}setFilename(w){this.filename=w}getFilename(){return this.filename}async read(w){await C(w,(async w=>{const O=await w.readByte(),_=await w.readByte();this.filename=Be.decodeUTF8(await w.readBytes(_)),this.date=Be.readDate(await w.readBytes(4));let N=w.remainder();y(N)&&(N=await Q(N)),this.setBytes(N,O)}))}writeHeader(){const w=Be.encodeUTF8(this.filename),O=new Uint8Array([w.length]),_=new Uint8Array([this.format]),N=Be.writeDate(this.date);return Be.concatUint8Array([_,O,w,N])}write(){const w=this.writeHeader(),O=this.getBytes();return Be.concat([w,O])}}class Ka{constructor(){this.bytes=""}read(w){return this.bytes=Be.uint8ArrayToString(w.subarray(0,8)),this.bytes.length}write(){return Be.stringToUint8Array(this.bytes)}toHex(){return Be.uint8ArrayToHex(Be.stringToUint8Array(this.bytes))}equals(w,O=!1){return O&&(w.isWildcard()||this.isWildcard())||this.bytes===w.bytes}isNull(){return""===this.bytes}isWildcard(){return/^0+$/.test(this.toHex())}static mapToHex(w){return w.toHex()}static fromID(w){const O=new Ka;return O.read(Be.hexToUint8Array(w)),O}static wildcard(){const w=new Ka;return w.read(new Uint8Array(8)),w}}const Qo=Symbol("verified"),Mo="salt@notations.openpgpjs.org",Lo=new Set([ve.signatureSubpacket.issuerKeyID,ve.signatureSubpacket.issuerFingerprint,ve.signatureSubpacket.embeddedSignature]);class Pa{static get tag(){return ve.packet.signature}constructor(){this.version=null,this.signatureType=null,this.hashAlgorithm=null,this.publicKeyAlgorithm=null,this.signatureData=null,this.unhashedSubpackets=[],this.unknownSubpackets=[],this.signedHashValue=null,this.salt=null,this.created=null,this.signatureExpirationTime=null,this.signatureNeverExpires=!0,this.exportable=null,this.trustLevel=null,this.trustAmount=null,this.regularExpression=null,this.revocable=null,this.keyExpirationTime=null,this.keyNeverExpires=null,this.preferredSymmetricAlgorithms=null,this.revocationKeyClass=null,this.revocationKeyAlgorithm=null,this.revocationKeyFingerprint=null,this.issuerKeyID=new Ka,this.rawNotations=[],this.notations={},this.preferredHashAlgorithms=null,this.preferredCompressionAlgorithms=null,this.keyServerPreferences=null,this.preferredKeyServer=null,this.isPrimaryUserID=null,this.policyURI=null,this.keyFlags=null,this.signersUserID=null,this.reasonForRevocationFlag=null,this.reasonForRevocationString=null,this.features=null,this.signatureTargetPublicKeyAlgorithm=null,this.signatureTargetHashAlgorithm=null,this.signatureTargetHash=null,this.embeddedSignature=null,this.issuerKeyVersion=null,this.issuerFingerprint=null,this.preferredAEADAlgorithms=null,this.preferredCipherSuites=null,this.revoked=null,this[Qo]=null}read(w,O=Se){let _=0;if(this.version=w[_++],5===this.version&&!O.enableParsingV5Entities)throw new er("Support for v5 entities is disabled; turn on `config.enableParsingV5Entities` if needed");if(4!==this.version&&5!==this.version&&6!==this.version)throw new er(`Version ${this.version} of the signature packet is unsupported.`);if(this.signatureType=w[_++],this.publicKeyAlgorithm=w[_++],this.hashAlgorithm=w[_++],_+=this.readSubPackets(w.subarray(_,w.length),!0),!this.created)throw Error("Missing signature creation time subpacket.");if(this.signatureData=w.subarray(0,_),_+=this.readSubPackets(w.subarray(_,w.length),!1),this.signedHashValue=w.subarray(_,_+2),_+=2,6===this.version){const O=w[_++];this.salt=w.subarray(_,_+O),_+=O}const N=w.subarray(_,w.length),{read:F,signatureParams:H}=function(w,O){let _=0;switch(w){case ve.publicKey.rsaEncryptSign:case ve.publicKey.rsaEncrypt:case ve.publicKey.rsaSign:{const w=Be.readMPI(O.subarray(_));return _+=w.length+2,{read:_,signatureParams:{s:w}}}case ve.publicKey.dsa:case ve.publicKey.ecdsa:{const w=Be.readMPI(O.subarray(_));_+=w.length+2;const N=Be.readMPI(O.subarray(_));return _+=N.length+2,{read:_,signatureParams:{r:w,s:N}}}case ve.publicKey.eddsaLegacy:{const w=Be.readMPI(O.subarray(_));_+=w.length+2;const N=Be.readMPI(O.subarray(_));return _+=N.length+2,{read:_,signatureParams:{r:w,s:N}}}case ve.publicKey.ed25519:case ve.publicKey.ed448:{const N=2*or(w),F=Be.readExactSubarray(O,_,_+N);return _+=F.length,{read:_,signatureParams:{RS:F}}}default:throw new er("Unknown signature algorithm.")}}(this.publicKeyAlgorithm,N);if(F<N.length)throw Error("Error reading MPIs");this.params=H}writeParams(){return this.params instanceof Promise?T((async()=>Bi(this.publicKeyAlgorithm,await this.params))):Bi(this.publicKeyAlgorithm,this.params)}write(){const w=[];return w.push(this.signatureData),w.push(this.writeUnhashedSubPackets()),w.push(this.signedHashValue),6===this.version&&(w.push(new Uint8Array([this.salt.length])),w.push(this.salt)),w.push(this.writeParams()),Be.concat(w)}async sign(w,O,_=new Date,N=!1,F){this.version=w.version,this.created=Be.normalizeDate(_),this.issuerKeyVersion=w.version,this.issuerFingerprint=w.getFingerprintBytes(),this.issuerKeyID=w.getKeyID();const H=[new Uint8Array([this.version,this.signatureType,this.publicKeyAlgorithm,this.hashAlgorithm])];if(6===this.version){const w=Qa(this.hashAlgorithm);if(null===this.salt)this.salt=we(w);else if(w!==this.salt.length)throw Error("Provided salt does not have the required length")}else if(F.nonDeterministicSignaturesViaNotation){if(0!==this.rawNotations.filter((({name:w})=>w===Mo)).length)throw Error("Unexpected existing salt notation");{const w=we(Qa(this.hashAlgorithm));this.rawNotations.push({name:Mo,value:w,humanReadable:!1,critical:!1})}}H.push(this.writeHashedSubPackets()),this.unhashedSubpackets=[],this.signatureData=Be.concat(H);const j=this.toHash(this.signatureType,O,N),G=await this.hash(this.signatureType,O,j,N);this.signedHashValue=x(D(G),0,2);const c=async()=>Is(this.publicKeyAlgorithm,this.hashAlgorithm,w.publicParams,w.privateParams,j,await Q(G));Be.isStream(G)?this.params=c():(this.params=await c(),this[Qo]=!0)}writeHashedSubPackets(){const w=ve.signatureSubpacket,O=[];let _;if(null===this.created)throw Error("Missing signature creation time");O.push(xa(w.signatureCreationTime,!0,Be.writeDate(this.created))),null!==this.signatureExpirationTime&&O.push(xa(w.signatureExpirationTime,!0,Be.writeNumber(this.signatureExpirationTime,4))),null!==this.exportable&&O.push(xa(w.exportableCertification,!0,new Uint8Array([this.exportable?1:0]))),null!==this.trustLevel&&(_=new Uint8Array([this.trustLevel,this.trustAmount]),O.push(xa(w.trustSignature,!0,_))),null!==this.regularExpression&&O.push(xa(w.regularExpression,!0,this.regularExpression)),null!==this.revocable&&O.push(xa(w.revocable,!0,new Uint8Array([this.revocable?1:0]))),null!==this.keyExpirationTime&&O.push(xa(w.keyExpirationTime,!0,Be.writeNumber(this.keyExpirationTime,4))),null!==this.preferredSymmetricAlgorithms&&(_=Be.stringToUint8Array(Be.uint8ArrayToString(this.preferredSymmetricAlgorithms)),O.push(xa(w.preferredSymmetricAlgorithms,!1,_))),null!==this.revocationKeyClass&&(_=new Uint8Array([this.revocationKeyClass,this.revocationKeyAlgorithm]),_=Be.concat([_,this.revocationKeyFingerprint]),O.push(xa(w.revocationKey,!1,_))),!this.issuerKeyID.isNull()&&this.issuerKeyVersion<5&&O.push(xa(w.issuerKeyID,!0,this.issuerKeyID.write())),this.rawNotations.forEach((({name:N,value:F,humanReadable:H,critical:j})=>{_=[new Uint8Array([H?128:0,0,0,0])];const G=Be.encodeUTF8(N);_.push(Be.writeNumber(G.length,2)),_.push(Be.writeNumber(F.length,2)),_.push(G),_.push(F),_=Be.concat(_),O.push(xa(w.notationData,j,_))})),null!==this.preferredHashAlgorithms&&(_=Be.stringToUint8Array(Be.uint8ArrayToString(this.preferredHashAlgorithms)),O.push(xa(w.preferredHashAlgorithms,!1,_))),null!==this.preferredCompressionAlgorithms&&(_=Be.stringToUint8Array(Be.uint8ArrayToString(this.preferredCompressionAlgorithms)),O.push(xa(w.preferredCompressionAlgorithms,!1,_))),null!==this.keyServerPreferences&&(_=Be.stringToUint8Array(Be.uint8ArrayToString(this.keyServerPreferences)),O.push(xa(w.keyServerPreferences,!1,_))),null!==this.preferredKeyServer&&O.push(xa(w.preferredKeyServer,!1,Be.encodeUTF8(this.preferredKeyServer))),null!==this.isPrimaryUserID&&O.push(xa(w.primaryUserID,!1,new Uint8Array([this.isPrimaryUserID?1:0]))),null!==this.policyURI&&O.push(xa(w.policyURI,!1,Be.encodeUTF8(this.policyURI))),null!==this.keyFlags&&(_=Be.stringToUint8Array(Be.uint8ArrayToString(this.keyFlags)),O.push(xa(w.keyFlags,!0,_))),null!==this.signersUserID&&O.push(xa(w.signersUserID,!1,Be.encodeUTF8(this.signersUserID))),null!==this.reasonForRevocationFlag&&(_=Be.stringToUint8Array(String.fromCharCode(this.reasonForRevocationFlag)+this.reasonForRevocationString),O.push(xa(w.reasonForRevocation,!0,_))),null!==this.features&&(_=Be.stringToUint8Array(Be.uint8ArrayToString(this.features)),O.push(xa(w.features,!1,_))),null!==this.signatureTargetPublicKeyAlgorithm&&(_=[new Uint8Array([this.signatureTargetPublicKeyAlgorithm,this.signatureTargetHashAlgorithm])],_.push(Be.stringToUint8Array(this.signatureTargetHash)),_=Be.concat(_),O.push(xa(w.signatureTarget,!0,_))),null!==this.embeddedSignature&&O.push(xa(w.embeddedSignature,!0,this.embeddedSignature.write())),null!==this.issuerFingerprint&&(_=[new Uint8Array([this.issuerKeyVersion]),this.issuerFingerprint],_=Be.concat(_),O.push(xa(w.issuerFingerprint,this.version>=5,_))),null!==this.preferredAEADAlgorithms&&(_=Be.stringToUint8Array(Be.uint8ArrayToString(this.preferredAEADAlgorithms)),O.push(xa(w.preferredAEADAlgorithms,!1,_))),null!==this.preferredCipherSuites&&(_=new Uint8Array([].concat(...this.preferredCipherSuites)),O.push(xa(w.preferredCipherSuites,!1,_)));const N=Be.concat(O),F=Be.writeNumber(N.length,6===this.version?4:2);return Be.concat([F,N])}writeUnhashedSubPackets(){const w=this.unhashedSubpackets.map((({type:w,critical:O,body:_})=>xa(w,O,_))),O=Be.concat(w),_=Be.writeNumber(O.length,6===this.version?4:2);return Be.concat([_,O])}readSubPacket(w,O=!0){let _=0;const N=!!(128&w[_]),F=127&w[_];if(_++,O||(this.unhashedSubpackets.push({type:F,critical:N,body:w.subarray(_,w.length)}),Lo.has(F)))switch(F){case ve.signatureSubpacket.signatureCreationTime:this.created=Be.readDate(w.subarray(_,w.length));break;case ve.signatureSubpacket.signatureExpirationTime:{const O=Be.readNumber(w.subarray(_,w.length));this.signatureNeverExpires=0===O,this.signatureExpirationTime=O;break}case ve.signatureSubpacket.exportableCertification:this.exportable=1===w[_++];break;case ve.signatureSubpacket.trustSignature:this.trustLevel=w[_++],this.trustAmount=w[_++];break;case ve.signatureSubpacket.regularExpression:this.regularExpression=w[_];break;case ve.signatureSubpacket.revocable:this.revocable=1===w[_++];break;case ve.signatureSubpacket.keyExpirationTime:{const O=Be.readNumber(w.subarray(_,w.length));this.keyExpirationTime=O,this.keyNeverExpires=0===O;break}case ve.signatureSubpacket.preferredSymmetricAlgorithms:this.preferredSymmetricAlgorithms=[...w.subarray(_,w.length)];break;case ve.signatureSubpacket.revocationKey:this.revocationKeyClass=w[_++],this.revocationKeyAlgorithm=w[_++],this.revocationKeyFingerprint=w.subarray(_,_+20);break;case ve.signatureSubpacket.issuerKeyID:if(4===this.version)this.issuerKeyID.read(w.subarray(_,w.length));else if(O)throw Error("Unexpected Issuer Key ID subpacket");break;case ve.signatureSubpacket.notationData:{const O=!!(128&w[_]);_+=4;const F=Be.readNumber(w.subarray(_,_+2));_+=2;const H=Be.readNumber(w.subarray(_,_+2));_+=2;const j=Be.decodeUTF8(w.subarray(_,_+F)),G=w.subarray(_+F,_+F+H);this.rawNotations.push({name:j,humanReadable:O,value:G,critical:N}),O&&(this.notations[j]=Be.decodeUTF8(G));break}case ve.signatureSubpacket.preferredHashAlgorithms:this.preferredHashAlgorithms=[...w.subarray(_,w.length)];break;case ve.signatureSubpacket.preferredCompressionAlgorithms:this.preferredCompressionAlgorithms=[...w.subarray(_,w.length)];break;case ve.signatureSubpacket.keyServerPreferences:this.keyServerPreferences=[...w.subarray(_,w.length)];break;case ve.signatureSubpacket.preferredKeyServer:this.preferredKeyServer=Be.decodeUTF8(w.subarray(_,w.length));break;case ve.signatureSubpacket.primaryUserID:this.isPrimaryUserID=0!==w[_++];break;case ve.signatureSubpacket.policyURI:this.policyURI=Be.decodeUTF8(w.subarray(_,w.length));break;case ve.signatureSubpacket.keyFlags:this.keyFlags=[...w.subarray(_,w.length)];break;case ve.signatureSubpacket.signersUserID:this.signersUserID=Be.decodeUTF8(w.subarray(_,w.length));break;case ve.signatureSubpacket.reasonForRevocation:this.reasonForRevocationFlag=w[_++],this.reasonForRevocationString=Be.decodeUTF8(w.subarray(_,w.length));break;case ve.signatureSubpacket.features:this.features=[...w.subarray(_,w.length)];break;case ve.signatureSubpacket.signatureTarget:{this.signatureTargetPublicKeyAlgorithm=w[_++],this.signatureTargetHashAlgorithm=w[_++];const O=Fe(this.signatureTargetHashAlgorithm);this.signatureTargetHash=Be.uint8ArrayToString(w.subarray(_,_+O));break}case ve.signatureSubpacket.embeddedSignature:this.embeddedSignature=new Pa,this.embeddedSignature.read(w.subarray(_,w.length));break;case ve.signatureSubpacket.issuerFingerprint:this.issuerKeyVersion=w[_++],this.issuerFingerprint=w.subarray(_,w.length),this.issuerKeyVersion>=5?this.issuerKeyID.read(this.issuerFingerprint):this.issuerKeyID.read(this.issuerFingerprint.subarray(-8));break;case ve.signatureSubpacket.preferredAEADAlgorithms:this.preferredAEADAlgorithms=[...w.subarray(_,w.length)];break;case ve.signatureSubpacket.preferredCipherSuites:this.preferredCipherSuites=[];for(let O=_;O<w.length;O+=2)this.preferredCipherSuites.push([w[O],w[O+1]]);break;default:this.unknownSubpackets.push({type:F,critical:N,body:w.subarray(_,w.length)})}}readSubPackets(w,O=!0,_){const N=6===this.version?4:2,F=Be.readNumber(w.subarray(0,N));let H=N;for(;H<2+F;){const N=Vt(w.subarray(H,w.length));H+=N.offset,this.readSubPacket(w.subarray(H,H+N.len),O,_),H+=N.len}return H}toSign(w,O){const _=ve.signature;switch(w){case _.binary:return null!==O.text?Be.encodeUTF8(O.getText(!0)):O.getBytes(!0);case _.text:{const w=O.getBytes(!0);return Be.canonicalizeEOL(w)}case _.standalone:return new Uint8Array(0);case _.certGeneric:case _.certPersona:case _.certCasual:case _.certPositive:case _.certRevocation:{let w,N;if(O.userID)N=180,w=O.userID;else{if(!O.userAttribute)throw Error("Either a userID or userAttribute packet needs to be supplied for certification.");N=209,w=O.userAttribute}const F=w.write();return Be.concat([this.toSign(_.key,O),new Uint8Array([N]),Be.writeNumber(F.length,4),F])}case _.subkeyBinding:case _.subkeyRevocation:case _.keyBinding:return Be.concat([this.toSign(_.key,O),this.toSign(_.key,{key:O.bind})]);case _.key:if(void 0===O.key)throw Error("Key packet is required for this signature.");return O.key.writeForHash(this.version);case _.keyRevocation:return this.toSign(_.key,O);case _.timestamp:return new Uint8Array(0);case _.thirdParty:throw Error("Not implemented");default:throw Error("Unknown signature type.")}}calculateTrailer(w,O){let _=0;return S(D(this.signatureData),(w=>{_+=w.length}),(()=>{const N=[];return 5!==this.version||this.signatureType!==ve.signature.binary&&this.signatureType!==ve.signature.text||(O?N.push(new Uint8Array(6)):N.push(w.writeHeader())),N.push(new Uint8Array([this.version,255])),5===this.version&&N.push(new Uint8Array(4)),N.push(Be.writeNumber(_,4)),Be.concat(N)}))}toHash(w,O,_=!1){const N=this.toSign(w,O);return Be.concat([this.salt||new Uint8Array,N,this.signatureData,this.calculateTrailer(O,_)])}async hash(w,O,_,N=!1){if(6===this.version&&this.salt.length!==Qa(this.hashAlgorithm))throw Error("Signature salt does not have the expected length");return _||(_=this.toHash(w,O,N)),Ne(this.hashAlgorithm,_)}async verify(w,O,_,N=new Date,F=!1,H=Se){if(!this.issuerKeyID.equals(w.getKeyID()))throw Error("Signature was not issued by the given public key");if(this.publicKeyAlgorithm!==w.algorithm)throw Error("Public key algorithm used to sign signature does not match issuer key algorithm.");const j=O===ve.signature.binary||O===ve.signature.text;if(!(this[Qo]&&!j)){let N,H;if(this.hashed?H=await this.hashed:(N=this.toHash(O,_,F),H=await this.hash(O,_,N)),H=await Q(H),this.signedHashValue[0]!==H[0]||this.signedHashValue[1]!==H[1])throw Error("Signed digest did not match");if(this.params=await this.params,this[Qo]=await vs(this.publicKeyAlgorithm,this.hashAlgorithm,this.params,w.publicParams,N,H),!this[Qo])throw Error("Signature verification failed")}const G=Be.normalizeDate(N);if(G&&this.created>G)throw Error("Signature creation time is in the future");if(G&&G>=this.getExpirationTime())throw Error("Signature is expired");if(H.rejectHashAlgorithms.has(this.hashAlgorithm))throw Error("Insecure hash algorithm: "+ve.read(ve.hash,this.hashAlgorithm).toUpperCase());if(H.rejectMessageHashAlgorithms.has(this.hashAlgorithm)&&[ve.signature.binary,ve.signature.text].includes(this.signatureType))throw Error("Insecure message hash algorithm: "+ve.read(ve.hash,this.hashAlgorithm).toUpperCase());if(this.unknownSubpackets.forEach((({type:w,critical:O})=>{if(O)throw Error("Unknown critical signature subpacket type "+w)})),this.rawNotations.forEach((({name:w,critical:O})=>{if(O&&H.knownNotations.indexOf(w)<0)throw Error("Unknown critical notation: "+w)})),null!==this.revocationKeyClass)throw Error("This key is intended to be revoked with an authorized key, which OpenPGP.js does not support.")}isExpired(w=new Date){const O=Be.normalizeDate(w);return null!==O&&!(this.created<=O&&O<this.getExpirationTime())}getExpirationTime(){return this.signatureNeverExpires?1/0:new Date(this.created.getTime()+1e3*this.signatureExpirationTime)}}function xa(w,O,_){const N=[];return N.push(Jt(_.length+1)),N.push(new Uint8Array([(O?128:0)|w])),N.push(_),Be.concat(N)}function Qa(w){switch(w){case ve.hash.sha256:return 16;case ve.hash.sha384:return 24;case ve.hash.sha512:return 32;case ve.hash.sha224:case ve.hash.sha3_256:return 16;case ve.hash.sha3_512:return 32;default:throw Error("Unsupported hash function")}}class Ra{static get tag(){return ve.packet.onePassSignature}static fromSignaturePacket(w,O){const _=new Ra;return _.version=6===w.version?6:3,_.signatureType=w.signatureType,_.hashAlgorithm=w.hashAlgorithm,_.publicKeyAlgorithm=w.publicKeyAlgorithm,_.issuerKeyID=w.issuerKeyID,_.salt=w.salt,_.issuerFingerprint=w.issuerFingerprint,_.flags=O?1:0,_}constructor(){this.version=null,this.signatureType=null,this.hashAlgorithm=null,this.publicKeyAlgorithm=null,this.salt=null,this.issuerKeyID=null,this.issuerFingerprint=null,this.flags=null}read(w){let O=0;if(this.version=w[O++],3!==this.version&&6!==this.version)throw new er(`Version ${this.version} of the one-pass signature packet is unsupported.`);if(this.signatureType=w[O++],this.hashAlgorithm=w[O++],this.publicKeyAlgorithm=w[O++],6===this.version){const _=w[O++];this.salt=w.subarray(O,O+_),O+=_,this.issuerFingerprint=w.subarray(O,O+32),O+=32,this.issuerKeyID=new Ka,this.issuerKeyID.read(this.issuerFingerprint)}else this.issuerKeyID=new Ka,this.issuerKeyID.read(w.subarray(O,O+8)),O+=8;return this.flags=w[O++],this}write(){const w=[new Uint8Array([this.version,this.signatureType,this.hashAlgorithm,this.publicKeyAlgorithm])];return 6===this.version?w.push(new Uint8Array([this.salt.length]),this.salt,this.issuerFingerprint):w.push(this.issuerKeyID.write()),w.push(new Uint8Array([this.flags])),Be.concatUint8Array(w)}calculateTrailer(...w){return T((async()=>Pa.prototype.calculateTrailer.apply(await this.correspondingSig,w)))}async verify(){const w=await this.correspondingSig;if(!w||w.constructor.tag!==ve.packet.signature)throw Error("Corresponding signature packet missing");if(w.signatureType!==this.signatureType||w.hashAlgorithm!==this.hashAlgorithm||w.publicKeyAlgorithm!==this.publicKeyAlgorithm||!w.issuerKeyID.equals(this.issuerKeyID)||3===this.version&&6===w.version||6===this.version&&6!==w.version||6===this.version&&!Be.equalsUint8Array(w.issuerFingerprint,this.issuerFingerprint)||6===this.version&&!Be.equalsUint8Array(w.salt,this.salt))throw Error("Corresponding signature packet does not match one-pass signature packet");return w.hashed=this.hashed,w.verify.apply(w,arguments)}}function Ta(w,O){if(!O[w]){let _;try{_=ve.read(ve.packet,w)}catch(O){throw new tr("Unknown packet type with tag: "+w)}throw Error("Packet not allowed in this context: "+_)}return new O[w]}Ra.prototype.hash=Pa.prototype.hash,Ra.prototype.toHash=Pa.prototype.toHash,Ra.prototype.toSign=Pa.prototype.toSign;class La extends Array{static async fromBinary(w,O,_=Se){const N=new La;return await N.read(w,O,_),N}async read(w,O,_=Se){_.additionalAllowedPackets.length&&(O={...O,...Be.constructAllowedPackets(_.additionalAllowedPackets)}),this.stream=K(w,(async(w,N)=>{const F=M(N);try{for(;;){await F.ready;if(await Xt(w,(async w=>{try{if(w.tag===ve.packet.marker||w.tag===ve.packet.trust||w.tag===ve.packet.padding)return;const N=Ta(w.tag,O);N.packets=new La,N.fromStream=Be.isStream(w.packet),await N.read(w.packet,_),await F.write(N)}catch(O){if(O instanceof tr){if(!(w.tag<=39))return;await F.abort(O)}const N=!_.ignoreUnsupportedPackets&&O instanceof er,H=!(_.ignoreMalformedPackets||O instanceof er);if(N||H||$t(w.tag))await F.abort(O);else{const O=new rr(w.tag,w.packet);await F.write(O)}Be.printDebugError(O)}})))return await F.ready,void await F.close()}}catch(w){await F.abort(w)}}));const N=L(this.stream);for(;;){const{done:w,value:O}=await N.read();if(w?this.stream=null:this.push(O),w||$t(O.constructor.tag))break}N.releaseLock()}write(){const w=[];for(let O=0;O<this.length;O++){const _=this[O]instanceof rr?this[O].tag:this[O].constructor.tag,N=this[O].write();if(Be.isStream(N)&&$t(this[O].constructor.tag)){let O=[],F=0;const H=512;w.push(Zt(_)),w.push(S(N,(w=>{if(O.push(w),F+=w.length,F>=H){const w=Math.min(Math.log(F)/Math.LN2|0,30),_=2**w,N=Be.concat([Yt(w)].concat(O));return O=[N.subarray(1+_)],F=O[0].length,N.subarray(0,1+_)}}),(()=>Be.concat([Jt(F)].concat(O)))))}else{if(Be.isStream(N)){let O=0;w.push(S(D(N),(w=>{O+=w.length}),(()=>Wt(_,O))))}else w.push(Wt(_,N.length));w.push(N)}}return Be.concat(w)}filterByTag(...w){const O=new La,r=w=>O=>w===O;for(let _=0;_<this.length;_++)w.some(r(this[_].constructor.tag))&&O.push(this[_]);return O}findPacket(w){return this.find((O=>O.constructor.tag===w))}indexOfTag(...w){const O=[],_=this,n=w=>O=>w===O;for(let N=0;N<this.length;N++)w.some(n(_[N].constructor.tag))&&O.push(N);return O}}const No=Be.constructAllowedPackets([Sa,Ra,Pa]);class Na{static get tag(){return ve.packet.compressedData}constructor(w=Se){this.packets=null,this.algorithm=w.preferredCompressionAlgorithm,this.compressed=null}async read(w,O=Se){await C(w,(async w=>{this.algorithm=await w.readByte(),this.compressed=w.remainder(),await this.decompress(O)}))}write(){return null===this.compressed&&this.compress(),Be.concat([new Uint8Array([this.algorithm]),this.compressed])}async decompress(w=Se){const O=ve.read(ve.compression,this.algorithm),_=Vo[O];if(!_)throw Error(O+" decompression not supported");this.packets=await La.fromBinary(await _(this.compressed),No,w)}compress(){const w=ve.read(ve.compression,this.algorithm),O=zo[w];if(!O)throw Error(w+" compression not supported");this.compressed=O(this.packets.write())}}function Fa(w,O){return _=>{if(!Be.isStream(_)||y(_))return T((()=>Q(_).then((w=>new Promise(((_,N)=>{const F=new O;F.ondata=w=>{_(w)};try{F.push(w,!0)}catch(w){N(w)}}))))));if(w)try{const O=w();return _.pipeThrough(O)}catch(w){if("TypeError"!==w.name)throw w}const N=_.getReader(),F=new O;return new ReadableStream({async start(w){for(F.ondata=async(O,_)=>{w.enqueue(O),_&&w.close()};;){const{done:w,value:O}=await N.read();if(w)return void F.push(new Uint8Array,!0);O.length&&F.push(O)}}})}}function Oa(){return async function(w){const{decode:O}=await Promise.resolve().then((function(){return $f}));return T((async()=>O(await Q(w))))}}const Ha=w=>({compressor:"undefined"!=typeof CompressionStream&&(()=>new CompressionStream(w)),decompressor:"undefined"!=typeof DecompressionStream&&(()=>new DecompressionStream(w))}),zo={zip:Fa(Ha("deflate-raw").compressor,Xa),zlib:Fa(Ha("deflate").compressor,Co)},Vo={uncompressed:w=>w,zip:Fa(Ha("deflate-raw").decompressor,oo),zlib:Fa(Ha("deflate").decompressor,Ko),bzip2:Oa()},nc=Be.constructAllowedPackets([Sa,Na,Ra,Pa]);class ja{static get tag(){return ve.packet.symEncryptedIntegrityProtectedData}static fromObject({version:w,aeadAlgorithm:O}){if(1!==w&&2!==w)throw Error("Unsupported SEIPD version");const _=new ja;return _.version=w,2===w&&(_.aeadAlgorithm=O),_}constructor(){this.version=null,this.cipherAlgorithm=null,this.aeadAlgorithm=null,this.chunkSizeByte=null,this.salt=null,this.encrypted=null,this.packets=null}async read(w){await C(w,(async w=>{if(this.version=await w.readByte(),1!==this.version&&2!==this.version)throw new er(`Version ${this.version} of the SEIP packet is unsupported.`);2===this.version&&(this.cipherAlgorithm=await w.readByte(),this.aeadAlgorithm=await w.readByte(),this.chunkSizeByte=await w.readByte(),this.salt=await w.readBytes(32)),this.encrypted=w.remainder()}))}write(){return 2===this.version?Be.concat([new Uint8Array([this.version,this.cipherAlgorithm,this.aeadAlgorithm,this.chunkSizeByte]),this.salt,this.encrypted]):Be.concat([new Uint8Array([this.version]),this.encrypted])}async encrypt(w,O,_=Se){const{blockSize:N,keySize:F}=wn(w);if(O.length!==F)throw Error("Unexpected session key size");let H=this.packets.write();if(y(H)&&(H=await Q(H)),2===this.version)this.cipherAlgorithm=w,this.salt=we(32),this.chunkSizeByte=_.aeadChunkSizeByte,this.encrypted=await qa(this,"encrypt",O,H);else{const _=await Ti(w),F=new Uint8Array([211,20]),j=Be.concat([_,H,F]),G=await Ne(ve.hash.sha1,U(j)),z=Be.concat([j,G]);this.encrypted=await Li(w,O,z,new Uint8Array(N))}return!0}async decrypt(w,O,_=Se){if(O.length!==wn(w).keySize)throw Error("Unexpected session key size");let N,F=D(this.encrypted);if(y(F)&&(F=await Q(F)),2===this.version){if(this.cipherAlgorithm!==w)throw Error("Unexpected session key algorithm");N=await qa(this,"decrypt",O,F)}else{const{blockSize:H}=wn(w),j=await Mi(w,O,F,new Uint8Array(H)),G=x(U(j),-20),z=x(j,0,-20),X=Promise.all([Q(await Ne(ve.hash.sha1,U(z))),Q(G)]).then((([w,O])=>{if(!Be.equalsUint8Array(w,O))throw Error("Modification detected.");return new Uint8Array})),ee=x(z,H+2);N=x(ee,0,-2),N=E([N,T((()=>X))]),Be.isStream(F)&&_.allowUnauthenticatedStream||(N=await Q(N))}return this.packets=await La.fromBinary(N,nc,_),!0}}async function qa(w,O,_,N){const F=w instanceof ja&&2===w.version,H=!F&&w.constructor.tag===ve.packet.aeadEncryptedData;if(!F&&!H)throw Error("Unexpected packet type");const j=Es(w.aeadAlgorithm,H),G="decrypt"===O?j.tagLength:0,z="encrypt"===O?j.tagLength:0,X=2**(w.chunkSizeByte+6)+G,ee=H?8:0,se=new ArrayBuffer(13+ee),ae=new Uint8Array(se,0,5+ee),Ae=new Uint8Array(se),be=new DataView(se),Se=new Uint8Array(se,5,8);ae.set([192|w.constructor.tag,w.version,w.cipherAlgorithm,w.aeadAlgorithm,w.chunkSizeByte],0);let Ie,Pe,xe=0,De=Promise.resolve(),Ue=0,Oe=0;if(F){const{keySize:O}=wn(w.cipherAlgorithm),{ivLength:N}=j,F=new Uint8Array(se,0,5),H=await vn(ve.hash.sha256,_,w.salt,F,O+N);_=H.subarray(0,O),Ie=H.subarray(O),Ie.fill(0,Ie.length-8),Pe=new DataView(Ie.buffer,Ie.byteOffset,Ie.byteLength)}else Ie=w.iv;const _e=await j(w.cipherAlgorithm,_);return K(N,(async(_,N)=>{if("array"!==Be.isStream(_)){const O=new TransformStream({},{highWaterMark:Be.getHardwareConcurrency()*2**(w.chunkSizeByte+6),size:w=>w.length});v(O.readable,N),N=O.writable}const H=L(_),j=M(N);try{for(;;){let w=await H.readBytes(X+G)||new Uint8Array;const _=w.subarray(w.length-G);let N,se,ve;if(w=w.subarray(0,w.length-G),F)ve=Ie;else{ve=Ie.slice();for(let w=0;w<8;w++)ve[Ie.length-8+w]^=Se[w]}if(!xe||w.length?(H.unshift(_),N=_e[O](w,ve,ae),N.catch((()=>{})),Oe+=w.length-G+z):(be.setInt32(5+ee+4,Ue),N=_e[O](_,ve,Ae),N.catch((()=>{})),Oe+=z,se=!0),Ue+=w.length-G,De=De.then((()=>N)).then((async w=>{await j.ready,await j.write(w),Oe-=w.length})).catch((w=>j.abort(w))),(se||Oe>j.desiredSize)&&await De,se){await j.close();break}F?Pe.setInt32(Ie.length-4,++xe):be.setInt32(9,++xe)}}catch(w){await j.ready.catch((()=>{})),await j.abort(w)}}))}const oc=Be.constructAllowedPackets([Sa,Na,Ra,Pa]);class Ja{static get tag(){return ve.packet.aeadEncryptedData}constructor(){this.version=1,this.cipherAlgorithm=null,this.aeadAlgorithm=ve.aead.eax,this.chunkSizeByte=null,this.iv=null,this.encrypted=null,this.packets=null}async read(w){await C(w,(async w=>{const O=await w.readByte();if(1!==O)throw new er(`Version ${O} of the AEAD-encrypted data packet is not supported.`);this.cipherAlgorithm=await w.readByte(),this.aeadAlgorithm=await w.readByte(),this.chunkSizeByte=await w.readByte();const _=Es(this.aeadAlgorithm,!0);this.iv=await w.readBytes(_.ivLength),this.encrypted=w.remainder()}))}write(){return Be.concat([new Uint8Array([this.version,this.cipherAlgorithm,this.aeadAlgorithm,this.chunkSizeByte]),this.iv,this.encrypted])}async decrypt(w,O,_=Se){this.packets=await La.fromBinary(await qa(this,"decrypt",O,D(this.encrypted)),oc,_)}async encrypt(w,O,_=Se){this.cipherAlgorithm=w;const{ivLength:N}=Es(this.aeadAlgorithm,!0);this.iv=we(N),this.chunkSizeByte=_.aeadChunkSizeByte;const F=this.packets.write();this.encrypted=await qa(this,"encrypt",O,F)}}class Ya{static get tag(){return ve.packet.publicKeyEncryptedSessionKey}constructor(){this.version=null,this.publicKeyID=new Ka,this.publicKeyVersion=null,this.publicKeyFingerprint=null,this.publicKeyAlgorithm=null,this.sessionKey=null,this.sessionKeyAlgorithm=null,this.encrypted={}}static fromObject({version:w,encryptionKeyPacket:O,anonymousRecipient:_,sessionKey:N,sessionKeyAlgorithm:F}){const H=new Ya;if(3!==w&&6!==w)throw Error("Unsupported PKESK version");return H.version=w,6===w&&(H.publicKeyVersion=_?null:O.version,H.publicKeyFingerprint=_?null:O.getFingerprintBytes()),H.publicKeyID=_?Ka.wildcard():O.getKeyID(),H.publicKeyAlgorithm=O.algorithm,H.sessionKey=N,H.sessionKeyAlgorithm=F,H}read(w){let O=0;if(this.version=w[O++],3!==this.version&&6!==this.version)throw new er(`Version ${this.version} of the PKESK packet is unsupported.`);if(6===this.version){const _=w[O++];if(_){this.publicKeyVersion=w[O++];const N=_-1;this.publicKeyFingerprint=w.subarray(O,O+N),O+=N,this.publicKeyVersion>=5?this.publicKeyID.read(this.publicKeyFingerprint):this.publicKeyID.read(this.publicKeyFingerprint.subarray(-8))}else this.publicKeyID=Ka.wildcard()}else O+=this.publicKeyID.read(w.subarray(O,O+8));if(this.publicKeyAlgorithm=w[O++],this.encrypted=function(w,O){let _=0;switch(w){case ve.publicKey.rsaEncrypt:case ve.publicKey.rsaEncryptSign:return{c:Be.readMPI(O.subarray(_))};case ve.publicKey.elgamal:{const w=Be.readMPI(O.subarray(_));return _+=w.length+2,{c1:w,c2:Be.readMPI(O.subarray(_))}}case ve.publicKey.ecdh:{const w=Be.readMPI(O.subarray(_));_+=w.length+2;const N=new mi;return N.read(O.subarray(_)),{V:w,C:N}}case ve.publicKey.x25519:case ve.publicKey.x448:{const N=Ui(w),F=Be.readExactSubarray(O,_,_+N);_+=F.length;const H=new ki;return H.read(O.subarray(_)),{ephemeralPublicKey:F,C:H}}default:throw new er("Unknown public key encryption algorithm.")}}(this.publicKeyAlgorithm,w.subarray(O)),this.publicKeyAlgorithm===ve.publicKey.x25519||this.publicKeyAlgorithm===ve.publicKey.x448)if(3===this.version)this.sessionKeyAlgorithm=ve.write(ve.symmetric,this.encrypted.C.algorithm);else if(null!==this.encrypted.C.algorithm)throw Error("Unexpected cleartext symmetric algorithm")}write(){const w=[new Uint8Array([this.version])];return 6===this.version?null!==this.publicKeyFingerprint?(w.push(new Uint8Array([this.publicKeyFingerprint.length+1,this.publicKeyVersion])),w.push(this.publicKeyFingerprint)):w.push(new Uint8Array([0])):w.push(this.publicKeyID.write()),w.push(new Uint8Array([this.publicKeyAlgorithm]),Bi(this.publicKeyAlgorithm,this.encrypted)),Be.concatUint8Array(w)}async encrypt(w){const O=ve.write(ve.publicKey,this.publicKeyAlgorithm),_=3===this.version?this.sessionKeyAlgorithm:null,N=5===w.version?w.getFingerprintBytes().subarray(0,20):w.getFingerprintBytes(),F=Za(this.version,O,_,this.sessionKey);this.encrypted=await Ei(O,_,w.publicParams,F,N)}async decrypt(w,O){if(this.publicKeyAlgorithm!==w.algorithm)throw Error("Decryption error");const _=O?Za(this.version,this.publicKeyAlgorithm,O.sessionKeyAlgorithm,O.sessionKey):null,N=5===w.version?w.getFingerprintBytes().subarray(0,20):w.getFingerprintBytes(),F=await vi(this.publicKeyAlgorithm,w.publicParams,w.privateParams,this.encrypted,N,_),{sessionKey:H,sessionKeyAlgorithm:j}=function(w,O,_,N){switch(O){case ve.publicKey.rsaEncrypt:case ve.publicKey.rsaEncryptSign:case ve.publicKey.elgamal:case ve.publicKey.ecdh:{const O=_.subarray(0,_.length-2),F=_.subarray(_.length-2),H=Be.writeChecksum(O.subarray(O.length%8)),j=H[0]===F[0]&H[1]===F[1],G=6===w?{sessionKeyAlgorithm:null,sessionKey:O}:{sessionKeyAlgorithm:O[0],sessionKey:O.subarray(1)};if(N){const O=j&G.sessionKeyAlgorithm===N.sessionKeyAlgorithm&G.sessionKey.length===N.sessionKey.length;return{sessionKey:Be.selectUint8Array(O,G.sessionKey,N.sessionKey),sessionKeyAlgorithm:6===w?null:Be.selectUint8(O,G.sessionKeyAlgorithm,N.sessionKeyAlgorithm)}}if(j&&(6===w||ve.read(ve.symmetric,G.sessionKeyAlgorithm)))return G;throw Error("Decryption error")}case ve.publicKey.x25519:case ve.publicKey.x448:return{sessionKeyAlgorithm:null,sessionKey:_};default:throw Error("Unsupported public key algorithm")}}(this.version,this.publicKeyAlgorithm,F,O);if(3===this.version){const w=this.publicKeyAlgorithm!==ve.publicKey.x25519&&this.publicKeyAlgorithm!==ve.publicKey.x448;if(this.sessionKeyAlgorithm=w?j:this.sessionKeyAlgorithm,H.length!==wn(this.sessionKeyAlgorithm).keySize)throw Error("Unexpected session key size")}this.sessionKey=H}}function Za(w,O,_,N){switch(O){case ve.publicKey.rsaEncrypt:case ve.publicKey.rsaEncryptSign:case ve.publicKey.elgamal:case ve.publicKey.ecdh:return Be.concatUint8Array([new Uint8Array(6===w?[]:[_]),N,Be.writeChecksum(N.subarray(N.length%8))]);case ve.publicKey.x25519:case ve.publicKey.x448:return N;default:throw Error("Unsupported public key algorithm")}}class Wa{static get tag(){return ve.packet.symEncryptedSessionKey}constructor(w=Se){this.version=w.aeadProtect?6:4,this.sessionKey=null,this.sessionKeyEncryptionAlgorithm=null,this.sessionKeyAlgorithm=null,this.aeadAlgorithm=ve.write(ve.aead,w.preferredAEADAlgorithm),this.encrypted=null,this.s2k=null,this.iv=null}read(w){let O=0;if(this.version=w[O++],4!==this.version&&5!==this.version&&6!==this.version)throw new er(`Version ${this.version} of the SKESK packet is unsupported.`);6===this.version&&O++;const _=w[O++];this.version>=5&&(this.aeadAlgorithm=w[O++],6===this.version&&O++);const N=w[O++];if(this.s2k=Ps(N),O+=this.s2k.read(w.subarray(O,w.length)),this.version>=5){const _=Es(this.aeadAlgorithm,!0);this.iv=w.subarray(O,O+=_.ivLength)}this.version>=5||O<w.length?(this.encrypted=w.subarray(O,w.length),this.sessionKeyEncryptionAlgorithm=_):this.sessionKeyAlgorithm=_}write(){const w=null===this.encrypted?this.sessionKeyAlgorithm:this.sessionKeyEncryptionAlgorithm;let O;const _=this.s2k.write();if(6===this.version){const N=_.length,F=3+N+this.iv.length;O=Be.concatUint8Array([new Uint8Array([this.version,F,w,this.aeadAlgorithm,N]),_,this.iv,this.encrypted])}else 5===this.version?O=Be.concatUint8Array([new Uint8Array([this.version,w,this.aeadAlgorithm]),_,this.iv,this.encrypted]):(O=Be.concatUint8Array([new Uint8Array([this.version,w]),_]),null!==this.encrypted&&(O=Be.concatUint8Array([O,this.encrypted])));return O}async decrypt(w){const O=null!==this.sessionKeyEncryptionAlgorithm?this.sessionKeyEncryptionAlgorithm:this.sessionKeyAlgorithm,{blockSize:_,keySize:N}=wn(O),F=await this.s2k.produceKey(w,N);if(this.version>=5){const w=Es(this.aeadAlgorithm,!0),_=new Uint8Array([192|Wa.tag,this.version,this.sessionKeyEncryptionAlgorithm,this.aeadAlgorithm]),H=6===this.version?await vn(ve.hash.sha256,F,new Uint8Array,_,N):F,j=await w(O,H);this.sessionKey=await j.decrypt(this.encrypted,this.iv,_)}else if(null!==this.encrypted){const w=await Mi(O,F,this.encrypted,new Uint8Array(_));if(this.sessionKeyAlgorithm=ve.write(ve.symmetric,w[0]),this.sessionKey=w.subarray(1,w.length),this.sessionKey.length!==wn(this.sessionKeyAlgorithm).keySize)throw Error("Unexpected session key size")}else this.sessionKey=F}async encrypt(w,O=Se){const _=null!==this.sessionKeyEncryptionAlgorithm?this.sessionKeyEncryptionAlgorithm:this.sessionKeyAlgorithm;this.sessionKeyEncryptionAlgorithm=_,this.s2k=xs(O),this.s2k.generateSalt();const{blockSize:N,keySize:F}=wn(_),H=await this.s2k.produceKey(w,F);if(null===this.sessionKey&&(this.sessionKey=Ci(this.sessionKeyAlgorithm)),this.version>=5){const w=Es(this.aeadAlgorithm);this.iv=we(w.ivLength);const O=new Uint8Array([192|Wa.tag,this.version,this.sessionKeyEncryptionAlgorithm,this.aeadAlgorithm]),N=6===this.version?await vn(ve.hash.sha256,H,new Uint8Array,O,F):H,j=await w(_,N);this.encrypted=await j.encrypt(this.sessionKey,this.iv,O)}else{const w=Be.concatUint8Array([new Uint8Array([this.sessionKeyAlgorithm]),this.sessionKey]);this.encrypted=await Li(_,H,w,new Uint8Array(N))}}}class $a{static get tag(){return ve.packet.publicKey}constructor(w=new Date,O=Se){this.version=O.v6Keys?6:4,this.created=Be.normalizeDate(w),this.algorithm=null,this.publicParams=null,this.expirationTimeV3=0,this.fingerprint=null,this.keyID=null}static fromSecretKeyPacket(w){const O=new $a,{version:_,created:N,algorithm:F,publicParams:H,keyID:j,fingerprint:G}=w;return O.version=_,O.created=N,O.algorithm=F,O.publicParams=H,O.keyID=j,O.fingerprint=G,O}async read(w,O=Se){let _=0;if(this.version=w[_++],5===this.version&&!O.enableParsingV5Entities)throw new er("Support for parsing v5 entities is disabled; turn on `config.enableParsingV5Entities` if needed");if(4===this.version||5===this.version||6===this.version){this.created=Be.readDate(w.subarray(_,_+4)),_+=4,this.algorithm=w[_++],this.version>=5&&(_+=4);const{read:O,publicParams:N}=function(w,O){let _=0;switch(w){case ve.publicKey.rsaEncrypt:case ve.publicKey.rsaEncryptSign:case ve.publicKey.rsaSign:{const w=Be.readMPI(O.subarray(_));_+=w.length+2;const N=Be.readMPI(O.subarray(_));return _+=N.length+2,{read:_,publicParams:{n:w,e:N}}}case ve.publicKey.dsa:{const w=Be.readMPI(O.subarray(_));_+=w.length+2;const N=Be.readMPI(O.subarray(_));_+=N.length+2;const F=Be.readMPI(O.subarray(_));_+=F.length+2;const H=Be.readMPI(O.subarray(_));return _+=H.length+2,{read:_,publicParams:{p:w,q:N,g:F,y:H}}}case ve.publicKey.elgamal:{const w=Be.readMPI(O.subarray(_));_+=w.length+2;const N=Be.readMPI(O.subarray(_));_+=N.length+2;const F=Be.readMPI(O.subarray(_));return _+=F.length+2,{read:_,publicParams:{p:w,g:N,y:F}}}case ve.publicKey.ecdsa:{const w=new qt;_+=w.read(O),Di(w);const N=Be.readMPI(O.subarray(_));return _+=N.length+2,{read:_,publicParams:{oid:w,Q:N}}}case ve.publicKey.eddsaLegacy:{const w=new qt;if(_+=w.read(O),Di(w),w.getName()!==ve.curve.ed25519Legacy)throw Error("Unexpected OID for eddsaLegacy");let N=Be.readMPI(O.subarray(_));return _+=N.length+2,N=Be.leftPad(N,33),{read:_,publicParams:{oid:w,Q:N}}}case ve.publicKey.ecdh:{const w=new qt;_+=w.read(O),Di(w);const N=Be.readMPI(O.subarray(_));_+=N.length+2;const F=new bi;return _+=F.read(O.subarray(_)),{read:_,publicParams:{oid:w,Q:N,kdfParams:F}}}case ve.publicKey.ed25519:case ve.publicKey.ed448:case ve.publicKey.x25519:case ve.publicKey.x448:{const N=Be.readExactSubarray(O,_,_+Ui(w));return _+=N.length,{read:_,publicParams:{A:N}}}default:throw new er("Unknown public key encryption algorithm.")}}(this.algorithm,w.subarray(_));if(6===this.version&&N.oid&&(N.oid.getName()===ve.curve.curve25519Legacy||N.oid.getName()===ve.curve.ed25519Legacy))throw Error("Legacy curve25519 cannot be used with v6 keys");return this.publicParams=N,_+=O,await this.computeFingerprintAndKeyID(),_}throw new er(`Version ${this.version} of the key packet is unsupported.`)}write(){const w=[];w.push(new Uint8Array([this.version])),w.push(Be.writeDate(this.created)),w.push(new Uint8Array([this.algorithm]));const O=Bi(this.algorithm,this.publicParams);return this.version>=5&&w.push(Be.writeNumber(O.length,4)),w.push(O),Be.concatUint8Array(w)}writeForHash(w){const O=this.writePublicKey(),_=149+w,N=w>=5?4:2;return Be.concatUint8Array([new Uint8Array([_]),Be.writeNumber(O.length,N),O])}isDecrypted(){return null}getCreationTime(){return this.created}getKeyID(){return this.keyID}async computeFingerprintAndKeyID(){if(await this.computeFingerprint(),this.keyID=new Ka,this.version>=5)this.keyID.read(this.fingerprint.subarray(0,8));else{if(4!==this.version)throw Error("Unsupported key version");this.keyID.read(this.fingerprint.subarray(12,20))}}async computeFingerprint(){const w=this.writeForHash(this.version);if(this.version>=5)this.fingerprint=await Ne(ve.hash.sha256,w);else{if(4!==this.version)throw Error("Unsupported key version");this.fingerprint=await Ne(ve.hash.sha1,w)}}getFingerprintBytes(){return this.fingerprint}getFingerprint(){return Be.uint8ArrayToHex(this.getFingerprintBytes())}hasSameFingerprintAs(w){return this.version===w.version&&Be.equalsUint8Array(this.writePublicKey(),w.writePublicKey())}getAlgorithmInfo(){const w={};w.algorithm=ve.read(ve.publicKey,this.algorithm);const O=this.publicParams.n||this.publicParams.p;return O?w.bits=Be.uint8ArrayBitLength(O):this.publicParams.oid&&(w.curve=this.publicParams.oid.getName()),w}}$a.prototype.readPublicKey=$a.prototype.read,$a.prototype.writePublicKey=$a.prototype.write;const wc=Be.constructAllowedPackets([Sa,Na,Ra,Pa]);class eo{static get tag(){return ve.packet.symmetricallyEncryptedData}constructor(){this.encrypted=null,this.packets=null}read(w){this.encrypted=w}write(){return this.encrypted}async decrypt(w,O,_=Se){if(!_.allowUnauthenticatedMessages)throw Error("Message is not authenticated.");const{blockSize:N}=wn(w),F=await Q(D(this.encrypted)),H=await Mi(w,O,F.subarray(N+2),F.subarray(2,N+2));this.packets=await La.fromBinary(H,wc,_)}async encrypt(w,O,_=Se){const N=this.packets.write(),{blockSize:F}=wn(w),H=await Ti(w),j=await Li(w,O,H,new Uint8Array(F)),G=await Li(w,O,N,j.subarray(2));this.encrypted=Be.concat([j,G])}}class to extends $a{static get tag(){return ve.packet.publicSubkey}constructor(w,O){super(w,O)}static fromSecretSubkeyPacket(w){const O=new to,{version:_,created:N,algorithm:F,publicParams:H,keyID:j,fingerprint:G}=w;return O.version=_,O.created=N,O.algorithm=F,O.publicParams=H,O.keyID=j,O.fingerprint=G,O}}class ro{static get tag(){return ve.packet.userAttribute}constructor(){this.attributes=[]}read(w){let O=0;for(;O<w.length;){const _=Vt(w.subarray(O,w.length));O+=_.offset,this.attributes.push(Be.uint8ArrayToString(w.subarray(O,O+_.len))),O+=_.len}}write(){const w=[];for(let O=0;O<this.attributes.length;O++)w.push(Jt(this.attributes[O].length)),w.push(Be.stringToUint8Array(this.attributes[O]));return Be.concatUint8Array(w)}equals(w){return!!(w&&w instanceof ro)&&this.attributes.every((function(O,_){return O===w.attributes[_]}))}}class no extends $a{static get tag(){return ve.packet.secretKey}constructor(w=new Date,O=Se){super(w,O),this.keyMaterial=null,this.isEncrypted=null,this.s2kUsage=0,this.s2k=null,this.symmetric=null,this.aead=null,this.isLegacyAEAD=null,this.privateParams=null,this.usedModernAEAD=null}async read(w,O=Se){let _=await this.readPublicKey(w,O);const N=_;this.s2kUsage=w[_++],5===this.version&&_++,6===this.version&&this.s2kUsage&&_++;try{if(255===this.s2kUsage||254===this.s2kUsage||253===this.s2kUsage){this.symmetric=w[_++],253===this.s2kUsage&&(this.aead=w[_++]),6===this.version&&_++;const O=w[_++];if(this.s2k=Ps(O),_+=this.s2k.read(w.subarray(_,w.length)),"gnu-dummy"===this.s2k.type)return}else this.s2kUsage&&(this.symmetric=this.s2kUsage);this.s2kUsage&&(this.isLegacyAEAD=253===this.s2kUsage&&(5===this.version||4===this.version&&O.parseAEADEncryptedV4KeysAsLegacy),253!==this.s2kUsage||this.isLegacyAEAD?(this.iv=w.subarray(_,_+wn(this.symmetric).blockSize),this.usedModernAEAD=!1):(this.iv=w.subarray(_,_+Es(this.aead).ivLength),this.usedModernAEAD=!0),_+=this.iv.length)}catch(O){if(!this.s2kUsage)throw O;this.unparseableKeyMaterial=w.subarray(N),this.isEncrypted=!0}if(5===this.version&&(_+=4),this.keyMaterial=w.subarray(_),this.isEncrypted=!!this.s2kUsage,!this.isEncrypted){let O;if(6===this.version)O=this.keyMaterial;else if(O=this.keyMaterial.subarray(0,-2),!Be.equalsUint8Array(Be.writeChecksum(O),this.keyMaterial.subarray(-2)))throw Error("Key checksum mismatch");try{const{read:w,privateParams:_}=Ii(this.algorithm,O,this.publicParams);if(w<O.length)throw Error("Error reading MPIs");this.privateParams=_}catch(w){if(w instanceof er)throw w;throw Error("Error reading MPIs")}}}write(){const w=this.writePublicKey();if(this.unparseableKeyMaterial)return Be.concatUint8Array([w,this.unparseableKeyMaterial]);const O=[w];O.push(new Uint8Array([this.s2kUsage]));const _=[];if(255===this.s2kUsage||254===this.s2kUsage||253===this.s2kUsage){_.push(this.symmetric),253===this.s2kUsage&&_.push(this.aead);const w=this.s2k.write();6===this.version&&_.push(w.length),_.push(...w)}return this.s2kUsage&&"gnu-dummy"!==this.s2k.type&&_.push(...this.iv),(5===this.version||6===this.version&&this.s2kUsage)&&O.push(new Uint8Array([_.length])),O.push(new Uint8Array(_)),this.isDummy()||(this.s2kUsage||(this.keyMaterial=Bi(this.algorithm,this.privateParams)),5===this.version&&O.push(Be.writeNumber(this.keyMaterial.length,4)),O.push(this.keyMaterial),this.s2kUsage||6===this.version||O.push(Be.writeChecksum(this.keyMaterial))),Be.concatUint8Array(O)}isDecrypted(){return!1===this.isEncrypted}isMissingSecretKeyMaterial(){return void 0!==this.unparseableKeyMaterial||this.isDummy()}isDummy(){return!(!this.s2k||"gnu-dummy"!==this.s2k.type)}makeDummy(w=Se){this.isDummy()||(this.isDecrypted()&&this.clearPrivateParams(),delete this.unparseableKeyMaterial,this.isEncrypted=null,this.keyMaterial=null,this.s2k=Ps(ve.s2k.gnu,w),this.s2k.algorithm=0,this.s2k.c=0,this.s2k.type="gnu-dummy",this.s2kUsage=254,this.symmetric=ve.symmetric.aes256,this.isLegacyAEAD=null,this.usedModernAEAD=null)}async encrypt(w,O=Se){if(this.isDummy())return;if(!this.isDecrypted())throw Error("Key packet is already encrypted");if(!w)throw Error("A non-empty passphrase is required for key encryption.");this.s2k=xs(O),this.s2k.generateSalt();const _=Bi(this.algorithm,this.privateParams);this.symmetric=ve.symmetric.aes256;const{blockSize:N}=wn(this.symmetric);if(O.aeadProtect){this.s2kUsage=253,this.aead=O.preferredAEADAlgorithm;const F=Es(this.aead);this.isLegacyAEAD=5===this.version,this.usedModernAEAD=!this.isLegacyAEAD;const H=Zt(this.constructor.tag),j=await io(this.version,this.s2k,w,this.symmetric,this.aead,H,this.isLegacyAEAD),G=await F(this.symmetric,j);this.iv=this.isLegacyAEAD?we(N):we(F.ivLength);const z=this.isLegacyAEAD?new Uint8Array:Be.concatUint8Array([H,this.writePublicKey()]);this.keyMaterial=await G.encrypt(_,this.iv.subarray(0,F.ivLength),z)}else{this.s2kUsage=254,this.usedModernAEAD=!1;const O=await io(this.version,this.s2k,w,this.symmetric);this.iv=we(N),this.keyMaterial=await Li(this.symmetric,O,Be.concatUint8Array([_,await Ne(ve.hash.sha1,_)]),this.iv)}}async decrypt(w){if(this.isDummy())return!1;if(this.unparseableKeyMaterial)throw Error("Key packet cannot be decrypted: unsupported S2K or cipher algo");if(this.isDecrypted())throw Error("Key packet is already decrypted.");let O;const _=Zt(this.constructor.tag);if(254!==this.s2kUsage&&253!==this.s2kUsage)throw 255===this.s2kUsage?Error("Encrypted private key is authenticated using an insecure two-byte hash"):Error("Private key is encrypted using an insecure S2K function: unsalted MD5");let N;if(O=await io(this.version,this.s2k,w,this.symmetric,this.aead,_,this.isLegacyAEAD),253===this.s2kUsage){const F=Es(this.aead,!0),H=await F(this.symmetric,O);try{const w=this.isLegacyAEAD?new Uint8Array:Be.concatUint8Array([_,this.writePublicKey()]);N=await H.decrypt(this.keyMaterial,this.iv.subarray(0,F.ivLength),w)}catch(w){if("Authentication tag mismatch"===w.message)throw Error("Incorrect key passphrase: "+w.message);throw w}}else{const w=await Mi(this.symmetric,O,this.keyMaterial,this.iv);N=w.subarray(0,-20);const _=await Ne(ve.hash.sha1,N);if(!Be.equalsUint8Array(_,w.subarray(-20)))throw Error("Incorrect key passphrase")}try{const{privateParams:w}=Ii(this.algorithm,N,this.publicParams);this.privateParams=w}catch(w){throw Error("Error reading MPIs")}this.isEncrypted=!1,this.keyMaterial=null,this.s2kUsage=0,this.aead=null,this.symmetric=null,this.isLegacyAEAD=null}async validate(){if(this.isDummy())return;if(!this.isDecrypted())throw Error("Key is not decrypted");if(this.usedModernAEAD)return;let w;try{w=await Ki(this.algorithm,this.publicParams,this.privateParams)}catch(O){w=!1}if(!w)throw Error("Key is invalid")}async generate(w,O){if(6===this.version&&(this.algorithm===ve.publicKey.ecdh&&O===ve.curve.curve25519Legacy||this.algorithm===ve.publicKey.eddsaLegacy))throw Error(`Cannot generate v6 keys of type 'ecc' with curve ${O}. Generate a key of type 'curve25519' instead`);const{privateParams:_,publicParams:N}=await Si(this.algorithm,w,O);this.privateParams=_,this.publicParams=N,this.isEncrypted=!1}clearPrivateParams(){this.isMissingSecretKeyMaterial()||(Object.keys(this.privateParams).forEach((w=>{this.privateParams[w].fill(0),delete this.privateParams[w]})),this.privateParams=null,this.isEncrypted=!0)}}async function io(w,O,_,N,F,H,j){if("argon2"===O.type&&!F)throw Error("Using Argon2 S2K without AEAD is not allowed");if("simple"===O.type&&6===w)throw Error("Using Simple S2K with version 6 keys is not allowed");const{keySize:G}=wn(N),z=await O.produceKey(_,G);if(!F||5===w||j)return z;const X=Be.concatUint8Array([H,new Uint8Array([w,N,F])]);return vn(ve.hash.sha256,z,new Uint8Array,X,G)}class so{static get tag(){return ve.packet.userID}constructor(){this.userID="",this.name="",this.email="",this.comment=""}static fromObject(w){if(Be.isString(w)||w.name&&!Be.isString(w.name)||w.email&&!Be.isEmailAddress(w.email)||w.comment&&!Be.isString(w.comment))throw Error("Invalid user ID format");const O=new so;Object.assign(O,w);const _=[];return O.name&&_.push(O.name),O.comment&&_.push(`(${O.comment})`),O.email&&_.push(`<${O.email}>`),O.userID=_.join(" "),O}read(w,O=Se){const _=Be.decodeUTF8(w);if(_.length>O.maxUserIDLength)throw Error("User ID string is too long");const N=/^(?<name>[^()]+\s+)?(?<comment>\([^()]+\)\s+)?(?<email><\S+@\S+>)$/.exec(_);if(null!==N){const{name:w,comment:O,email:_}=N.groups;this.comment=O?.replace(/^\(|\)|\s$/g,"").trim()||"",this.name=w?.trim()||"",this.email=_.substring(1,_.length-1)}else/^[^\s@]+@[^\s@]+$/.test(_)&&(this.email=_);this.userID=_}write(){return Be.encodeUTF8(this.userID)}equals(w){return w&&w.userID===this.userID}}class ao extends no{static get tag(){return ve.packet.secretSubkey}constructor(w=new Date,O=Se){super(w,O)}}const mc=Be.constructAllowedPackets([Pa]);class co{constructor(w){this.packets=w||new La}write(){return this.packets.write()}armor(w=Se){const O=this.packets.some((w=>w.constructor.tag===Pa.tag&&6!==w.version));return ie(ve.armor.signature,this.write(),void 0,void 0,void 0,O,w)}getSigningKeyIDs(){return this.packets.map((w=>w.issuerKeyID))}}async function ho(w,O){const _=new ao(w.date,O);return _.packets=null,_.algorithm=ve.write(ve.publicKey,w.algorithm),await _.generate(w.rsaBits,w.curve),await _.computeFingerprintAndKeyID(),_}async function uo(w,O){const _=new no(w.date,O);return _.packets=null,_.algorithm=ve.write(ve.publicKey,w.algorithm),await _.generate(w.rsaBits,w.curve,w.config),await _.computeFingerprintAndKeyID(),_}async function lo(w,O,_,N,F=new Date,H){let j,G;for(let z=w.length-1;z>=0;z--)try{(!j||w[z].created>=j.created)&&(await w[z].verify(O,_,N,F,void 0,H),j=w[z])}catch(w){G=w}if(!j)throw Be.wrapError(`Could not find valid ${ve.read(ve.signature,_)} signature in key ${O.getKeyID().toHex()}`.replace("certGeneric ","self-").replace(/([a-z])([A-Z])/g,((w,O,_)=>O+" "+_.toLowerCase())),G);return j}function yo(w,O,_=new Date){const N=Be.normalizeDate(_);if(null!==N){const _=mo(w,O);return!(w.created<=N&&N<_)}return!1}async function fo(w,O,_,N){const F={};F.key=O,F.bind=w;const H={signatureType:ve.signature.subkeyBinding};_.sign?(H.keyFlags=[ve.keyFlags.signData],H.embeddedSignature=await po(F,[],w,{signatureType:ve.signature.keyBinding},_.date,void 0,void 0,void 0,N)):H.keyFlags=[ve.keyFlags.encryptCommunication|ve.keyFlags.encryptStorage],_.keyExpirationTime>0&&(H.keyExpirationTime=_.keyExpirationTime,H.keyNeverExpires=!1);return await po(F,[],O,H,_.date,void 0,void 0,void 0,N)}async function go(w,O,_=new Date,N=[],F){const H=ve.hash.sha256,j=F.preferredHashAlgorithm,G=await Promise.all(w.map((async(w,O)=>(await w.getPrimarySelfSignature(_,N[O],F)).preferredHashAlgorithms||[]))),z=new Map;for(const w of G)for(const O of w)try{const w=ve.write(ve.hash,O);z.set(w,z.has(w)?z.get(w)+1:1)}catch{}const h=O=>0===w.length||z.get(O)===w.length||O===H,u=()=>{if(0===z.size)return H;const w=Array.from(z.keys()).filter((w=>h(w))).sort(((w,O)=>Fe(w)-Fe(O)))[0];return Fe(w)>=Fe(H)?w:H};if(new Set([ve.publicKey.ecdsa,ve.publicKey.eddsaLegacy,ve.publicKey.ed25519,ve.publicKey.ed448]).has(O.algorithm)){const w=function(w,O){switch(w){case ve.publicKey.ecdsa:case ve.publicKey.eddsaLegacy:return zn(O);case ve.publicKey.ed25519:case ve.publicKey.ed448:return cr(w);default:throw Error("Unknown elliptic signing algo")}}(O.algorithm,O.publicParams.oid),_=h(j),N=Fe(j)>=Fe(w);if(_&&N)return j;{const O=u();return Fe(O)>=Fe(w)?O:w}}return h(j)?j:u()}async function po(w,O,_,N,F,H,j=[],G=!1,z){if(_.isDummy())throw Error("Cannot sign with a gnu-dummy key.");if(!_.isDecrypted())throw Error("Signing key is not decrypted.");const X=new Pa;return Object.assign(X,N),X.publicKeyAlgorithm=_.algorithm,X.hashAlgorithm=await go(O,_,F,H,z),X.rawNotations=[...j],await X.sign(_,w,F,G,z),X}async function Ao(w,O,_,N=new Date,F){(w=w[_])&&(O[_].length?await Promise.all(w.map((async function(w){w.isExpired(N)||F&&!await F(w)||O[_].some((function(O){return Be.equalsUint8Array(O.writeParams(),w.writeParams())}))||O[_].push(w)}))):O[_]=w)}async function wo(w,O,_,N,F,H,j=new Date,G){H=H||w;const z=[];return await Promise.all(N.map((async function(w){try{if(!F||w.issuerKeyID.equals(F.issuerKeyID)){const N=![ve.reasonForRevocation.keyRetired,ve.reasonForRevocation.keySuperseded,ve.reasonForRevocation.userIDInvalid].includes(w.reasonForRevocationFlag);await w.verify(H,O,_,N?null:j,!1,G),z.push(w.issuerKeyID)}}catch(w){}}))),F?(F.revoked=!!z.some((w=>w.equals(F.issuerKeyID)))||(F.revoked||!1),F.revoked):z.length>0}function mo(w,O){let _;return!1===O.keyNeverExpires&&(_=w.created.getTime()+1e3*O.keyExpirationTime),_?new Date(_):1/0}function bo(w,O={}){switch(w.type=w.type||O.type,w.curve=w.curve||O.curve,w.rsaBits=w.rsaBits||O.rsaBits,w.keyExpirationTime=void 0!==w.keyExpirationTime?w.keyExpirationTime:O.keyExpirationTime,w.passphrase=Be.isString(w.passphrase)?w.passphrase:O.passphrase,w.date=w.date||O.date,w.sign=w.sign||!1,w.type){case"ecc":try{w.curve=ve.write(ve.curve,w.curve)}catch(w){throw Error("Unknown curve")}w.curve!==ve.curve.ed25519Legacy&&w.curve!==ve.curve.curve25519Legacy&&"ed25519"!==w.curve&&"curve25519"!==w.curve||(w.curve=w.sign?ve.curve.ed25519Legacy:ve.curve.curve25519Legacy),w.sign?w.algorithm=w.curve===ve.curve.ed25519Legacy?ve.publicKey.eddsaLegacy:ve.publicKey.ecdsa:w.algorithm=ve.publicKey.ecdh;break;case"curve25519":w.algorithm=w.sign?ve.publicKey.ed25519:ve.publicKey.x25519;break;case"curve448":w.algorithm=w.sign?ve.publicKey.ed448:ve.publicKey.x448;break;case"rsa":w.algorithm=ve.publicKey.rsaEncryptSign;break;default:throw Error("Unsupported key type "+w.type)}return w}function ko(w,O,_){switch(w.algorithm){case ve.publicKey.rsaEncryptSign:case ve.publicKey.rsaSign:case ve.publicKey.dsa:case ve.publicKey.ecdsa:case ve.publicKey.eddsaLegacy:case ve.publicKey.ed25519:case ve.publicKey.ed448:if(!O.keyFlags&&!_.allowMissingKeyFlags)throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");return!O.keyFlags||!!(O.keyFlags[0]&ve.keyFlags.signData);default:return!1}}function Eo(w,O,_){switch(w.algorithm){case ve.publicKey.rsaEncryptSign:case ve.publicKey.rsaEncrypt:case ve.publicKey.elgamal:case ve.publicKey.ecdh:case ve.publicKey.x25519:case ve.publicKey.x448:if(!O.keyFlags&&!_.allowMissingKeyFlags)throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");return!O.keyFlags||!!(O.keyFlags[0]&ve.keyFlags.encryptCommunication)||!!(O.keyFlags[0]&ve.keyFlags.encryptStorage);default:return!1}}function vo(w,O,_){if(!O.keyFlags&&!_.allowMissingKeyFlags)throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");switch(w.algorithm){case ve.publicKey.rsaEncryptSign:case ve.publicKey.rsaEncrypt:case ve.publicKey.elgamal:case ve.publicKey.ecdh:case ve.publicKey.x25519:case ve.publicKey.x448:return!(!(!O.keyFlags||!!(O.keyFlags[0]&ve.keyFlags.signData))||!_.allowInsecureDecryptionWithSigningKeys)||(!O.keyFlags||!!(O.keyFlags[0]&ve.keyFlags.encryptCommunication)||!!(O.keyFlags[0]&ve.keyFlags.encryptStorage));default:return!1}}function Io(w,O){const _=ve.write(ve.publicKey,w.algorithm),N=w.getAlgorithmInfo();if(O.rejectPublicKeyAlgorithms.has(_))throw Error(N.algorithm+" keys are considered too weak.");switch(_){case ve.publicKey.rsaEncryptSign:case ve.publicKey.rsaSign:case ve.publicKey.rsaEncrypt:if(N.bits<O.minRSABits)throw Error(`RSA keys shorter than ${O.minRSABits} bits are considered too weak.`);break;case ve.publicKey.ecdsa:case ve.publicKey.eddsaLegacy:case ve.publicKey.ecdh:if(O.rejectCurves.has(N.curve))throw Error(`Support for ${N.algorithm} keys using curve ${N.curve} is disabled.`)}}class Bo{constructor(w,O){this.userID=w.constructor.tag===ve.packet.userID?w:null,this.userAttribute=w.constructor.tag===ve.packet.userAttribute?w:null,this.selfCertifications=[],this.otherCertifications=[],this.revocationSignatures=[],this.mainKey=O}toPacketList(){const w=new La;return w.push(this.userID||this.userAttribute),w.push(...this.revocationSignatures),w.push(...this.selfCertifications),w.push(...this.otherCertifications),w}clone(){const w=new Bo(this.userID||this.userAttribute,this.mainKey);return w.selfCertifications=[...this.selfCertifications],w.otherCertifications=[...this.otherCertifications],w.revocationSignatures=[...this.revocationSignatures],w}async certify(w,O,_){const N=this.mainKey.keyPacket,F={userID:this.userID,userAttribute:this.userAttribute,key:N},H=new Bo(F.userID||F.userAttribute,this.mainKey);return H.otherCertifications=await Promise.all(w.map((async function(w){if(!w.isPrivate())throw Error("Need private key for signing");if(w.hasSameFingerprintAs(N))throw Error("The user's own key can only be used for self-certifications");const H=await w.getSigningKey(void 0,O,void 0,_);return po(F,[w],H.keyPacket,{signatureType:ve.signature.certGeneric,keyFlags:[ve.keyFlags.certifyKeys|ve.keyFlags.signData]},O,void 0,void 0,void 0,_)}))),await H.update(this,O,_),H}async isRevoked(w,O,_=new Date,N=Se){const F=this.mainKey.keyPacket;return wo(F,ve.signature.certRevocation,{key:F,userID:this.userID,userAttribute:this.userAttribute},this.revocationSignatures,w,O,_,N)}async verifyCertificate(w,O,_=new Date,N){const F=this,H=this.mainKey.keyPacket,j={userID:this.userID,userAttribute:this.userAttribute,key:H},{issuerKeyID:G}=w,z=O.filter((w=>w.getKeys(G).length>0));return 0===z.length?null:(await Promise.all(z.map((async O=>{const H=await O.getSigningKey(G,w.created,void 0,N);if(w.revoked||await F.isRevoked(w,H.keyPacket,_,N))throw Error("User certificate is revoked");try{await w.verify(H.keyPacket,ve.signature.certGeneric,j,_,void 0,N)}catch(w){throw Be.wrapError("User certificate is invalid",w)}}))),!0)}async verifyAllCertifications(w,O=new Date,_){const N=this,F=this.selfCertifications.concat(this.otherCertifications);return Promise.all(F.map((async F=>({keyID:F.issuerKeyID,valid:await N.verifyCertificate(F,w,O,_).catch((()=>!1))}))))}async verify(w=new Date,O){if(!this.selfCertifications.length)throw Error("No self-certifications found");const _=this,N=this.mainKey.keyPacket,F={userID:this.userID,userAttribute:this.userAttribute,key:N};let H;for(let j=this.selfCertifications.length-1;j>=0;j--)try{const H=this.selfCertifications[j];if(H.revoked||await _.isRevoked(H,void 0,w,O))throw Error("Self-certification is revoked");try{await H.verify(N,ve.signature.certGeneric,F,w,void 0,O)}catch(w){throw Be.wrapError("Self-certification is invalid",w)}return!0}catch(w){H=w}throw H}async update(w,O,_){const N=this.mainKey.keyPacket,F={userID:this.userID,userAttribute:this.userAttribute,key:N};await Ao(w,this,"selfCertifications",O,(async function(w){try{return await w.verify(N,ve.signature.certGeneric,F,O,!1,_),!0}catch(w){return!1}})),await Ao(w,this,"otherCertifications",O),await Ao(w,this,"revocationSignatures",O,(function(w){return wo(N,ve.signature.certRevocation,F,[w],void 0,void 0,O,_)}))}async revoke(w,{flag:O=ve.reasonForRevocation.noReason,string:_=""}={},N=new Date,F=Se){const H={userID:this.userID,userAttribute:this.userAttribute,key:w},j=new Bo(H.userID||H.userAttribute,this.mainKey);return j.revocationSignatures.push(await po(H,[],w,{signatureType:ve.signature.certRevocation,reasonForRevocationFlag:ve.write(ve.reasonForRevocation,O),reasonForRevocationString:_},N,void 0,void 0,!1,F)),await j.update(this),j}}class So{constructor(w,O){this.keyPacket=w,this.bindingSignatures=[],this.revocationSignatures=[],this.mainKey=O}toPacketList(){const w=new La;return w.push(this.keyPacket),w.push(...this.revocationSignatures),w.push(...this.bindingSignatures),w}clone(){const w=new So(this.keyPacket,this.mainKey);return w.bindingSignatures=[...this.bindingSignatures],w.revocationSignatures=[...this.revocationSignatures],w}async isRevoked(w,O,_=new Date,N=Se){const F=this.mainKey.keyPacket;return wo(F,ve.signature.subkeyRevocation,{key:F,bind:this.keyPacket},this.revocationSignatures,w,O,_,N)}async verify(w=new Date,O=Se){const _=this.mainKey.keyPacket,N={key:_,bind:this.keyPacket},F=await lo(this.bindingSignatures,_,ve.signature.subkeyBinding,N,w,O);if(F.revoked||await this.isRevoked(F,null,w,O))throw Error("Subkey is revoked");if(yo(this.keyPacket,F,w))throw Error("Subkey is expired");return F}async getExpirationTime(w=new Date,O=Se){const _=this.mainKey.keyPacket,N={key:_,bind:this.keyPacket};let F;try{F=await lo(this.bindingSignatures,_,ve.signature.subkeyBinding,N,w,O)}catch(w){return null}const H=mo(this.keyPacket,F),j=F.getExpirationTime();return H<j?H:j}async update(w,O=new Date,_=Se){const N=this.mainKey.keyPacket;if(!this.hasSameFingerprintAs(w))throw Error("Subkey update method: fingerprints of subkeys not equal");this.keyPacket.constructor.tag===ve.packet.publicSubkey&&w.keyPacket.constructor.tag===ve.packet.secretSubkey&&(this.keyPacket=w.keyPacket);const F=this,H={key:N,bind:F.keyPacket};await Ao(w,this,"bindingSignatures",O,(async function(w){for(let O=0;O<F.bindingSignatures.length;O++)if(F.bindingSignatures[O].issuerKeyID.equals(w.issuerKeyID))return w.created>F.bindingSignatures[O].created&&(F.bindingSignatures[O]=w),!1;try{return await w.verify(N,ve.signature.subkeyBinding,H,O,void 0,_),!0}catch(w){return!1}})),await Ao(w,this,"revocationSignatures",O,(function(w){return wo(N,ve.signature.subkeyRevocation,H,[w],void 0,void 0,O,_)}))}async revoke(w,{flag:O=ve.reasonForRevocation.noReason,string:_=""}={},N=new Date,F=Se){const H={key:w,bind:this.keyPacket},j=new So(this.keyPacket,this.mainKey);return j.revocationSignatures.push(await po(H,[],w,{signatureType:ve.signature.subkeyRevocation,reasonForRevocationFlag:ve.write(ve.reasonForRevocation,O),reasonForRevocationString:_},N,void 0,void 0,!1,F)),await j.update(this),j}hasSameFingerprintAs(w){return this.keyPacket.hasSameFingerprintAs(w.keyPacket||w)}}["getKeyID","getFingerprint","getAlgorithmInfo","getCreationTime","isDecrypted"].forEach((w=>{So.prototype[w]=function(){return this.keyPacket[w]()}}));const bc=Be.constructAllowedPackets([Pa]),vc=new Set([ve.packet.publicKey,ve.packet.privateKey]),Ic=new Set([ve.packet.publicKey,ve.packet.privateKey,ve.packet.publicSubkey,ve.packet.privateSubkey]);class Uo{packetListToStructure(w,O=new Set){let _,N,F,H;for(const j of w){if(j instanceof rr){Ic.has(j.tag)&&!H&&(H=vc.has(j.tag)?vc:Ic);continue}const w=j.constructor.tag;if(H){if(!H.has(w))continue;H=null}if(O.has(w))throw Error("Unexpected packet type: "+w);switch(w){case ve.packet.publicKey:case ve.packet.secretKey:if(this.keyPacket)throw Error("Key block contains multiple keys");if(this.keyPacket=j,N=this.getKeyID(),!N)throw Error("Missing Key ID");break;case ve.packet.userID:case ve.packet.userAttribute:_=new Bo(j,this),this.users.push(_);break;case ve.packet.publicSubkey:case ve.packet.secretSubkey:_=null,F=new So(j,this),this.subkeys.push(F);break;case ve.packet.signature:switch(j.signatureType){case ve.signature.certGeneric:case ve.signature.certPersona:case ve.signature.certCasual:case ve.signature.certPositive:if(!_){Be.printDebug("Dropping certification signatures without preceding user packet");continue}j.issuerKeyID.equals(N)?_.selfCertifications.push(j):_.otherCertifications.push(j);break;case ve.signature.certRevocation:_?_.revocationSignatures.push(j):this.directSignatures.push(j);break;case ve.signature.key:this.directSignatures.push(j);break;case ve.signature.subkeyBinding:if(!F){Be.printDebug("Dropping subkey binding signature without preceding subkey packet");continue}F.bindingSignatures.push(j);break;case ve.signature.keyRevocation:this.revocationSignatures.push(j);break;case ve.signature.subkeyRevocation:if(!F){Be.printDebug("Dropping subkey revocation signature without preceding subkey packet");continue}F.revocationSignatures.push(j)}}}}toPacketList(){const w=new La;return w.push(this.keyPacket),w.push(...this.revocationSignatures),w.push(...this.directSignatures),this.users.map((O=>w.push(...O.toPacketList()))),this.subkeys.map((O=>w.push(...O.toPacketList()))),w}clone(w=!1){const O=new this.constructor(this.toPacketList());return w&&O.getKeys().forEach((w=>{if(w.keyPacket=Object.create(Object.getPrototypeOf(w.keyPacket),Object.getOwnPropertyDescriptors(w.keyPacket)),!w.keyPacket.isDecrypted())return;const O={};Object.keys(w.keyPacket.privateParams).forEach((_=>{O[_]=new Uint8Array(w.keyPacket.privateParams[_])})),w.keyPacket.privateParams=O})),O}getSubkeys(w=null){return this.subkeys.filter((O=>!w||O.getKeyID().equals(w,!0)))}getKeys(w=null){const O=[];return w&&!this.getKeyID().equals(w,!0)||O.push(this),O.concat(this.getSubkeys(w))}getKeyIDs(){return this.getKeys().map((w=>w.getKeyID()))}getUserIDs(){return this.users.map((w=>w.userID?w.userID.userID:null)).filter((w=>null!==w))}write(){return this.toPacketList().write()}async getSigningKey(w=null,O=new Date,_={},N=Se){await this.verifyPrimaryKey(O,_,N);const F=this.keyPacket;try{Io(F,N)}catch(w){throw Be.wrapError("Could not verify primary key",w)}const H=this.subkeys.slice().sort(((w,O)=>O.keyPacket.created-w.keyPacket.created));let j;for(const _ of H)if(!w||_.getKeyID().equals(w))try{await _.verify(O,N);const w={key:F,bind:_.keyPacket},H=await lo(_.bindingSignatures,F,ve.signature.subkeyBinding,w,O,N);if(!ko(_.keyPacket,H,N))continue;if(!H.embeddedSignature)throw Error("Missing embedded signature");return await lo([H.embeddedSignature],_.keyPacket,ve.signature.keyBinding,w,O,N),Io(_.keyPacket,N),_}catch(w){j=w}try{const H=await this.getPrimarySelfSignature(O,_,N);if((!w||F.getKeyID().equals(w))&&ko(F,H,N))return Io(F,N),this}catch(w){j=w}throw Be.wrapError("Could not find valid signing key packet in key "+this.getKeyID().toHex(),j)}async getEncryptionKey(w,O=new Date,_={},N=Se){await this.verifyPrimaryKey(O,_,N);const F=this.keyPacket;try{Io(F,N)}catch(w){throw Be.wrapError("Could not verify primary key",w)}const H=this.subkeys.slice().sort(((w,O)=>O.keyPacket.created-w.keyPacket.created));let j;for(const _ of H)if(!w||_.getKeyID().equals(w))try{await _.verify(O,N);const w={key:F,bind:_.keyPacket},H=await lo(_.bindingSignatures,F,ve.signature.subkeyBinding,w,O,N);if(Eo(_.keyPacket,H,N))return Io(_.keyPacket,N),_}catch(w){j=w}try{const H=await this.getPrimarySelfSignature(O,_,N);if((!w||F.getKeyID().equals(w))&&Eo(F,H,N))return Io(F,N),this}catch(w){j=w}throw Be.wrapError("Could not find valid encryption key packet in key "+this.getKeyID().toHex(),j)}async isRevoked(w,O,_=new Date,N=Se){return wo(this.keyPacket,ve.signature.keyRevocation,{key:this.keyPacket},this.revocationSignatures,w,O,_,N)}async verifyPrimaryKey(w=new Date,O={},_=Se){const N=this.keyPacket;if(await this.isRevoked(null,null,w,_))throw Error("Primary key is revoked");if(yo(N,await this.getPrimarySelfSignature(w,O,_),w))throw Error("Primary key is expired");if(6!==N.version){const O=await lo(this.directSignatures,N,ve.signature.key,{key:N},w,_).catch((()=>{}));if(O&&yo(N,O,w))throw Error("Primary key is expired")}}async getExpirationTime(w,O=Se){let _;try{const N=await this.getPrimarySelfSignature(null,w,O),F=mo(this.keyPacket,N),H=N.getExpirationTime(),j=6!==this.keyPacket.version&&await lo(this.directSignatures,this.keyPacket,ve.signature.key,{key:this.keyPacket},null,O).catch((()=>{}));if(j){const w=mo(this.keyPacket,j);_=Math.min(F,H,w)}else _=F<H?F:H}catch(w){_=null}return Be.normalizeDate(_)}async getPrimarySelfSignature(w=new Date,O={},_=Se){const N=this.keyPacket;if(6===N.version)return lo(this.directSignatures,N,ve.signature.key,{key:N},w,_);const{selfCertification:F}=await this.getPrimaryUser(w,O,_);return F}async getPrimaryUser(w=new Date,O={},_=Se){const N=this.keyPacket,F=[];let H;for(let j=0;j<this.users.length;j++)try{const H=this.users[j];if(!H.userID)continue;if(void 0!==O.name&&H.userID.name!==O.name||void 0!==O.email&&H.userID.email!==O.email||void 0!==O.comment&&H.userID.comment!==O.comment)throw Error("Could not find user that matches that user ID");const G={userID:H.userID,key:N},z=await lo(H.selfCertifications,N,ve.signature.certGeneric,G,w,_);F.push({index:j,user:H,selfCertification:z})}catch(w){H=w}if(!F.length)throw H||Error("Could not find primary user");await Promise.all(F.map((async function(O){return O.selfCertification.revoked||O.user.isRevoked(O.selfCertification,null,w,_)})));const j=F.sort((function(w,O){const _=w.selfCertification,N=O.selfCertification;return N.revoked-_.revoked||_.isPrimaryUserID-N.isPrimaryUserID||_.created-N.created})).pop(),{user:G,selfCertification:z}=j;if(z.revoked||await G.isRevoked(z,null,w,_))throw Error("Primary user is revoked");return j}async update(w,O=new Date,_=Se){if(!this.hasSameFingerprintAs(w))throw Error("Primary key fingerprints must be equal to update the key");if(!this.isPrivate()&&w.isPrivate()){if(!(this.subkeys.length===w.subkeys.length&&this.subkeys.every((O=>w.subkeys.some((w=>O.hasSameFingerprintAs(w)))))))throw Error("Cannot update public key with private key if subkeys mismatch");return w.update(this,_)}const N=this.clone();return await Ao(w,N,"revocationSignatures",O,(F=>wo(N.keyPacket,ve.signature.keyRevocation,N,[F],null,w.keyPacket,O,_))),await Ao(w,N,"directSignatures",O),await Promise.all(w.users.map((async w=>{const F=N.users.filter((O=>w.userID&&w.userID.equals(O.userID)||w.userAttribute&&w.userAttribute.equals(O.userAttribute)));if(F.length>0)await Promise.all(F.map((N=>N.update(w,O,_))));else{const O=w.clone();O.mainKey=N,N.users.push(O)}}))),await Promise.all(w.subkeys.map((async w=>{const F=N.subkeys.filter((O=>O.hasSameFingerprintAs(w)));if(F.length>0)await Promise.all(F.map((N=>N.update(w,O,_))));else{const O=w.clone();O.mainKey=N,N.subkeys.push(O)}}))),N}async getRevocationCertificate(w=new Date,O=Se){const _={key:this.keyPacket},N=await lo(this.revocationSignatures,this.keyPacket,ve.signature.keyRevocation,_,w,O),F=new La;F.push(N);const H=6!==this.keyPacket.version;return ie(ve.armor.publicKey,F.write(),null,null,"This is a revocation certificate",H,O)}async applyRevocationCertificate(w,O=new Date,_=Se){const N=await ne(w),F=(await La.fromBinary(N.data,bc,_)).findPacket(ve.packet.signature);if(!F||F.signatureType!==ve.signature.keyRevocation)throw Error("Could not find revocation signature packet");if(!F.issuerKeyID.equals(this.getKeyID()))throw Error("Revocation signature does not match key");try{await F.verify(this.keyPacket,ve.signature.keyRevocation,{key:this.keyPacket},O,void 0,_)}catch(w){throw Be.wrapError("Could not verify revocation signature",w)}const H=this.clone();return H.revocationSignatures.push(F),H}async signPrimaryUser(w,O,_,N=Se){const{index:F,user:H}=await this.getPrimaryUser(O,_,N),j=await H.certify(w,O,N),G=this.clone();return G.users[F]=j,G}async signAllUsers(w,O=new Date,_=Se){const N=this.clone();return N.users=await Promise.all(this.users.map((function(N){return N.certify(w,O,_)}))),N}async verifyPrimaryUser(w,O=new Date,_,N=Se){const F=this.keyPacket,{user:H}=await this.getPrimaryUser(O,_,N);return w?await H.verifyAllCertifications(w,O,N):[{keyID:F.getKeyID(),valid:await H.verify(O,N).catch((()=>!1))}]}async verifyAllUsers(w,O=new Date,_=Se){const N=this.keyPacket,F=[];return await Promise.all(this.users.map((async H=>{const j=w?await H.verifyAllCertifications(w,O,_):[{keyID:N.getKeyID(),valid:await H.verify(O,_).catch((()=>!1))}];F.push(...j.map((w=>({userID:H.userID?H.userID.userID:null,userAttribute:H.userAttribute,keyID:w.keyID,valid:w.valid}))))}))),F}}["getKeyID","getFingerprint","getAlgorithmInfo","getCreationTime","hasSameFingerprintAs"].forEach((w=>{Uo.prototype[w]=So.prototype[w]}));class Po extends Uo{constructor(w){if(super(),this.keyPacket=null,this.revocationSignatures=[],this.directSignatures=[],this.users=[],this.subkeys=[],w&&(this.packetListToStructure(w,new Set([ve.packet.secretKey,ve.packet.secretSubkey])),!this.keyPacket))throw Error("Invalid key: missing public-key packet")}isPrivate(){return!1}toPublic(){return this}armor(w=Se){const O=6!==this.keyPacket.version;return ie(ve.armor.publicKey,this.toPacketList().write(),void 0,void 0,void 0,O,w)}}class xo extends Po{constructor(w){if(super(),this.packetListToStructure(w,new Set([ve.packet.publicKey,ve.packet.publicSubkey])),!this.keyPacket)throw Error("Invalid key: missing private-key packet")}isPrivate(){return!0}toPublic(){const w=new La,O=this.toPacketList();for(const _ of O)switch(_.constructor.tag){case ve.packet.secretKey:{const O=$a.fromSecretKeyPacket(_);w.push(O);break}case ve.packet.secretSubkey:{const O=to.fromSecretSubkeyPacket(_);w.push(O);break}default:w.push(_)}return new Po(w)}armor(w=Se){const O=6!==this.keyPacket.version;return ie(ve.armor.privateKey,this.toPacketList().write(),void 0,void 0,void 0,O,w)}async getDecryptionKeys(w,O=new Date,_={},N=Se){const F=this.keyPacket,H=[];let j=null;for(let _=0;_<this.subkeys.length;_++)if(!w||this.subkeys[_].getKeyID().equals(w,!0)){if(this.subkeys[_].keyPacket.isDummy()){j=j||Error("Gnu-dummy key packets cannot be used for decryption");continue}try{const w={key:F,bind:this.subkeys[_].keyPacket},j=await lo(this.subkeys[_].bindingSignatures,F,ve.signature.subkeyBinding,w,O,N);vo(this.subkeys[_].keyPacket,j,N)&&H.push(this.subkeys[_])}catch(w){j=w}}const G=await this.getPrimarySelfSignature(O,_,N);if(w&&!F.getKeyID().equals(w,!0)||!vo(F,G,N)||(F.isDummy()?j=j||Error("Gnu-dummy key packets cannot be used for decryption"):H.push(this)),0===H.length)throw j||Error("No decryption key packets found");return H}isDecrypted(){return this.getKeys().some((({keyPacket:w})=>w.isDecrypted()))}async validate(w=Se){if(!this.isPrivate())throw Error("Cannot validate a public key");let O;if(this.keyPacket.isDummy()){const _=await this.getSigningKey(null,null,void 0,{...w,rejectPublicKeyAlgorithms:new Set,minRSABits:0});_&&!_.keyPacket.isDummy()&&(O=_.keyPacket)}else O=this.keyPacket;if(O)return O.validate();{const w=this.getKeys();if(w.map((w=>w.keyPacket.isDummy())).every(Boolean))throw Error("Cannot validate an all-gnu-dummy key");return Promise.all(w.map((async w=>w.keyPacket.validate())))}}clearPrivateParams(){this.getKeys().forEach((({keyPacket:w})=>{w.isDecrypted()&&w.clearPrivateParams()}))}async revoke({flag:w=ve.reasonForRevocation.noReason,string:O=""}={},_=new Date,N=Se){if(!this.isPrivate())throw Error("Need private key for revoking");const F={key:this.keyPacket},H=this.clone();return H.revocationSignatures.push(await po(F,[],this.keyPacket,{signatureType:ve.signature.keyRevocation,reasonForRevocationFlag:ve.write(ve.reasonForRevocation,w),reasonForRevocationString:O},_,void 0,void 0,void 0,N)),H}async addSubkey(w={}){const O={...Se,...w.config};if(w.passphrase)throw Error("Subkey could not be encrypted here, please encrypt whole key");if(w.rsaBits<O.minRSABits)throw Error(`rsaBits should be at least ${O.minRSABits}, got: ${w.rsaBits}`);const _=this.keyPacket;if(_.isDummy())throw Error("Cannot add subkey to gnu-dummy primary key");if(!_.isDecrypted())throw Error("Key is not decrypted");const N=_.getAlgorithmInfo();N.type=function(w){switch(ve.write(ve.publicKey,w)){case ve.publicKey.rsaEncrypt:case ve.publicKey.rsaEncryptSign:case ve.publicKey.rsaSign:case ve.publicKey.dsa:return"rsa";case ve.publicKey.ecdsa:case ve.publicKey.eddsaLegacy:return"ecc";case ve.publicKey.ed25519:return"curve25519";case ve.publicKey.ed448:return"curve448";default:throw Error("Unsupported algorithm")}}(N.algorithm),N.rsaBits=N.bits||4096,N.curve=N.curve||"curve25519Legacy",w=bo(w,N);const F=await ho(w,{...O,v6Keys:6===this.keyPacket.version});Io(F,O);const H=await fo(F,_,w,O),j=this.toPacketList();return j.push(F,H),new xo(j)}}const Cc=Be.constructAllowedPackets([$a,to,no,ao,so,ro,Pa]);function Ro(w){for(const O of w)switch(O.constructor.tag){case ve.packet.secretKey:return new xo(w);case ve.packet.publicKey:return new Po(w)}throw Error("No key packet found")}async function To(w,O,_,N){_.passphrase&&await w.encrypt(_.passphrase,N),await Promise.all(O.map((async function(w,O){const F=_.subkeys[O].passphrase;F&&await w.encrypt(F,N)})));const F=new La;function s(w,O){return[O,...w.filter((w=>w!==O))]}function a(){const w={};w.keyFlags=[ve.keyFlags.certifyKeys|ve.keyFlags.signData];const O=s([ve.symmetric.aes256,ve.symmetric.aes128],N.preferredSymmetricAlgorithm);if(w.preferredSymmetricAlgorithms=O,N.aeadProtect){const _=s([ve.aead.gcm,ve.aead.eax,ve.aead.ocb],N.preferredAEADAlgorithm);w.preferredCipherSuites=_.flatMap((w=>O.map((O=>[O,w]))))}return w.preferredHashAlgorithms=s([ve.hash.sha512,ve.hash.sha256,ve.hash.sha3_512,ve.hash.sha3_256],N.preferredHashAlgorithm),w.preferredCompressionAlgorithms=s([ve.compression.uncompressed,ve.compression.zlib,ve.compression.zip],N.preferredCompressionAlgorithm),w.features=[0],w.features[0]|=ve.features.modificationDetection,N.aeadProtect&&(w.features[0]|=ve.features.seipdv2),_.keyExpirationTime>0&&(w.keyExpirationTime=_.keyExpirationTime,w.keyNeverExpires=!1),w}if(F.push(w),6===w.version){const O={key:w},H=a();H.signatureType=ve.signature.key;const j=await po(O,[],w,H,_.date,void 0,void 0,void 0,N);F.push(j)}await Promise.all(_.userIDs.map((async function(O,F){const H=so.fromObject(O),j={userID:H,key:w},G=6!==w.version?a():{};G.signatureType=ve.signature.certPositive,0===F&&(G.isPrimaryUserID=!0);return{userIDPacket:H,signaturePacket:await po(j,[],w,G,_.date,void 0,void 0,void 0,N)}}))).then((w=>{w.forEach((({userIDPacket:w,signaturePacket:O})=>{F.push(w),F.push(O)}))})),await Promise.all(O.map((async function(O,F){const H=_.subkeys[F];return{secretSubkeyPacket:O,subkeySignaturePacket:await fo(O,w,H,N)}}))).then((w=>{w.forEach((({secretSubkeyPacket:w,subkeySignaturePacket:O})=>{F.push(w),F.push(O)}))}));const H={key:w};return F.push(await po(H,[],w,{signatureType:ve.signature.keyRevocation,reasonForRevocationFlag:ve.reasonForRevocation.noReason,reasonForRevocationString:""},_.date,void 0,void 0,void 0,N)),_.passphrase&&w.clearPrivateParams(),await Promise.all(O.map((async function(w,O){_.subkeys[O].passphrase&&w.clearPrivateParams()}))),new xo(F)}const Kc=Be.constructAllowedPackets([Sa,Na,Ja,ja,eo,Ya,Wa,Ra,Pa]),Dc=Be.constructAllowedPackets([Wa]),Qc=Be.constructAllowedPackets([Pa]);class Fo{constructor(w){this.packets=w||new La}getEncryptionKeyIDs(){const w=[];return this.packets.filterByTag(ve.packet.publicKeyEncryptedSessionKey).forEach((function(O){w.push(O.publicKeyID)})),w}getSigningKeyIDs(){const w=this.unwrapCompressed(),O=w.packets.filterByTag(ve.packet.onePassSignature);if(O.length>0)return O.map((w=>w.issuerKeyID));return w.packets.filterByTag(ve.packet.signature).map((w=>w.issuerKeyID))}async decrypt(w,O,_,N=new Date,F=Se){const H=this.packets.filterByTag(ve.packet.symmetricallyEncryptedData,ve.packet.symEncryptedIntegrityProtectedData,ve.packet.aeadEncryptedData);if(0===H.length)throw Error("No encrypted data found");const j=H[0],G=j.cipherAlgorithm,z=_||await this.decryptSessionKeys(w,O,G,N,F);let X=null;const ee=Promise.all(z.map((async({algorithm:w,data:O})=>{if(!Be.isUint8Array(O)||!j.cipherAlgorithm&&!Be.isString(w))throw Error("Invalid session key for decryption.");try{const _=j.cipherAlgorithm||ve.write(ve.symmetric,w);await j.decrypt(_,O,F)}catch(w){Be.printDebugError(w),X=w}})));if(R(j.encrypted),j.encrypted=null,await ee,!j.packets||!j.packets.length)throw X||Error("Decryption failed.");const se=new Fo(j.packets);return j.packets=new La,se}async decryptSessionKeys(w,O,_,N=new Date,F=Se){let H,j=[];if(O){const w=this.packets.filterByTag(ve.packet.symEncryptedSessionKey);if(0===w.length)throw Error("No symmetrically encrypted session key packet found.");await Promise.all(O.map((async function(O,_){let N;N=_?await La.fromBinary(w.write(),Dc,F):w,await Promise.all(N.map((async function(w){try{await w.decrypt(O),j.push(w)}catch(w){Be.printDebugError(w),w instanceof Bs&&(H=w)}})))})))}else{if(!w)throw Error("No key or password specified.");{const O=this.packets.filterByTag(ve.packet.publicKeyEncryptedSessionKey);if(0===O.length)throw Error("No public key encrypted session key packet found.");await Promise.all(O.map((async function(O){await Promise.all(w.map((async function(w){let G;try{G=(await w.getDecryptionKeys(O.publicKeyID,null,void 0,F)).map((w=>w.keyPacket))}catch(w){return void(H=w)}let z=[ve.symmetric.aes256,ve.symmetric.aes128,ve.symmetric.tripledes,ve.symmetric.cast5];try{const O=await w.getPrimarySelfSignature(N,void 0,F);O.preferredSymmetricAlgorithms&&(z=z.concat(O.preferredSymmetricAlgorithms))}catch(w){}await Promise.all(G.map((async function(w){if(!w.isDecrypted())throw Error("Decryption key is not decrypted.");if(F.constantTimePKCS1Decryption&&(O.publicKeyAlgorithm===ve.publicKey.rsaEncrypt||O.publicKeyAlgorithm===ve.publicKey.rsaEncryptSign||O.publicKeyAlgorithm===ve.publicKey.rsaSign||O.publicKeyAlgorithm===ve.publicKey.elgamal)){const N=O.write();await Promise.all((_?[_]:Array.from(F.constantTimePKCS1DecryptionSupportedSymmetricAlgorithms)).map((async O=>{const _=new Ya;_.read(N);const F={sessionKeyAlgorithm:O,sessionKey:Ci(O)};try{await _.decrypt(w,F),j.push(_)}catch(w){Be.printDebugError(w),H=w}})))}else try{await O.decrypt(w);const N=_||O.sessionKeyAlgorithm;if(N&&!z.includes(ve.write(ve.symmetric,N)))throw Error("A non-preferred symmetric algorithm was used.");j.push(O)}catch(w){Be.printDebugError(w),H=w}})))}))),R(O.encrypted),O.encrypted=null})))}}if(j.length>0){if(j.length>1){const w=new Set;j=j.filter((O=>{const _=O.sessionKeyAlgorithm+Be.uint8ArrayToString(O.sessionKey);return!w.has(_)&&(w.add(_),!0)}))}return j.map((w=>({data:w.sessionKey,algorithm:w.sessionKeyAlgorithm&&ve.read(ve.symmetric,w.sessionKeyAlgorithm)})))}throw H||Error("Session key decryption failed.")}getLiteralData(){const w=this.unwrapCompressed().packets.findPacket(ve.packet.literalData);return w&&w.getBytes()||null}getFilename(){const w=this.unwrapCompressed().packets.findPacket(ve.packet.literalData);return w&&w.getFilename()||null}getText(){const w=this.unwrapCompressed().packets.findPacket(ve.packet.literalData);return w?w.getText():null}static async generateSessionKey(w=[],O=new Date,_=[],N=Se){const{symmetricAlgo:F,aeadAlgo:H}=await async function(w=[],O=new Date,_=[],N=Se){const F=await Promise.all(w.map(((w,F)=>w.getPrimarySelfSignature(O,_[F],N))));if(w.length?F.every((w=>w.features&&w.features[0]&ve.features.seipdv2)):N.aeadProtect){const w={symmetricAlgo:ve.symmetric.aes128,aeadAlgo:ve.aead.ocb},O=[{symmetricAlgo:N.preferredSymmetricAlgorithm,aeadAlgo:N.preferredAEADAlgorithm},{symmetricAlgo:N.preferredSymmetricAlgorithm,aeadAlgo:ve.aead.ocb},{symmetricAlgo:ve.symmetric.aes128,aeadAlgo:N.preferredAEADAlgorithm}];for(const w of O)if(F.every((O=>O.preferredCipherSuites&&O.preferredCipherSuites.some((O=>O[0]===w.symmetricAlgo&&O[1]===w.aeadAlgo)))))return w;return w}const H=ve.symmetric.aes128,j=N.preferredSymmetricAlgorithm;return{symmetricAlgo:F.every((w=>w.preferredSymmetricAlgorithms&&w.preferredSymmetricAlgorithms.includes(j)))?j:H,aeadAlgo:void 0}}(w,O,_,N),j=ve.read(ve.symmetric,F),G=H?ve.read(ve.aead,H):void 0;await Promise.all(w.map((w=>w.getEncryptionKey().catch((()=>null)).then((w=>{if(w&&(w.keyPacket.algorithm===ve.publicKey.x25519||w.keyPacket.algorithm===ve.publicKey.x448)&&!G&&!Be.isAES(F))throw Error("Could not generate a session key compatible with the given `encryptionKeys`: X22519 and X448 keys can only be used to encrypt AES session keys; change `config.preferredSymmetricAlgorithm` accordingly.")})))));return{data:Ci(F),algorithm:j,aeadAlgorithm:G}}async encrypt(w,O,_,N=!1,F=[],H=new Date,j=[],G=Se){if(_){if(!Be.isUint8Array(_.data)||!Be.isString(_.algorithm))throw Error("Invalid session key for encryption.")}else if(w&&w.length)_=await Fo.generateSessionKey(w,H,j,G);else{if(!O||!O.length)throw Error("No keys, passwords, or session key provided.");_=await Fo.generateSessionKey(void 0,void 0,void 0,G)}const{data:z,algorithm:X,aeadAlgorithm:ee}=_,se=await Fo.encryptSessionKey(z,X,ee,w,O,N,F,H,j,G),ae=ja.fromObject({version:ee?2:1,aeadAlgorithm:ee?ve.write(ve.aead,ee):null});ae.packets=this.packets;const Ae=ve.write(ve.symmetric,X);return await ae.encrypt(Ae,z,G),se.packets.push(ae),ae.packets=new La,se}static async encryptSessionKey(w,O,_,N,F,H=!1,j=[],G=new Date,z=[],X=Se){const ee=new La,se=ve.write(ve.symmetric,O),ae=_&&ve.write(ve.aead,_);if(N){const O=await Promise.all(N.map((async function(O,_){const N=await O.getEncryptionKey(j[_],G,z,X),F=Ya.fromObject({version:ae?6:3,encryptionKeyPacket:N.keyPacket,anonymousRecipient:H,sessionKey:w,sessionKeyAlgorithm:se});return await F.encrypt(N.keyPacket),delete F.sessionKey,F})));ee.push(...O)}if(F){const t=async function(w,O){try{return await w.decrypt(O),1}catch(w){return 0}},r=(w,O)=>w+O,n=async function(w,O,_,N){const H=new Wa(X);if(H.sessionKey=w,H.sessionKeyAlgorithm=O,_&&(H.aeadAlgorithm=_),await H.encrypt(N,X),X.passwordCollisionCheck){if(1!==(await Promise.all(F.map((w=>t(H,w))))).reduce(r))return n(w,O,N)}return delete H.sessionKey,H},O=await Promise.all(F.map((O=>n(w,se,ae,O))));ee.push(...O)}return new Fo(ee)}async sign(w=[],O=[],_=null,N=[],F=new Date,H=[],j=[],G=[],z=Se){const X=new La,ee=this.packets.findPacket(ve.packet.literalData);if(!ee)throw Error("No literal data packet to sign.");const se=await Oo(ee,w,O,_,N,F,H,j,G,!1,z),ae=se.map(((w,O)=>Ra.fromSignaturePacket(w,0===O))).reverse();return X.push(...ae),X.push(ee),X.push(...se),new Fo(X)}compress(w,O=Se){if(w===ve.compression.uncompressed)return this;const _=new Na(O);_.algorithm=w,_.packets=this.packets;const N=new La;return N.push(_),new Fo(N)}async signDetached(w=[],O=[],_=null,N=[],F=[],H=new Date,j=[],G=[],z=Se){const X=this.packets.findPacket(ve.packet.literalData);if(!X)throw Error("No literal data packet to sign.");return new co(await Oo(X,w,O,_,N,F,H,j,G,!0,z))}async verify(w,O=new Date,_=Se){const N=this.unwrapCompressed(),F=N.packets.filterByTag(ve.packet.literalData);if(1!==F.length)throw Error("Can only verify message with one literal data packet.");y(N.packets.stream)&&N.packets.push(...await Q(N.packets.stream,(w=>w||[])));const H=N.packets.filterByTag(ve.packet.onePassSignature).reverse(),j=N.packets.filterByTag(ve.packet.signature);return H.length&&!j.length&&Be.isStream(N.packets.stream)&&!y(N.packets.stream)?(await Promise.all(H.map((async w=>{w.correspondingSig=new Promise(((O,_)=>{w.correspondingSigResolve=O,w.correspondingSigReject=_})),w.signatureData=T((async()=>(await w.correspondingSig).signatureData)),w.hashed=Q(await w.hash(w.signatureType,F[0],void 0,!1)),w.hashed.catch((()=>{}))}))),N.packets.stream=K(N.packets.stream,(async(w,O)=>{const _=L(w),N=M(O);try{for(let w=0;w<H.length;w++){const{value:O}=await _.read();H[w].correspondingSigResolve(O)}await _.readToEnd(),await N.ready,await N.close()}catch(w){H.forEach((O=>{O.correspondingSigReject(w)})),await N.abort(w)}})),Ho(H,F,w,O,!1,_)):Ho(j,F,w,O,!1,_)}verifyDetached(w,O,_=new Date,N=Se){const F=this.unwrapCompressed().packets.filterByTag(ve.packet.literalData);if(1!==F.length)throw Error("Can only verify message with one literal data packet.");return Ho(w.packets.filterByTag(ve.packet.signature),F,O,_,!0,N)}unwrapCompressed(){const w=this.packets.filterByTag(ve.packet.compressedData);return w.length?new Fo(w[0].packets):this}async appendSignature(w,O=Se){await this.packets.read(Be.isUint8Array(w)?w:(await ne(w)).data,Qc,O)}write(){return this.packets.write()}armor(w=Se){const O=this.packets[this.packets.length-1],_=O.constructor.tag===ja.tag?2!==O.version:this.packets.some((w=>w.constructor.tag===Pa.tag&&6!==w.version));return ie(ve.armor.message,this.write(),null,null,null,_,w)}}async function Oo(w,O,_=[],N=null,F=[],H=new Date,j=[],G=[],z=[],X=!1,ee=Se){const se=new La,ae=null===w.text?ve.signature.binary:ve.signature.text;if(await Promise.all(O.map((async(O,N)=>{const se=j[N];if(!O.isPrivate())throw Error("Need private key for signing");const Ae=await O.getSigningKey(F[N],H,se,ee);return po(w,_.length?_:[O],Ae.keyPacket,{signatureType:ae},H,G,z,X,ee)}))).then((w=>{se.push(...w)})),N){const w=N.packets.filterByTag(ve.packet.signature);se.push(...w)}return se}async function Ho(w,O,_,N=new Date,F=!1,H=Se){return Promise.all(w.filter((function(w){return["text","binary"].includes(ve.read(ve.signature,w.signatureType))})).map((async function(w){return async function(w,O,_,N=new Date,F=!1,H=Se){let j,G;for(const O of _){const _=O.getKeys(w.issuerKeyID);if(_.length>0){j=O,G=_[0];break}}const z=w instanceof Ra?w.correspondingSig:w,X={keyID:w.issuerKeyID,verified:(async()=>{if(!G)throw Error("Could not find signing key with key ID "+w.issuerKeyID.toHex());await w.verify(G.keyPacket,w.signatureType,O[0],N,F,H);const _=await z;if(G.getCreationTime()>_.created)throw Error("Key is newer than the signature");try{await j.getSigningKey(G.getKeyID(),_.created,void 0,H)}catch(w){if(!H.allowInsecureVerificationWithReformattedKeys||!w.message.match(/Signature creation time is in the future/))throw w;await j.getSigningKey(G.getKeyID(),N,void 0,H)}return!0})(),signature:(async()=>{const w=await z,O=new La;return w&&O.push(w),new co(O)})()};return X.signature.catch((()=>{})),X.verified.catch((()=>{})),X}(w,O,_,N,F,H)})))}const Mc=Be.constructAllowedPackets([Pa]);class Go{constructor(w,O){if(this.text=Be.removeTrailingSpaces(w).replace(/\r?\n/g,"\r\n"),O&&!(O instanceof co))throw Error("Invalid signature input");this.signature=O||new co(new La)}getSigningKeyIDs(){const w=[];return this.signature.packets.forEach((function(O){w.push(O.issuerKeyID)})),w}async sign(w,O=[],_=null,N=[],F=new Date,H=[],j=[],G=[],z=Se){const X=new Sa;X.setText(this.text);const ee=new co(await Oo(X,w,O,_,N,F,H,j,G,!0,z));return new Go(this.text,ee)}verify(w,O=new Date,_=Se){const N=this.signature.packets.filterByTag(ve.packet.signature),F=new Sa;return F.setText(this.text),Ho(N,[F],w,O,!0,_)}getText(){return this.text.replace(/\r\n/g,"\n")}armor(w=Se){const O=this.signature.packets.some((w=>6!==w.version)),_={hash:O?Array.from(new Set(this.signature.packets.map((w=>ve.read(ve.hash,w.hashAlgorithm).toUpperCase())))).join():null,text:this.text,data:this.signature.packets.write()};return ie(ve.armor.signed,_,void 0,void 0,void 0,O,w)}}function _o(w){if(!(w instanceof Fo))throw Error("Parameter [message] needs to be of type Message")}function jo(w){if(!(w instanceof Go||w instanceof Fo))throw Error("Parameter [message] needs to be of type Message or CleartextMessage")}function qo(w){if("armored"!==w&&"binary"!==w&&"object"!==w)throw Error("Unsupported format "+w)}const ru=Object.keys(Se).length;function Jo(w){const O=Object.keys(w);if(O.length!==ru)for(const w of O)if(void 0===Se[w])throw Error("Unknown config property: "+w)}function Yo(w){return w&&!Be.isArray(w)&&(w=[w]),w}async function Zo(w){return"array"===Be.isStream(w)?Q(w):w}function Wo(w,O){w.data=K(O.packets.stream,(async(O,_)=>{await v(w.data,_,{preventClose:!0});const N=M(_);try{await Q(O,(w=>w)),await N.close()}catch(w){await N.abort(w)}}))}function $o(w,O,_){switch(O){case"object":return w;case"armored":return w.armor(_);case"binary":return w.write();default:throw Error("Unsupported format "+O)}}function Xo(w){if(!Number.isSafeInteger(w)||w<0)throw Error("positive integer expected, not "+w)}function ec(w,...O){if(!((_=w)instanceof Uint8Array||null!=_&&"object"==typeof _&&"Uint8Array"===_.constructor.name))throw Error("Uint8Array expected");var _;if(O.length>0&&!O.includes(w.length))throw Error(`Uint8Array expected of length ${O}, not of length=${w.length}`)}function tc(w,O=!0){if(w.destroyed)throw Error("Hash instance has been destroyed");if(O&&w.finished)throw Error("Hash#digest() has already been called")}function rc(w,O){ec(w);const _=O.outputLen;if(w.length<_)throw Error("digestInto() expects output buffer of length at least "+_)}const nu=G&&"object"==typeof G&&"webcrypto"in G?G.webcrypto:G&&"object"==typeof G&&"randomBytes"in G?G:void 0,ic=w=>new DataView(w.buffer,w.byteOffset,w.byteLength),sc=(w,O)=>w<<32-O|w>>>O,ac=(w,O)=>w<<O|w>>>32-O>>>0,iu=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0];
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function cc(w){for(let _=0;_<w.length;_++)w[_]=(O=w[_])<<24&4278190080|O<<8&16711680|O>>>8&65280|O>>>24&255;var O}function hc(w){if("string"!=typeof w)throw Error("utf8ToBytes expected string, got "+typeof w);return new Uint8Array((new TextEncoder).encode(w))}function uc(w){return"string"==typeof w&&(w=hc(w)),ec(w),w}function lc(...w){let O=0;for(let _=0;_<w.length;_++){const N=w[_];ec(N),O+=N.length}const _=new Uint8Array(O);for(let O=0,N=0;O<w.length;O++){const F=w[O];_.set(F,N),N+=F.length}return _}class yc{clone(){return this._cloneInto()}}function fc(w){const t=O=>w().update(uc(O)).digest(),O=w();return t.outputLen=O.outputLen,t.blockLen=O.blockLen,t.create=()=>w(),t}function gc(w=32){if(nu&&"function"==typeof nu.getRandomValues)return nu.getRandomValues(new Uint8Array(w));if(nu&&"function"==typeof nu.randomBytes)return nu.randomBytes(w);throw Error("crypto.getRandomValues must be defined")}const pc=(w,O,_)=>w&O^~w&_,dc=(w,O,_)=>w&O^w&_^O&_;class Ac extends yc{constructor(w,O,_,N){super(),this.blockLen=w,this.outputLen=O,this.padOffset=_,this.isLE=N,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(w),this.view=ic(this.buffer)}update(w){tc(this);const{view:O,buffer:_,blockLen:N}=this,F=(w=uc(w)).length;for(let H=0;H<F;){const j=Math.min(N-this.pos,F-H);if(j!==N)_.set(w.subarray(H,H+j),this.pos),this.pos+=j,H+=j,this.pos===N&&(this.process(O,0),this.pos=0);else{const O=ic(w);for(;N<=F-H;H+=N)this.process(O,H)}}return this.length+=w.length,this.roundClean(),this}digestInto(w){tc(this),rc(w,this),this.finished=!0;const{buffer:O,view:_,blockLen:N,isLE:F}=this;let{pos:H}=this;O[H++]=128,this.buffer.subarray(H).fill(0),this.padOffset>N-H&&(this.process(_,0),H=0);for(let w=H;w<N;w++)O[w]=0;!function(w,O,_,N){if("function"==typeof w.setBigUint64)return w.setBigUint64(O,_,N);const F=BigInt(32),H=BigInt(4294967295),j=Number(_>>F&H),G=Number(_&H),z=N?4:0,X=N?0:4;w.setUint32(O+z,j,N),w.setUint32(O+X,G,N)}(_,N-8,BigInt(8*this.length),F),this.process(_,0);const j=ic(w),G=this.outputLen;if(G%4)throw Error("_sha2: outputLen should be aligned to 32bit");const z=G/4,X=this.get();if(z>X.length)throw Error("_sha2: outputLen bigger than state");for(let w=0;w<z;w++)j.setUint32(4*w,X[w],F)}digest(){const{buffer:w,outputLen:O}=this;this.digestInto(w);const _=w.slice(0,O);return this.destroy(),_}_cloneInto(w){w||(w=new this.constructor),w.set(...this.get());const{blockLen:O,buffer:_,length:N,finished:F,destroyed:H,pos:j}=this;return w.length=N,w.pos=j,w.finished=F,w.destroyed=H,N%O&&w.buffer.set(_),w}}const su=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),au=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ou=new Uint32Array(64);class kc extends Ac{constructor(){super(64,32,8,!1),this.A=0|au[0],this.B=0|au[1],this.C=0|au[2],this.D=0|au[3],this.E=0|au[4],this.F=0|au[5],this.G=0|au[6],this.H=0|au[7]}get(){const{A:w,B:O,C:_,D:N,E:F,F:H,G:j,H:G}=this;return[w,O,_,N,F,H,j,G]}set(w,O,_,N,F,H,j,G){this.A=0|w,this.B=0|O,this.C=0|_,this.D=0|N,this.E=0|F,this.F=0|H,this.G=0|j,this.H=0|G}process(w,O){for(let _=0;_<16;_++,O+=4)ou[_]=w.getUint32(O,!1);for(let w=16;w<64;w++){const O=ou[w-15],_=ou[w-2],N=sc(O,7)^sc(O,18)^O>>>3,F=sc(_,17)^sc(_,19)^_>>>10;ou[w]=F+ou[w-7]+N+ou[w-16]|0}let{A:_,B:N,C:F,D:H,E:j,F:G,G:z,H:X}=this;for(let w=0;w<64;w++){const O=X+(sc(j,6)^sc(j,11)^sc(j,25))+pc(j,G,z)+su[w]+ou[w]|0,ee=(sc(_,2)^sc(_,13)^sc(_,22))+dc(_,N,F)|0;X=z,z=G,G=j,j=H+O|0,H=F,F=N,N=_,_=O+ee|0}_=_+this.A|0,N=N+this.B|0,F=F+this.C|0,H=H+this.D|0,j=j+this.E|0,G=G+this.F|0,z=z+this.G|0,X=X+this.H|0,this.set(_,N,F,H,j,G,z,X)}roundClean(){ou.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class Ec extends kc{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const cu=fc((()=>new kc)),uu=fc((()=>new Ec));class Bc extends yc{constructor(w,O){super(),this.finished=!1,this.destroyed=!1,function(w){if("function"!=typeof w||"function"!=typeof w.create)throw Error("Hash should be wrapped by utils.wrapConstructor");Xo(w.outputLen),Xo(w.blockLen)}(w);const _=uc(O);if(this.iHash=w.create(),"function"!=typeof this.iHash.update)throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const N=this.blockLen,F=new Uint8Array(N);F.set(_.length>N?w.create().update(_).digest():_);for(let w=0;w<F.length;w++)F[w]^=54;this.iHash.update(F),this.oHash=w.create();for(let w=0;w<F.length;w++)F[w]^=106;this.oHash.update(F),F.fill(0)}update(w){return tc(this),this.iHash.update(w),this}digestInto(w){tc(this),ec(w,this.outputLen),this.finished=!0,this.iHash.digestInto(w),this.oHash.update(w),this.oHash.digestInto(w),this.destroy()}digest(){const w=new Uint8Array(this.oHash.outputLen);return this.digestInto(w),w}_cloneInto(w){w||(w=Object.create(Object.getPrototypeOf(this),{}));const{oHash:O,iHash:_,finished:N,destroyed:F,blockLen:H,outputLen:j}=this;return w.finished=N,w.destroyed=F,w.blockLen=H,w.outputLen=j,w.oHash=O._cloneInto(w.oHash),w.iHash=_._cloneInto(w.iHash),w}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Sc=(w,O,_)=>new Bc(w,O).update(_).digest();Sc.create=(w,O)=>new Bc(w,O)
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */;const hu=BigInt(0),lu=BigInt(1),fu=BigInt(2);function Uc(w){return w instanceof Uint8Array||null!=w&&"object"==typeof w&&"Uint8Array"===w.constructor.name}function Pc(w){if(!Uc(w))throw Error("Uint8Array expected")}function xc(w,O){if("boolean"!=typeof O)throw Error(`${w} must be valid boolean, got "${O}".`)}const yu=Array.from({length:256},((w,O)=>O.toString(16).padStart(2,"0")));function Rc(w){Pc(w);let O="";for(let _=0;_<w.length;_++)O+=yu[w[_]];return O}function Tc(w){const O=w.toString(16);return 1&O.length?"0"+O:O}function Lc(w){if("string"!=typeof w)throw Error("hex string expected, got "+typeof w);return BigInt(""===w?"0":"0x"+w)}const du={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Nc(w){return w>=du._0&&w<=du._9?w-du._0:w>=du._A&&w<=du._F?w-(du._A-10):w>=du._a&&w<=du._f?w-(du._a-10):void 0}function Fc(w){if("string"!=typeof w)throw Error("hex string expected, got "+typeof w);const O=w.length,_=O/2;if(O%2)throw Error("padded hex string expected, got unpadded hex of length "+O);const N=new Uint8Array(_);for(let O=0,F=0;O<_;O++,F+=2){const _=Nc(w.charCodeAt(F)),H=Nc(w.charCodeAt(F+1));if(void 0===_||void 0===H){const O=w[F]+w[F+1];throw Error('hex string expected, got non-hex character "'+O+'" at index '+F)}N[O]=16*_+H}return N}function Oc(w){return Lc(Rc(w))}function Hc(w){return Pc(w),Lc(Rc(Uint8Array.from(w).reverse()))}function zc(w,O){return Fc(w.toString(16).padStart(2*O,"0"))}function Gc(w,O){return zc(w,O).reverse()}function _c(w,O,_){let N;if("string"==typeof O)try{N=Fc(O)}catch(_){throw Error(`${w} must be valid hex string, got "${O}". Cause: ${_}`)}else{if(!Uc(O))throw Error(w+" must be hex string or Uint8Array");N=Uint8Array.from(O)}const F=N.length;if("number"==typeof _&&F!==_)throw Error(`${w} expected ${_} bytes, got ${F}`);return N}function jc(...w){let O=0;for(let _=0;_<w.length;_++){const N=w[_];Pc(N),O+=N.length}const _=new Uint8Array(O);for(let O=0,N=0;O<w.length;O++){const F=w[O];_.set(F,N),N+=F.length}return _}const qc=w=>"bigint"==typeof w&&hu<=w;function Vc(w,O,_){return qc(w)&&qc(O)&&qc(_)&&O<=w&&w<_}function Jc(w,O,_,N){if(!Vc(O,_,N))throw Error(`expected valid ${w}: ${_} <= n < ${N}, got ${typeof O} ${O}`)}function Yc(w){let O;for(O=0;w>hu;w>>=lu,O+=1);return O}const Zc=w=>(fu<<BigInt(w-1))-lu,Wc=w=>new Uint8Array(w),$c=w=>Uint8Array.from(w);function Xc(w,O,_){if("number"!=typeof w||w<2)throw Error("hashLen must be a number");if("number"!=typeof O||O<2)throw Error("qByteLen must be a number");if("function"!=typeof _)throw Error("hmacFn must be a function");let N=Wc(w),F=Wc(w),H=0;const a=()=>{N.fill(1),F.fill(0),H=0},o=(...w)=>_(F,N,...w),c=(w=Wc())=>{F=o($c([0]),w),N=o(),0!==w.length&&(F=o($c([1]),w),N=o())},h=()=>{if(H++>=1e3)throw Error("drbg: tried 1000 values");let w=0;const _=[];for(;w<O;){N=o();const O=N.slice();_.push(O),w+=N.length}return jc(..._)};return(w,O)=>{let _;for(a(),c(w);!(_=O(h()));)c();return a(),_}}const pu={bigint:w=>"bigint"==typeof w,function:w=>"function"==typeof w,boolean:w=>"boolean"==typeof w,string:w=>"string"==typeof w,stringOrUint8Array:w=>"string"==typeof w||Uc(w),isSafeInteger:w=>Number.isSafeInteger(w),array:w=>Array.isArray(w),field:(w,O)=>O.Fp.isValid(w),hash:w=>"function"==typeof w&&Number.isSafeInteger(w.outputLen)};function th(w,O,_={}){const n=(O,_,N)=>{const F=pu[_];if("function"!=typeof F)throw Error(`Invalid validator "${_}", expected function`);const H=w[O];if(!(N&&void 0===H||F(H,w)))throw Error(`Invalid param ${O+""}=${H} (${typeof H}), expected ${_}`)};for(const[w,_]of Object.entries(O))n(w,_,!1);for(const[w,O]of Object.entries(_))n(w,O,!0);return w}function rh(w){const O=new WeakMap;return(_,...N)=>{const F=O.get(_);if(void 0!==F)return F;const H=w(_,...N);return O.set(_,H),H}}var gu=Object.freeze({__proto__:null,aInRange:Jc,abool:xc,abytes:Pc,bitGet:function(w,O){return w>>BigInt(O)&lu},bitLen:Yc,bitMask:Zc,bitSet:function(w,O,_){return w|(_?lu:hu)<<BigInt(O)},bytesToHex:Rc,bytesToNumberBE:Oc,bytesToNumberLE:Hc,concatBytes:jc,createHmacDrbg:Xc,ensureBytes:_c,equalBytes:function(w,O){if(w.length!==O.length)return!1;let _=0;for(let N=0;N<w.length;N++)_|=w[N]^O[N];return 0===_},hexToBytes:Fc,hexToNumber:Lc,inRange:Vc,isBytes:Uc,memoized:rh,notImplemented:()=>{throw Error("not implemented")},numberToBytesBE:zc,numberToBytesLE:Gc,numberToHexUnpadded:Tc,numberToVarBytesBE:function(w){return Fc(Tc(w))},utf8ToBytes:function(w){if("string"!=typeof w)throw Error("utf8ToBytes expected string, got "+typeof w);return new Uint8Array((new TextEncoder).encode(w))},validateObject:th});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const wu=BigInt(0),mu=BigInt(1),Au=BigInt(2),Su=BigInt(3),Iu=BigInt(4),Bu=BigInt(5),Cu=BigInt(8);function lh(w,O){const _=w%O;return _>=wu?_:O+_}function yh(w,O,_){if(_<=wu||O<wu)throw Error("Expected power/modulo > 0");if(_===mu)return wu;let N=mu;for(;O>wu;)O&mu&&(N=N*w%_),w=w*w%_,O>>=mu;return N}function fh(w,O,_){let N=w;for(;O-- >wu;)N*=N,N%=_;return N}function gh(w,O){if(w===wu||O<=wu)throw Error(`invert: expected positive integers, got n=${w} mod=${O}`);let _=lh(w,O),N=O,F=wu,H=mu;for(;_!==wu;){const w=N%_,O=F-H*(N/_);N=_,_=w,F=H,H=O}if(N!==mu)throw Error("invert: does not exist");return lh(F,O)}function ph(w){if(w%Iu===Su){const O=(w+mu)/Iu;return function(w,_){const N=w.pow(_,O);if(!w.eql(w.sqr(N),_))throw Error("Cannot find square root");return N}}if(w%Cu===Bu){const O=(w-Bu)/Cu;return function(w,_){const N=w.mul(_,Au),F=w.pow(N,O),H=w.mul(_,F),j=w.mul(w.mul(H,Au),F),G=w.mul(H,w.sub(j,w.ONE));if(!w.eql(w.sqr(G),_))throw Error("Cannot find square root");return G}}return function(w){const O=(w-mu)/Au;let _,N,F;for(_=w-mu,N=0;_%Au===wu;_/=Au,N++);for(F=Au;F<w&&yh(F,O,w)!==w-mu;F++);if(1===N){const O=(w+mu)/Iu;return function(w,_){const N=w.pow(_,O);if(!w.eql(w.sqr(N),_))throw Error("Cannot find square root");return N}}const H=(_+mu)/Au;return function(w,j){if(w.pow(j,O)===w.neg(w.ONE))throw Error("Cannot find square root");let G=N,z=w.pow(w.mul(w.ONE,F),_),X=w.pow(j,H),ee=w.pow(j,_);for(;!w.eql(ee,w.ONE);){if(w.eql(ee,w.ZERO))return w.ZERO;let O=1;for(let _=w.sqr(ee);O<G&&!w.eql(_,w.ONE);O++)_=w.sqr(_);const _=w.pow(z,mu<<BigInt(G-O-1));z=w.sqr(_),X=w.mul(X,_),ee=w.mul(ee,z),G=O}return X}}(w)}BigInt(9),BigInt(16);const Pu=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ah(w,O){const _=void 0!==O?O:w.toString(2).length;return{nBitLength:_,nByteLength:Math.ceil(_/8)}}function wh(w,O,_=!1,N={}){if(w<=wu)throw Error("Expected Field ORDER > 0, got "+w);const{nBitLength:F,nByteLength:H}=Ah(w,O);if(H>2048)throw Error("Field lengths over 2048 bytes are not supported");const j=ph(w),G=Object.freeze({ORDER:w,BITS:F,BYTES:H,MASK:Zc(F),ZERO:wu,ONE:mu,create:O=>lh(O,w),isValid:O=>{if("bigint"!=typeof O)throw Error("Invalid field element: expected bigint, got "+typeof O);return wu<=O&&O<w},is0:w=>w===wu,isOdd:w=>(w&mu)===mu,neg:O=>lh(-O,w),eql:(w,O)=>w===O,sqr:O=>lh(O*O,w),add:(O,_)=>lh(O+_,w),sub:(O,_)=>lh(O-_,w),mul:(O,_)=>lh(O*_,w),pow:(w,O)=>function(w,O,_){if(_<wu)throw Error("Expected power > 0");if(_===wu)return w.ONE;if(_===mu)return O;let N=w.ONE,F=O;for(;_>wu;)_&mu&&(N=w.mul(N,F)),F=w.sqr(F),_>>=mu;return N}(G,w,O),div:(O,_)=>lh(O*gh(_,w),w),sqrN:w=>w*w,addN:(w,O)=>w+O,subN:(w,O)=>w-O,mulN:(w,O)=>w*O,inv:O=>gh(O,w),sqrt:N.sqrt||(w=>j(G,w)),invertBatch:w=>function(w,O){const _=Array(O.length),N=O.reduce(((O,N,F)=>w.is0(N)?O:(_[F]=O,w.mul(O,N))),w.ONE),F=w.inv(N);return O.reduceRight(((O,N,F)=>w.is0(N)?O:(_[F]=w.mul(O,_[F]),w.mul(O,N))),F),_}(G,w),cmov:(w,O,_)=>_?O:w,toBytes:w=>_?Gc(w,H):zc(w,H),fromBytes:w=>{if(w.length!==H)throw Error(`Fp.fromBytes: expected ${H}, got ${w.length}`);return _?Hc(w):Oc(w)}});return Object.freeze(G)}function mh(w){if("bigint"!=typeof w)throw Error("field order must be bigint");const O=w.toString(2).length;return Math.ceil(O/8)}function bh(w){const O=mh(w);return O+Math.ceil(O/2)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ku=BigInt(0),Du=BigInt(1),Uu=new WeakMap,Ou=new WeakMap;function Bh(w,O){const r=(w,O)=>{const _=O.negate();return w?_:O},n=w=>{if(!Number.isSafeInteger(w)||w<=0||w>O)throw Error(`Wrong window size=${w}, should be [1..${O}]`)},i=w=>{n(w);return{windows:Math.ceil(O/w)+1,windowSize:2**(w-1)}};return{constTimeNegate:r,unsafeLadder(O,_){let N=w.ZERO,F=O;for(;_>Ku;)_&Du&&(N=N.add(F)),F=F.double(),_>>=Du;return N},precomputeWindow(w,O){const{windows:_,windowSize:N}=i(O),F=[];let H=w,j=H;for(let w=0;w<_;w++){j=H,F.push(j);for(let w=1;w<N;w++)j=j.add(H),F.push(j);H=j.double()}return F},wNAF(O,_,N){const{windows:F,windowSize:H}=i(O);let j=w.ZERO,G=w.BASE;const z=BigInt(2**O-1),X=2**O,ee=BigInt(O);for(let w=0;w<F;w++){const O=w*H;let F=Number(N&z);N>>=ee,F>H&&(F-=X,N+=Du);const se=O,ae=O+Math.abs(F)-1,Ae=w%2!=0,be=F<0;0===F?G=G.add(r(Ae,_[se])):j=j.add(r(be,_[ae]))}return{p:j,f:G}},wNAFCached(w,O,_){const N=Ou.get(w)||1;let F=Uu.get(w);return F||(F=this.precomputeWindow(w,N),1!==N&&Uu.set(w,_(F))),this.wNAF(N,F,O)},setWindowSize(w,O){n(O),Ou.set(w,O),Uu.delete(w)}}}function Sh(w,O,_,N){if(!Array.isArray(_)||!Array.isArray(N)||N.length!==_.length)throw Error("arrays of points and scalars must have equal length");N.forEach(((w,_)=>{if(!O.isValid(w))throw Error("wrong scalar at index "+_)})),_.forEach(((O,_)=>{if(!(O instanceof w))throw Error("wrong point at index "+_)}));const F=Yc(BigInt(_.length)),H=F>12?F-3:F>4?F-2:F?2:1,j=(1<<H)-1,G=Array(j+1).fill(w.ZERO),z=Math.floor((O.BITS-1)/H)*H;let X=w.ZERO;for(let O=z;O>=0;O-=H){G.fill(w.ZERO);for(let w=0;w<N.length;w++){const F=N[w],H=Number(F>>BigInt(O)&BigInt(j));G[H]=G[H].add(_[w])}let F=w.ZERO;for(let O=G.length-1,_=w.ZERO;O>0;O--)_=_.add(G[O]),F=F.add(_);if(X=X.add(F),0!==O)for(let w=0;w<H;w++)X=X.double()}return X}function Kh(w){return th(w.Fp,Pu.reduce(((w,O)=>(w[O]="function",w)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),th(w,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ah(w.n,w.nBitLength),...w,p:w.Fp.ORDER})}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ch(w){void 0!==w.lowS&&xc("lowS",w.lowS),void 0!==w.prehash&&xc("prehash",w.prehash)}const{bytesToNumberBE:_u,hexToBytes:Ru}=gu,Qu={Err:class extends Error{constructor(w=""){super(w)}},_tlv:{encode:(w,O)=>{const{Err:_}=Qu;if(w<0||w>256)throw new _("tlv.encode: wrong tag");if(1&O.length)throw new _("tlv.encode: unpadded data");const N=O.length/2,F=Tc(N);if(F.length/2&128)throw new _("tlv.encode: long form length too big");const H=N>127?Tc(F.length/2|128):"";return`${Tc(w)}${H}${F}${O}`},decode(w,O){const{Err:_}=Qu;let N=0;if(w<0||w>256)throw new _("tlv.encode: wrong tag");if(O.length<2||O[N++]!==w)throw new _("tlv.decode: wrong tlv");const F=O[N++];let H=0;if(!!(128&F)){const w=127&F;if(!w)throw new _("tlv.decode(long): indefinite length not supported");if(w>4)throw new _("tlv.decode(long): byte length is too big");const j=O.subarray(N,N+w);if(j.length!==w)throw new _("tlv.decode: length bytes not complete");if(0===j[0])throw new _("tlv.decode(long): zero leftmost byte");for(const w of j)H=H<<8|w;if(N+=w,H<128)throw new _("tlv.decode(long): not minimal encoding")}else H=F;const j=O.subarray(N,N+H);if(j.length!==H)throw new _("tlv.decode: wrong value length");return{v:j,l:O.subarray(N+H)}}},_int:{encode(w){const{Err:O}=Qu;if(w<Mu)throw new O("integer: negative integers are not allowed");let _=Tc(w);if(8&Number.parseInt(_[0],16)&&(_="00"+_),1&_.length)throw new O("unexpected assertion");return _},decode(w){const{Err:O}=Qu;if(128&w[0])throw new O("Invalid signature integer: negative");if(0===w[0]&&!(128&w[1]))throw new O("Invalid signature integer: unnecessary leading zero");return _u(w)}},toSig(w){const{Err:O,_int:_,_tlv:N}=Qu,F="string"==typeof w?Ru(w):w;Pc(F);const{v:H,l:j}=N.decode(48,F);if(j.length)throw new O("Invalid signature: left bytes after parsing");const{v:G,l:z}=N.decode(2,H),{v:X,l:ee}=N.decode(2,z);if(ee.length)throw new O("Invalid signature: left bytes after parsing");return{r:_.decode(G),s:_.decode(X)}},hexFromSig(w){const{_tlv:O,_int:_}=Qu,N=`${O.encode(2,_.encode(w.r))}${O.encode(2,_.encode(w.s))}`;return O.encode(48,N)}},Mu=BigInt(0),Lu=BigInt(1);BigInt(2);const Nu=BigInt(3);function Th(w){const O=function(w){const O=Kh(w);th(O,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:_,Fp:N,a:F}=O;if(_){if(!N.eql(F,N.ZERO))throw Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof _||"bigint"!=typeof _.beta||"function"!=typeof _.splitScalar)throw Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...O})}(w),{Fp:_}=O,N=wh(O.n,O.nBitLength),F=O.toBytes||((w,O,N)=>{const F=O.toAffine();return jc(Uint8Array.from([4]),_.toBytes(F.x),_.toBytes(F.y))}),H=O.fromBytes||(w=>{const O=w.subarray(1);return{x:_.fromBytes(O.subarray(0,_.BYTES)),y:_.fromBytes(O.subarray(_.BYTES,2*_.BYTES))}});function a(w){const{a:N,b:F}=O,H=_.sqr(w),j=_.mul(H,w);return _.add(_.add(j,_.mul(w,N)),F)}if(!_.eql(_.sqr(O.Gy),a(O.Gx)))throw Error("bad generator point: equation left != right");function o(w){const{allowedPrivateKeyLengths:_,nByteLength:N,wrapPrivateKey:F,n:H}=O;if(_&&"bigint"!=typeof w){if(Uc(w)&&(w=Rc(w)),"string"!=typeof w||!_.includes(w.length))throw Error("Invalid key");w=w.padStart(2*N,"0")}let j;try{j="bigint"==typeof w?w:Oc(_c("private key",w,N))}catch(O){throw Error(`private key must be ${N} bytes, hex or bigint, not ${typeof w}`)}return F&&(j=lh(j,H)),Jc("private key",j,Lu,H),j}function c(w){if(!(w instanceof l))throw Error("ProjectivePoint expected")}const j=rh(((w,O)=>{const{px:N,py:F,pz:H}=w;if(_.eql(H,_.ONE))return{x:N,y:F};const j=w.is0();null==O&&(O=j?_.ONE:_.inv(H));const G=_.mul(N,O),z=_.mul(F,O),X=_.mul(H,O);if(j)return{x:_.ZERO,y:_.ZERO};if(!_.eql(X,_.ONE))throw Error("invZ was invalid");return{x:G,y:z}})),G=rh((w=>{if(w.is0()){if(O.allowInfinityPoint&&!_.is0(w.py))return;throw Error("bad point: ZERO")}const{x:N,y:F}=w.toAffine();if(!_.isValid(N)||!_.isValid(F))throw Error("bad point: x or y not FE");const H=_.sqr(F),j=a(N);if(!_.eql(H,j))throw Error("bad point: equation left != right");if(!w.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0}));class l{constructor(w,O,N){if(this.px=w,this.py=O,this.pz=N,null==w||!_.isValid(w))throw Error("x required");if(null==O||!_.isValid(O))throw Error("y required");if(null==N||!_.isValid(N))throw Error("z required");Object.freeze(this)}static fromAffine(w){const{x:O,y:N}=w||{};if(!w||!_.isValid(O)||!_.isValid(N))throw Error("invalid affine point");if(w instanceof l)throw Error("projective point not allowed");const i=w=>_.eql(w,_.ZERO);return i(O)&&i(N)?l.ZERO:new l(O,N,_.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(w){const O=_.invertBatch(w.map((w=>w.pz)));return w.map(((w,_)=>w.toAffine(O[_]))).map(l.fromAffine)}static fromHex(w){const O=l.fromAffine(H(_c("pointHex",w)));return O.assertValidity(),O}static fromPrivateKey(w){return l.BASE.multiply(o(w))}static msm(w,O){return Sh(l,N,w,O)}_setWindowSize(w){X.setWindowSize(this,w)}assertValidity(){G(this)}hasEvenY(){const{y:w}=this.toAffine();if(_.isOdd)return!_.isOdd(w);throw Error("Field doesn't support isOdd")}equals(w){c(w);const{px:O,py:N,pz:F}=this,{px:H,py:j,pz:G}=w,z=_.eql(_.mul(O,G),_.mul(H,F)),X=_.eql(_.mul(N,G),_.mul(j,F));return z&&X}negate(){return new l(this.px,_.neg(this.py),this.pz)}double(){const{a:w,b:N}=O,F=_.mul(N,Nu),{px:H,py:j,pz:G}=this;let z=_.ZERO,X=_.ZERO,ee=_.ZERO,se=_.mul(H,H),ae=_.mul(j,j),Ae=_.mul(G,G),be=_.mul(H,j);return be=_.add(be,be),ee=_.mul(H,G),ee=_.add(ee,ee),z=_.mul(w,ee),X=_.mul(F,Ae),X=_.add(z,X),z=_.sub(ae,X),X=_.add(ae,X),X=_.mul(z,X),z=_.mul(be,z),ee=_.mul(F,ee),Ae=_.mul(w,Ae),be=_.sub(se,Ae),be=_.mul(w,be),be=_.add(be,ee),ee=_.add(se,se),se=_.add(ee,se),se=_.add(se,Ae),se=_.mul(se,be),X=_.add(X,se),Ae=_.mul(j,G),Ae=_.add(Ae,Ae),se=_.mul(Ae,be),z=_.sub(z,se),ee=_.mul(Ae,ae),ee=_.add(ee,ee),ee=_.add(ee,ee),new l(z,X,ee)}add(w){c(w);const{px:N,py:F,pz:H}=this,{px:j,py:G,pz:z}=w;let X=_.ZERO,ee=_.ZERO,se=_.ZERO;const ae=O.a,Ae=_.mul(O.b,Nu);let be=_.mul(N,j),ve=_.mul(F,G),Se=_.mul(H,z),Ie=_.add(N,F),Be=_.add(j,G);Ie=_.mul(Ie,Be),Be=_.add(be,ve),Ie=_.sub(Ie,Be),Be=_.add(N,H);let Pe=_.add(j,z);return Be=_.mul(Be,Pe),Pe=_.add(be,Se),Be=_.sub(Be,Pe),Pe=_.add(F,H),X=_.add(G,z),Pe=_.mul(Pe,X),X=_.add(ve,Se),Pe=_.sub(Pe,X),se=_.mul(ae,Be),X=_.mul(Ae,Se),se=_.add(X,se),X=_.sub(ve,se),se=_.add(ve,se),ee=_.mul(X,se),ve=_.add(be,be),ve=_.add(ve,be),Se=_.mul(ae,Se),Be=_.mul(Ae,Be),ve=_.add(ve,Se),Se=_.sub(be,Se),Se=_.mul(ae,Se),Be=_.add(Be,Se),be=_.mul(ve,Be),ee=_.add(ee,be),be=_.mul(Pe,Be),X=_.mul(Ie,X),X=_.sub(X,be),be=_.mul(Ie,ve),se=_.mul(Pe,se),se=_.add(se,be),new l(X,ee,se)}subtract(w){return this.add(w.negate())}is0(){return this.equals(l.ZERO)}wNAF(w){return X.wNAFCached(this,w,l.normalizeZ)}multiplyUnsafe(w){Jc("scalar",w,Mu,O.n);const N=l.ZERO;if(w===Mu)return N;if(w===Lu)return this;const{endo:F}=O;if(!F)return X.unsafeLadder(this,w);let{k1neg:H,k1:j,k2neg:G,k2:z}=F.splitScalar(w),ee=N,se=N,ae=this;for(;j>Mu||z>Mu;)j&Lu&&(ee=ee.add(ae)),z&Lu&&(se=se.add(ae)),ae=ae.double(),j>>=Lu,z>>=Lu;return H&&(ee=ee.negate()),G&&(se=se.negate()),se=new l(_.mul(se.px,F.beta),se.py,se.pz),ee.add(se)}multiply(w){const{endo:N,n:F}=O;let H,j;if(Jc("scalar",w,Lu,F),N){const{k1neg:O,k1:F,k2neg:G,k2:z}=N.splitScalar(w);let{p:ee,f:se}=this.wNAF(F),{p:ae,f:Ae}=this.wNAF(z);ee=X.constTimeNegate(O,ee),ae=X.constTimeNegate(G,ae),ae=new l(_.mul(ae.px,N.beta),ae.py,ae.pz),H=ee.add(ae),j=se.add(Ae)}else{const{p:O,f:_}=this.wNAF(w);H=O,j=_}return l.normalizeZ([H,j])[0]}multiplyAndAddUnsafe(w,O,_){const N=l.BASE,i=(w,O)=>O!==Mu&&O!==Lu&&w.equals(N)?w.multiply(O):w.multiplyUnsafe(O),F=i(this,O).add(i(w,_));return F.is0()?void 0:F}toAffine(w){return j(this,w)}isTorsionFree(){const{h:w,isTorsionFree:_}=O;if(w===Lu)return!0;if(_)return _(l,this);throw Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:w,clearCofactor:_}=O;return w===Lu?this:_?_(l,this):this.multiplyUnsafe(O.h)}toRawBytes(w=!0){return xc("isCompressed",w),this.assertValidity(),F(l,this,w)}toHex(w=!0){return xc("isCompressed",w),Rc(this.toRawBytes(w))}}l.BASE=new l(O.Gx,O.Gy,_.ONE),l.ZERO=new l(_.ZERO,_.ONE,_.ZERO);const z=O.nBitLength,X=Bh(l,O.endo?Math.ceil(z/2):z);return{CURVE:O,ProjectivePoint:l,normPrivateKeyToScalar:o,weierstrassEquation:a,isWithinCurveOrder:function(w){return Vc(w,Lu,O.n)}}}function Lh(w){const O=function(w){const O=Kh(w);return th(O,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...O})}(w),{Fp:_,n:N}=O,F=_.BYTES+1,H=2*_.BYTES+1;function a(w){return lh(w,N)}function o(w){return gh(w,N)}const{ProjectivePoint:j,normPrivateKeyToScalar:G,weierstrassEquation:z,isWithinCurveOrder:X}=Th({...O,toBytes(w,O,N){const F=O.toAffine(),H=_.toBytes(F.x),j=jc;return xc("isCompressed",N),N?j(Uint8Array.from([O.hasEvenY()?2:3]),H):j(Uint8Array.from([4]),H,_.toBytes(F.y))},fromBytes(w){const O=w.length,N=w[0],j=w.subarray(1);if(O!==F||2!==N&&3!==N){if(O===H&&4===N){return{x:_.fromBytes(j.subarray(0,_.BYTES)),y:_.fromBytes(j.subarray(_.BYTES,2*_.BYTES))}}throw Error(`Point of length ${O} was invalid. Expected ${F} compressed bytes or ${H} uncompressed bytes`)}{const O=Oc(j);if(!Vc(O,Lu,_.ORDER))throw Error("Point is not on curve");const F=z(O);let H;try{H=_.sqrt(F)}catch(w){const O=w instanceof Error?": "+w.message:"";throw Error("Point is not on curve"+O)}return!(1&~N)!==((H&Lu)===Lu)&&(H=_.neg(H)),{x:O,y:H}}}}),y=w=>Rc(zc(w,O.nByteLength));function f(w){return w>N>>Lu}const g=(w,O,_)=>Oc(w.slice(O,_));class p{constructor(w,O,_){this.r=w,this.s=O,this.recovery=_,this.assertValidity()}static fromCompact(w){const _=O.nByteLength;return w=_c("compactSignature",w,2*_),new p(g(w,0,_),g(w,_,2*_))}static fromDER(w){const{r:O,s:_}=Qu.toSig(_c("DER",w));return new p(O,_)}assertValidity(){Jc("r",this.r,Lu,N),Jc("s",this.s,Lu,N)}addRecoveryBit(w){return new p(this.r,this.s,w)}recoverPublicKey(w){const{r:N,s:F,recovery:H}=this,G=ae(_c("msgHash",w));if(null==H||![0,1,2,3].includes(H))throw Error("recovery id invalid");const z=2===H||3===H?N+O.n:N;if(z>=_.ORDER)throw Error("recovery id 2 or 3 invalid");const X=1&H?"03":"02",ee=j.fromHex(X+y(z)),se=o(z),Ae=a(-G*se),be=a(F*se),ve=j.BASE.multiplyAndAddUnsafe(ee,Ae,be);if(!ve)throw Error("point at infinify");return ve.assertValidity(),ve}hasHighS(){return f(this.s)}normalizeS(){return this.hasHighS()?new p(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return Fc(this.toDERHex())}toDERHex(){return Qu.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Fc(this.toCompactHex())}toCompactHex(){return y(this.r)+y(this.s)}}const ee={isValidPrivateKey(w){try{return G(w),!0}catch(w){return!1}},normPrivateKeyToScalar:G,randomPrivateKey:()=>{const w=bh(O.n);return function(w,O,_=!1){const N=w.length,F=mh(O),H=bh(O);if(N<16||N<H||N>1024)throw Error(`expected ${H}-1024 bytes of input, got ${N}`);const j=lh(_?Oc(w):Hc(w),O-mu)+mu;return _?Gc(j,F):zc(j,F)}(O.randomBytes(w),O.n)},precompute:(w=8,O=j.BASE)=>(O._setWindowSize(w),O.multiply(BigInt(3)),O)};function A(w){const O=Uc(w),_="string"==typeof w,N=(O||_)&&w.length;return O?N===F||N===H:_?N===2*F||N===2*H:w instanceof j}const se=O.bits2int||function(w){const _=Oc(w),N=8*w.length-O.nBitLength;return N>0?_>>BigInt(N):_},ae=O.bits2int_modN||function(w){return a(se(w))},Ae=Zc(O.nBitLength);function k(w){return Jc("num < 2^"+O.nBitLength,w,Mu,Ae),zc(w,O.nByteLength)}function E(w,N,F=be){if(["recovered","canonical"].some((w=>w in F)))throw Error("sign() legacy options not supported");const{hash:H,randomBytes:z}=O;let{lowS:ee,prehash:Ae,extraEntropy:ve}=F;null==ee&&(ee=!0),w=_c("msgHash",w),Ch(F),Ae&&(w=_c("prehashed msgHash",H(w)));const Se=ae(w),Ie=G(N),Be=[k(Ie),k(Se)];if(null!=ve&&!1!==ve){const w=!0===ve?z(_.BYTES):ve;Be.push(_c("extraEntropy",w))}const Pe=jc(...Be),xe=Se;return{seed:Pe,k2sig:function(w){const O=se(w);if(!X(O))return;const _=o(O),N=j.BASE.multiply(O).toAffine(),F=a(N.x);if(F===Mu)return;const H=a(_*a(xe+F*Ie));if(H===Mu)return;let G=(N.x===F?0:2)|Number(N.y&Lu),z=H;return ee&&f(H)&&(z=function(w){return f(w)?a(-w):w}(H),G^=1),new p(F,z,G)}}}const be={lowS:O.lowS,prehash:!1},ve={lowS:O.lowS,prehash:!1};return j.BASE._setWindowSize(8),{CURVE:O,getPublicKey:function(w,O=!0){return j.fromPrivateKey(w).toRawBytes(O)},getSharedSecret:function(w,O,_=!0){if(A(w))throw Error("first arg must be private key");if(!A(O))throw Error("second arg must be public key");return j.fromHex(O).multiply(G(w)).toRawBytes(_)},sign:function(w,_,N=be){const{seed:F,k2sig:H}=E(w,_,N),j=O;return Xc(j.hash.outputLen,j.nByteLength,j.hmac)(F,H)},verify:function(w,_,N,F=ve){const H=w;if(_=_c("msgHash",_),N=_c("publicKey",N),"strict"in F)throw Error("options.strict was renamed to lowS");Ch(F);const{lowS:G,prehash:z}=F;let X,ee;try{if("string"==typeof H||Uc(H))try{X=p.fromDER(H)}catch(w){if(!(w instanceof Qu.Err))throw w;X=p.fromCompact(H)}else{if("object"!=typeof H||"bigint"!=typeof H.r||"bigint"!=typeof H.s)throw Error("PARSE");{const{r:w,s:O}=H;X=new p(w,O)}}ee=j.fromHex(N)}catch(w){if("PARSE"===w.message)throw Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(G&&X.hasHighS())return!1;z&&(_=O.hash(_));const{r:se,s:Ae}=X,be=ae(_),Se=o(Ae),Ie=a(be*Se),Be=a(se*Se),Pe=j.BASE.multiplyAndAddUnsafe(ee,Ie,Be)?.toAffine();return!!Pe&&a(Pe.x)===se},ProjectivePoint:j,Signature:p,utils:ee}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Mh(w){return{hash:w,hmac:(O,..._)=>Sc(w,O,lc(..._)),randomBytes:gc}}function Nh(w,O){const r=O=>Lh({...w,...Mh(O)});return Object.freeze({...r(O),create:r})}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */BigInt(4);const Fu=wh(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),Hu=Nh({a:Fu.create(BigInt("-3")),b:BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Fp:Fu,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},cu),ju=BigInt(2**32-1),Gu=BigInt(32);function Gh(w,O=!1){return O?{h:Number(w&ju),l:Number(w>>Gu&ju)}:{h:0|Number(w>>Gu&ju),l:0|Number(w&ju)}}function _h(w,O=!1){let _=new Uint32Array(w.length),N=new Uint32Array(w.length);for(let F=0;F<w.length;F++){const{h:H,l:j}=Gh(w[F],O);[_[F],N[F]]=[H,j]}return[_,N]}const jh=(w,O,_)=>w<<_|O>>>32-_,qh=(w,O,_)=>O<<_|w>>>32-_,Vh=(w,O,_)=>O<<_-32|w>>>64-_,Jh=(w,O,_)=>w<<_-32|O>>>64-_;const zu={fromBig:Gh,split:_h,toBig:(w,O)=>BigInt(w>>>0)<<Gu|BigInt(O>>>0),shrSH:(w,O,_)=>w>>>_,shrSL:(w,O,_)=>w<<32-_|O>>>_,rotrSH:(w,O,_)=>w>>>_|O<<32-_,rotrSL:(w,O,_)=>w<<32-_|O>>>_,rotrBH:(w,O,_)=>w<<64-_|O>>>_-32,rotrBL:(w,O,_)=>w>>>_-32|O<<64-_,rotr32H:(w,O)=>O,rotr32L:(w,O)=>w,rotlSH:jh,rotlSL:qh,rotlBH:Vh,rotlBL:Jh,add:function(w,O,_,N){const F=(O>>>0)+(N>>>0);return{h:w+_+(F/2**32|0)|0,l:0|F}},add3L:(w,O,_)=>(w>>>0)+(O>>>0)+(_>>>0),add3H:(w,O,_,N)=>O+_+N+(w/2**32|0)|0,add4L:(w,O,_,N)=>(w>>>0)+(O>>>0)+(_>>>0)+(N>>>0),add4H:(w,O,_,N,F)=>O+_+N+F+(w/2**32|0)|0,add5H:(w,O,_,N,F,H)=>O+_+N+F+H+(w/2**32|0)|0,add5L:(w,O,_,N,F)=>(w>>>0)+(O>>>0)+(_>>>0)+(N>>>0)+(F>>>0)},[$u,Ju]=(()=>zu.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((w=>BigInt(w)))))(),Yu=new Uint32Array(80),Wu=new Uint32Array(80);class eu extends Ac{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:w,Al:O,Bh:_,Bl:N,Ch:F,Cl:H,Dh:j,Dl:G,Eh:z,El:X,Fh:ee,Fl:se,Gh:ae,Gl:Ae,Hh:be,Hl:ve}=this;return[w,O,_,N,F,H,j,G,z,X,ee,se,ae,Ae,be,ve]}set(w,O,_,N,F,H,j,G,z,X,ee,se,ae,Ae,be,ve){this.Ah=0|w,this.Al=0|O,this.Bh=0|_,this.Bl=0|N,this.Ch=0|F,this.Cl=0|H,this.Dh=0|j,this.Dl=0|G,this.Eh=0|z,this.El=0|X,this.Fh=0|ee,this.Fl=0|se,this.Gh=0|ae,this.Gl=0|Ae,this.Hh=0|be,this.Hl=0|ve}process(w,O){for(let _=0;_<16;_++,O+=4)Yu[_]=w.getUint32(O),Wu[_]=w.getUint32(O+=4);for(let w=16;w<80;w++){const O=0|Yu[w-15],_=0|Wu[w-15],N=zu.rotrSH(O,_,1)^zu.rotrSH(O,_,8)^zu.shrSH(O,_,7),F=zu.rotrSL(O,_,1)^zu.rotrSL(O,_,8)^zu.shrSL(O,_,7),H=0|Yu[w-2],j=0|Wu[w-2],G=zu.rotrSH(H,j,19)^zu.rotrBH(H,j,61)^zu.shrSH(H,j,6),z=zu.rotrSL(H,j,19)^zu.rotrBL(H,j,61)^zu.shrSL(H,j,6),X=zu.add4L(F,z,Wu[w-7],Wu[w-16]),ee=zu.add4H(X,N,G,Yu[w-7],Yu[w-16]);Yu[w]=0|ee,Wu[w]=0|X}let{Ah:_,Al:N,Bh:F,Bl:H,Ch:j,Cl:G,Dh:z,Dl:X,Eh:ee,El:se,Fh:ae,Fl:Ae,Gh:be,Gl:ve,Hh:Se,Hl:Ie}=this;for(let w=0;w<80;w++){const O=zu.rotrSH(ee,se,14)^zu.rotrSH(ee,se,18)^zu.rotrBH(ee,se,41),Be=zu.rotrSL(ee,se,14)^zu.rotrSL(ee,se,18)^zu.rotrBL(ee,se,41),Pe=ee&ae^~ee&be,xe=se&Ae^~se&ve,De=zu.add5L(Ie,Be,xe,Ju[w],Wu[w]),Ue=zu.add5H(De,Se,O,Pe,$u[w],Yu[w]),Oe=0|De,_e=zu.rotrSH(_,N,28)^zu.rotrBH(_,N,34)^zu.rotrBH(_,N,39),Re=zu.rotrSL(_,N,28)^zu.rotrBL(_,N,34)^zu.rotrBL(_,N,39),Te=_&F^_&j^F&j,Qe=N&H^N&G^H&G;Se=0|be,Ie=0|ve,be=0|ae,ve=0|Ae,ae=0|ee,Ae=0|se,({h:ee,l:se}=zu.add(0|z,0|X,0|Ue,0|Oe)),z=0|j,X=0|G,j=0|F,G=0|H,F=0|_,H=0|N;const Me=zu.add3L(Oe,Re,Qe);_=zu.add3H(Me,Ue,_e,Te),N=0|Me}({h:_,l:N}=zu.add(0|this.Ah,0|this.Al,0|_,0|N)),({h:F,l:H}=zu.add(0|this.Bh,0|this.Bl,0|F,0|H)),({h:j,l:G}=zu.add(0|this.Ch,0|this.Cl,0|j,0|G)),({h:z,l:X}=zu.add(0|this.Dh,0|this.Dl,0|z,0|X)),({h:ee,l:se}=zu.add(0|this.Eh,0|this.El,0|ee,0|se)),({h:ae,l:Ae}=zu.add(0|this.Fh,0|this.Fl,0|ae,0|Ae)),({h:be,l:ve}=zu.add(0|this.Gh,0|this.Gl,0|be,0|ve)),({h:Se,l:Ie}=zu.add(0|this.Hh,0|this.Hl,0|Se,0|Ie)),this.set(_,N,F,H,j,G,z,X,ee,se,ae,Ae,be,ve,Se,Ie)}roundClean(){Yu.fill(0),Wu.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class tu extends eu{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const Zu=fc((()=>new eu)),Xu=fc((()=>new tu)),eh=wh(BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff")),nh=Nh({a:eh.create(BigInt("-3")),b:BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Fp:eh,n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),h:BigInt(1),lowS:!1},Xu),ih=wh(BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")),sh={a:ih.create(BigInt("-3")),b:BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),Fp:ih,n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"),h:BigInt(1)},ah=Nh({a:sh.a,b:sh.b,Fp:ih,n:sh.n,Gx:sh.Gx,Gy:sh.Gy,h:sh.h,lowS:!1,allowedPrivateKeyLengths:[130,131,132]},Zu),oh=[],ch=[],uh=[],hh=BigInt(0),dh=BigInt(1),vh=BigInt(2),Eh=BigInt(7),kh=BigInt(256),Ih=BigInt(113);for(let w=0,O=dh,_=1,N=0;w<24;w++){[_,N]=[N,(2*_+3*N)%5],oh.push(2*(5*N+_)),ch.push((w+1)*(w+2)/2%64);let F=hh;for(let w=0;w<7;w++)O=(O<<dh^(O>>Eh)*Ih)%kh,O&vh&&(F^=dh<<(dh<<BigInt(w))-dh);uh.push(F)}const[Ph,xh]=_h(uh,!0),bu=(w,O,_)=>_>32?Vh(w,O,_):jh(w,O,_),ku=(w,O,_)=>_>32?Jh(w,O,_):qh(w,O,_);class Eu extends yc{constructor(w,O,_,N=!1,F=24){if(super(),this.blockLen=w,this.suffix=O,this.outputLen=_,this.enableXOF=N,this.rounds=F,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Xo(_),0>=this.blockLen||this.blockLen>=200)throw Error("Sha3 supports only keccak-f1600 function");var H;this.state=new Uint8Array(200),this.state32=(H=this.state,new Uint32Array(H.buffer,H.byteOffset,Math.floor(H.byteLength/4)))}keccak(){iu||cc(this.state32),function(w,O=24){const _=new Uint32Array(10);for(let N=24-O;N<24;N++){for(let O=0;O<10;O++)_[O]=w[O]^w[O+10]^w[O+20]^w[O+30]^w[O+40];for(let O=0;O<10;O+=2){const N=(O+8)%10,F=(O+2)%10,H=_[F],j=_[F+1],G=bu(H,j,1)^_[N],z=ku(H,j,1)^_[N+1];for(let _=0;_<50;_+=10)w[O+_]^=G,w[O+_+1]^=z}let O=w[2],F=w[3];for(let _=0;_<24;_++){const N=ch[_],H=bu(O,F,N),j=ku(O,F,N),G=oh[_];O=w[G],F=w[G+1],w[G]=H,w[G+1]=j}for(let O=0;O<50;O+=10){for(let N=0;N<10;N++)_[N]=w[O+N];for(let N=0;N<10;N++)w[O+N]^=~_[(N+2)%10]&_[(N+4)%10]}w[0]^=Ph[N],w[1]^=xh[N]}_.fill(0)}(this.state32,this.rounds),iu||cc(this.state32),this.posOut=0,this.pos=0}update(w){tc(this);const{blockLen:O,state:_}=this,N=(w=uc(w)).length;for(let F=0;F<N;){const H=Math.min(O-this.pos,N-F);for(let O=0;O<H;O++)_[this.pos++]^=w[F++];this.pos===O&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:w,suffix:O,pos:_,blockLen:N}=this;w[_]^=O,128&O&&_===N-1&&this.keccak(),w[N-1]^=128,this.keccak()}writeInto(w){tc(this,!1),ec(w),this.finish();const O=this.state,{blockLen:_}=this;for(let N=0,F=w.length;N<F;){this.posOut>=_&&this.keccak();const H=Math.min(_-this.posOut,F-N);w.set(O.subarray(this.posOut,this.posOut+H),N),this.posOut+=H,N+=H}return w}xofInto(w){if(!this.enableXOF)throw Error("XOF is not possible for this instance");return this.writeInto(w)}xof(w){return Xo(w),this.xofInto(new Uint8Array(w))}digestInto(w){if(rc(w,this),this.finished)throw Error("digest() was already called");return this.writeInto(w),this.destroy(),w}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(w){const{blockLen:O,suffix:_,outputLen:N,rounds:F,enableXOF:H}=this;return w||(w=new Eu(O,_,N,H,F)),w.state32.set(this.state32),w.pos=this.pos,w.posOut=this.posOut,w.finished=this.finished,w.rounds=F,w.suffix=_,w.outputLen=N,w.enableXOF=H,w.destroyed=this.destroyed,w}}const vu=(w,O,_)=>fc((()=>new Eu(O,w,_))),Dh=vu(6,136,32),Uh=vu(6,72,64),Oh=((w,O,_)=>function(w){const t=(O,_)=>w(_).update(uc(O)).digest(),O=w({});return t.outputLen=O.outputLen,t.blockLen=O.blockLen,t.create=O=>w(O),t}(((N={})=>new Eu(O,w,void 0===N.dkLen?_:N.dkLen,!0))))(31,136,32),Rh=BigInt(0),Qh=BigInt(1),Fh=BigInt(2),Hh=BigInt(8),zh={zip215:!0};function xu(w){const O=function(w){const O=Kh(w);return th(w,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...O})}(w),{Fp:_,n:N,prehash:F,hash:H,randomBytes:j,nByteLength:G,h:z}=O,X=Fh<<BigInt(8*G)-Qh,ee=_.create,se=wh(O.n,O.nBitLength),ae=O.uvRatio||((w,O)=>{try{return{isValid:!0,value:_.sqrt(w*_.inv(O))}}catch(w){return{isValid:!1,value:Rh}}}),Ae=O.adjustScalarBytes||(w=>w),be=O.domain||((w,O,_)=>{if(xc("phflag",_),O.length||_)throw Error("Contexts/pre-hash are not supported");return w});function p(w,O){Jc("coordinate "+w,O,Rh,X)}function d(w){if(!(w instanceof m))throw Error("ExtendedPoint expected")}const ve=rh(((w,O)=>{const{ex:N,ey:F,ez:H}=w,j=w.is0();null==O&&(O=j?Hh:_.inv(H));const G=ee(N*O),z=ee(F*O),X=ee(H*O);if(j)return{x:Rh,y:Qh};if(X!==Qh)throw Error("invZ was invalid");return{x:G,y:z}})),Se=rh((w=>{const{a:_,d:N}=O;if(w.is0())throw Error("bad point: ZERO");const{ex:F,ey:H,ez:j,et:G}=w,z=ee(F*F),X=ee(H*H),se=ee(j*j),ae=ee(se*se),Ae=ee(z*_);if(ee(se*ee(Ae+X))!==ee(ae+ee(N*ee(z*X))))throw Error("bad point: equation left != right (1)");if(ee(F*H)!==ee(j*G))throw Error("bad point: equation left != right (2)");return!0}));class m{constructor(w,O,_,N){this.ex=w,this.ey=O,this.ez=_,this.et=N,p("x",w),p("y",O),p("z",_),p("t",N),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(w){if(w instanceof m)throw Error("extended point not allowed");const{x:O,y:_}=w||{};return p("x",O),p("y",_),new m(O,_,Qh,ee(O*_))}static normalizeZ(w){const O=_.invertBatch(w.map((w=>w.ez)));return w.map(((w,_)=>w.toAffine(O[_]))).map(m.fromAffine)}static msm(w,O){return Sh(m,se,w,O)}_setWindowSize(w){Pe.setWindowSize(this,w)}assertValidity(){Se(this)}equals(w){d(w);const{ex:O,ey:_,ez:N}=this,{ex:F,ey:H,ez:j}=w,G=ee(O*j),z=ee(F*N),X=ee(_*j),se=ee(H*N);return G===z&&X===se}is0(){return this.equals(m.ZERO)}negate(){return new m(ee(-this.ex),this.ey,this.ez,ee(-this.et))}double(){const{a:w}=O,{ex:_,ey:N,ez:F}=this,H=ee(_*_),j=ee(N*N),G=ee(Fh*ee(F*F)),z=ee(w*H),X=_+N,se=ee(ee(X*X)-H-j),ae=z+j,Ae=ae-G,be=z-j,ve=ee(se*Ae),Se=ee(ae*be),Ie=ee(se*be),Be=ee(Ae*ae);return new m(ve,Se,Be,Ie)}add(w){d(w);const{a:_,d:N}=O,{ex:F,ey:H,ez:j,et:G}=this,{ex:z,ey:X,ez:se,et:ae}=w;if(_===BigInt(-1)){const w=ee((H-F)*(X+z)),O=ee((H+F)*(X-z)),_=ee(O-w);if(_===Rh)return this.double();const N=ee(j*Fh*ae),Ae=ee(G*Fh*se),be=Ae+N,ve=O+w,Se=Ae-N,Ie=ee(be*_),Be=ee(ve*Se),Pe=ee(be*Se),xe=ee(_*ve);return new m(Ie,Be,xe,Pe)}const Ae=ee(F*z),be=ee(H*X),ve=ee(G*N*ae),Se=ee(j*se),Ie=ee((F+H)*(z+X)-Ae-be),Be=Se-ve,Pe=Se+ve,xe=ee(be-_*Ae),De=ee(Ie*Be),Ue=ee(Pe*xe),Oe=ee(Ie*xe),_e=ee(Be*Pe);return new m(De,Ue,_e,Oe)}subtract(w){return this.add(w.negate())}wNAF(w){return Pe.wNAFCached(this,w,m.normalizeZ)}multiply(w){const O=w;Jc("scalar",O,Qh,N);const{p:_,f:F}=this.wNAF(O);return m.normalizeZ([_,F])[0]}multiplyUnsafe(w){const O=w;return Jc("scalar",O,Rh,N),O===Rh?Be:this.equals(Be)||O===Qh?this:this.equals(Ie)?this.wNAF(O).p:Pe.unsafeLadder(this,O)}isSmallOrder(){return this.multiplyUnsafe(z).is0()}isTorsionFree(){return Pe.unsafeLadder(this,N).is0()}toAffine(w){return ve(this,w)}clearCofactor(){const{h:w}=O;return w===Qh?this:this.multiplyUnsafe(w)}static fromHex(w,N=!1){const{d:F,a:H}=O,j=_.BYTES;w=_c("pointHex",w,j),xc("zip215",N);const G=w.slice(),z=w[j-1];G[j-1]=-129&z;const se=Hc(G),Ae=N?X:_.ORDER;Jc("pointHex.y",se,Rh,Ae);const be=ee(se*se),ve=ee(be-Qh),Se=ee(F*be-H);let{isValid:Ie,value:Be}=ae(ve,Se);if(!Ie)throw Error("Point.fromHex: invalid y coordinate");const Pe=(Be&Qh)===Qh,xe=!!(128&z);if(!N&&Be===Rh&&xe)throw Error("Point.fromHex: x=0 and x_0=1");return xe!==Pe&&(Be=ee(-Be)),m.fromAffine({x:Be,y:se})}static fromPrivateKey(w){return B(w).point}toRawBytes(){const{x:w,y:O}=this.toAffine(),N=Gc(O,_.BYTES);return N[N.length-1]|=w&Qh?128:0,N}toHex(){return Rc(this.toRawBytes())}}m.BASE=new m(O.Gx,O.Gy,Qh,ee(O.Gx*O.Gy)),m.ZERO=new m(Rh,Qh,Qh,Rh);const{BASE:Ie,ZERO:Be}=m,Pe=Bh(m,8*G);function v(w){return lh(w,N)}function I(w){return v(Hc(w))}function B(w){const O=G;w=_c("private key",w,O);const _=_c("hashed private key",H(w),2*O),N=Ae(_.slice(0,O)),F=_.slice(O,2*O),j=I(N),z=Ie.multiply(j),X=z.toRawBytes();return{head:N,prefix:F,scalar:j,point:z,pointBytes:X}}function S(w=new Uint8Array,...O){const _=jc(...O);return I(H(be(_,_c("context",w),!!F)))}const xe=zh;Ie._setWindowSize(8);return{CURVE:O,getPublicKey:function(w){return B(w).pointBytes},sign:function(w,O,H={}){w=_c("message",w),F&&(w=F(w));const{prefix:j,scalar:z,pointBytes:X}=B(O),ee=S(H.context,j,w),se=Ie.multiply(ee).toRawBytes(),ae=v(ee+S(H.context,se,X,w)*z);return Jc("signature.s",ae,Rh,N),_c("result",jc(se,Gc(ae,_.BYTES)),2*G)},verify:function(w,O,N,H=xe){const{context:j,zip215:G}=H,z=_.BYTES;w=_c("signature",w,2*z),O=_c("message",O),void 0!==G&&xc("zip215",G),F&&(O=F(O));const X=Hc(w.slice(z,2*z));let ee,se,ae;try{ee=m.fromHex(N,G),se=m.fromHex(w.slice(0,z),G),ae=Ie.multiplyUnsafe(X)}catch(w){return!1}if(!G&&ee.isSmallOrder())return!1;const Ae=S(j,se.toRawBytes(),ee.toRawBytes(),O);return se.add(ee.multiplyUnsafe(Ae)).subtract(ae).clearCofactor().equals(m.ZERO)},ExtendedPoint:m,utils:{getExtendedPublicKey:B,randomPrivateKey:()=>j(_.BYTES),precompute:(w=8,O=m.BASE)=>(O._setWindowSize(w),O.multiply(BigInt(3)),O)}}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const $h=BigInt(0),Yh=BigInt(1);function Tu(w){const O=(th(_=w,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({..._}));var _;const{P:N}=O,i=w=>lh(w,N),F=O.montgomeryBits,H=Math.ceil(F/8),j=O.nByteLength,G=O.adjustScalarBytes||(w=>w),z=O.powPminus2||(w=>yh(w,N-BigInt(2),N));function u(w,O,_){const N=i(w*(O-_));return[O=i(O-N),_=i(_+N)]}const X=(O.a-BigInt(2))/BigInt(4);function y(w){return Gc(i(w),H)}function f(w,O){const _=function(w){const O=_c("u coordinate",w,H);return 32===j&&(O[31]&=127),Hc(O)}(O),ee=function(w){const O=_c("scalar",w),_=O.length;if(_!==H&&_!==j)throw Error(`Expected ${H} or ${j} bytes, got ${_}`);return Hc(G(O))}(w),se=function(w,O){Jc("u",w,$h,N),Jc("scalar",O,$h,N);const _=O,H=w;let j,G=Yh,ee=$h,se=w,ae=Yh,Ae=$h;for(let w=BigInt(F-1);w>=$h;w--){const O=_>>w&Yh;Ae^=O,j=u(Ae,G,se),G=j[0],se=j[1],j=u(Ae,ee,ae),ee=j[0],ae=j[1],Ae=O;const N=G+ee,F=i(N*N),z=G-ee,be=i(z*z),ve=F-be,Se=se+ae,Ie=i((se-ae)*N),Be=i(Se*z),Pe=Ie+Be,xe=Ie-Be;se=i(Pe*Pe),ae=i(H*i(xe*xe)),G=i(F*be),ee=i(ve*(F+i(X*ve)))}j=u(Ae,G,se),G=j[0],se=j[1],j=u(Ae,ee,ae),ee=j[0],ae=j[1];const be=z(ee);return i(G*be)}(_,ee);if(se===$h)throw Error("Invalid private or public key received");return y(se)}const ee=y(O.Gu);function p(w){return f(w,ee)}return{scalarMult:f,scalarMultBase:p,getSharedSecret:(w,O)=>f(w,O),getPublicKey:w=>p(w),utils:{randomPrivateKey:()=>O.randomBytes(O.nByteLength)},GuBytes:ee}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Wh=fc((()=>Oh.create({dkLen:114}))),Zh=(fc((()=>Oh.create({dkLen:64}))),BigInt("726838724295606890549323807888004534353641360687318060281490199180612328166730772686396383698676545930088884461843637361053498018365439")),Xh=BigInt(1),el=BigInt(2),tl=BigInt(3);BigInt(4);const nl=BigInt(11),il=BigInt(22),sl=BigInt(44),al=BigInt(88),ol=BigInt(223);function qu(w){const O=Zh,_=w*w*w%O,N=_*_*w%O,F=fh(N,tl,O)*N%O,H=fh(F,tl,O)*N%O,j=fh(H,el,O)*_%O,G=fh(j,nl,O)*j%O,z=fh(G,il,O)*G%O,X=fh(z,sl,O)*z%O,ee=fh(X,al,O)*X%O,se=fh(ee,sl,O)*z%O,ae=fh(se,el,O)*_%O,Ae=fh(ae,Xh,O)*w%O;return fh(Ae,ol,O)*ae%O}function Vu(w){return w[0]&=252,w[55]|=128,w[56]=0,w}const cl=wh(Zh,456,!0),ul={a:BigInt(1),d:BigInt("726838724295606890549323807888004534353641360687318060281490199180612328166730772686396383698676545930088884461843637361053498018326358"),Fp:cl,n:BigInt("181709681073901722637330951972001133588410340171829515070372549795146003961539585716195755291692375963310293709091662304773755859649779"),nBitLength:456,h:BigInt(4),Gx:BigInt("224580040295924300187604334099896036246789641632564134246125461686950415467406032909029192869357953282578032075146446173674602635247710"),Gy:BigInt("298819210078481492676017930443930673437544040154080242095928241372331506189835876003536878655418784733982303233503462500531545062832660"),hash:Wh,randomBytes:gc,adjustScalarBytes:Vu,domain:(w,O,_)=>{if(O.length>255)throw Error("Context is too big: "+O.length);return lc(hc("SigEd448"),new Uint8Array([_?1:0,O.length]),O,w)},uvRatio:function(w,O){const _=Zh,N=lh(w*w*O,_),F=lh(N*w,_),H=lh(F*N*O,_),j=lh(F*qu(H),_),G=lh(j*j,_);return{isValid:lh(G*O,_)===w,value:j}}},hl=xu(ul),ll=(()=>Tu({a:BigInt(156326),montgomeryBits:448,nByteLength:56,P:Zh,Gu:BigInt(5),powPminus2:w=>{const O=Zh;return lh(fh(qu(w),BigInt(2),O)*w,O)},adjustScalarBytes:Vu,randomBytes:gc}))();cl.ORDER,BigInt(3),BigInt(4),BigInt(156326),BigInt("39082"),BigInt("78163"),BigInt("98944233647732219769177004876929019128417576295529901074099889598043702116001257856802131563896515373927712232092845883226922417596214"),BigInt("315019913931389607337177038330951043522456072897266928557328499619017160722351061360252776265186336876723201881398623946864393857820716"),BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const fl=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),yl=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),dl=BigInt(1),gl=BigInt(2),rl=(w,O)=>(w+O/gl)/O;const wl=wh(fl,void 0,void 0,{sqrt:function(w){const O=fl,_=BigInt(3),N=BigInt(6),F=BigInt(11),H=BigInt(22),j=BigInt(23),G=BigInt(44),z=BigInt(88),X=w*w*w%O,ee=X*X*w%O,se=fh(ee,_,O)*ee%O,ae=fh(se,_,O)*ee%O,Ae=fh(ae,gl,O)*X%O,be=fh(Ae,F,O)*Ae%O,ve=fh(be,H,O)*be%O,Se=fh(ve,G,O)*ve%O,Ie=fh(Se,z,O)*Se%O,Be=fh(Ie,G,O)*ve%O,Pe=fh(Be,_,O)*ee%O,xe=fh(Pe,j,O)*be%O,De=fh(xe,N,O)*X%O,Ue=fh(De,gl,O);if(!wl.eql(wl.sqr(Ue),w))throw Error("Cannot find square root");return Ue}}),ml=Nh({a:BigInt(0),b:BigInt(7),Fp:wl,n:yl,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:w=>{const O=yl,_=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),N=-dl*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),F=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),H=_,j=BigInt("0x100000000000000000000000000000000"),G=rl(H*w,O),z=rl(-N*w,O);let X=lh(w-G*_-z*F,O),ee=lh(-G*N-z*H,O);const se=X>j,ae=ee>j;if(se&&(X=O-X),ae&&(ee=O-ee),X>j||ee>j)throw Error("splitScalar: Endomorphism failed, k="+w);return{k1neg:se,k1:X,k2neg:ae,k2:ee}}}},cu);BigInt(0),ml.ProjectivePoint;const Al=wh(BigInt("0xa9fb57dba1eea9bc3e660a909d838d726e3bf623d52620282013481d1f6e5377")),bl=Nh({a:Al.create(BigInt("0x7d5a0975fc2c3057eef67530417affe7fb8055c126dc5c6ce94a4b44f330b5d9")),b:BigInt("0x26dc5c6ce94a4b44f330b5d9bbd77cbf958416295cf7e1ce6bccdc18ff8c07b6"),Fp:Al,n:BigInt("0xa9fb57dba1eea9bc3e660a909d838d718c397aa3b561a6f7901e0e82974856a7"),Gx:BigInt("0x8bd2aeb9cb7e57cb2c4b482ffc81b7afb9de27e1e3bd23c23a4453bd9ace3262"),Gy:BigInt("0x547ef835c3dac4fd97f8461a14611dc9c27745132ded8e545c1d54c72f046997"),h:BigInt(1),lowS:!1},cu),vl=wh(BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b412b1da197fb71123acd3a729901d1a71874700133107ec53")),El=Nh({a:vl.create(BigInt("0x7bc382c63d8c150c3c72080ace05afa0c2bea28e4fb22787139165efba91f90f8aa5814a503ad4eb04a8c7dd22ce2826")),b:BigInt("0x04a8c7dd22ce28268b39b55416f0447c2fb77de107dcd2a62e880ea53eeb62d57cb4390295dbc9943ab78696fa504c11"),Fp:vl,n:BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b31f166e6cac0425a7cf3ab6af6b7fc3103b883202e9046565"),Gx:BigInt("0x1d1c64f068cf45ffa2a63a81b7c13f6b8847a3e77ef14fe3db7fcafe0cbd10e8e826e03436d646aaef87b2e247d4af1e"),Gy:BigInt("0x8abe1d7520f9c2a45cb1eb8e95cfd55262b70b29feec5864e19c054ff99129280e4646217791811142820341263c5315"),h:BigInt(1),lowS:!1},Xu),kl=wh(BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca703308717d4d9b009bc66842aecda12ae6a380e62881ff2f2d82c68528aa6056583a48f3")),Sl=Nh({a:kl.create(BigInt("0x7830a3318b603b89e2327145ac234cc594cbdd8d3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94ca")),b:BigInt("0x3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94cadc083e67984050b75ebae5dd2809bd638016f723"),Fp:kl,n:BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca70330870553e5c414ca92619418661197fac10471db1d381085ddaddb58796829ca90069"),Gx:BigInt("0x81aee4bdd82ed9645a21322e9c4c6a9385ed9f70b5d916c1b43b62eef4d0098eff3b1f78e2d0d48d50d1687b93b97d5f7c6d5047406a5e688b352209bcb9f822"),Gy:BigInt("0x7dde385d566332ecc0eabfa9cf7822fdf209f70024a57b1aa000c55b881f8111b2dcde494a5f485e5bca4bd88a2763aed1ca2b2fa8f0540678cd1e0f3ad80892"),h:BigInt(1),lowS:!1},Zu),Il=new Map(Object.entries({nistP256:Hu,nistP384:nh,nistP521:ah,brainpoolP256r1:bl,brainpoolP384r1:El,brainpoolP512r1:Sl,secp256k1:ml,x448:ll,ed448:hl}));var Bl=Object.freeze({__proto__:null,nobleCurves:Il});const Cl=new Uint32Array([1732584193,4023233417,2562383102,271733878,3285377520]),Pl=new Uint32Array(80);class pl extends Ac{constructor(){super(64,20,8,!1),this.A=0|Cl[0],this.B=0|Cl[1],this.C=0|Cl[2],this.D=0|Cl[3],this.E=0|Cl[4]}get(){const{A:w,B:O,C:_,D:N,E:F}=this;return[w,O,_,N,F]}set(w,O,_,N,F){this.A=0|w,this.B=0|O,this.C=0|_,this.D=0|N,this.E=0|F}process(w,O){for(let _=0;_<16;_++,O+=4)Pl[_]=w.getUint32(O,!1);for(let w=16;w<80;w++)Pl[w]=ac(Pl[w-3]^Pl[w-8]^Pl[w-14]^Pl[w-16],1);let{A:_,B:N,C:F,D:H,E:j}=this;for(let w=0;w<80;w++){let O,G;w<20?(O=pc(N,F,H),G=1518500249):w<40?(O=N^F^H,G=1859775393):w<60?(O=dc(N,F,H),G=2400959708):(O=N^F^H,G=3395469782);const z=ac(_,5)+O+j+G+Pl[w]|0;j=H,H=F,F=ac(N,30),N=_,_=z}_=_+this.A|0,N=N+this.B|0,F=F+this.C|0,H=H+this.D|0,j=j+this.E|0,this.set(_,N,F,H,j)}roundClean(){Pl.fill(0)}destroy(){this.set(0,0,0,0,0),this.buffer.fill(0)}}const Ul=fc((()=>new pl)),Rl=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Ql=new Uint8Array(Array(16).fill(0).map(((w,O)=>O))),Ml=Ql.map((w=>(9*w+5)%16));let Ll=[Ql],Gl=[Ml];for(let w=0;w<4;w++)for(let O of[Ll,Gl])O.push(O[w].map((w=>Rl[w])));const $l=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map((w=>new Uint8Array(w))),Wl=Ll.map(((w,O)=>w.map((w=>$l[O][w])))),ef=Gl.map(((w,O)=>w.map((w=>$l[O][w])))),tf=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),rf=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]);function Kl(w,O,_,N){return 0===w?O^_^N:1===w?O&_|~O&N:2===w?(O|~_)^N:3===w?O&N|_&~N:O^(_|~N)}const nf=new Uint32Array(16);class Dl extends Ac{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:w,h1:O,h2:_,h3:N,h4:F}=this;return[w,O,_,N,F]}set(w,O,_,N,F){this.h0=0|w,this.h1=0|O,this.h2=0|_,this.h3=0|N,this.h4=0|F}process(w,O){for(let _=0;_<16;_++,O+=4)nf[_]=w.getUint32(O,!0);let _=0|this.h0,N=_,F=0|this.h1,H=F,j=0|this.h2,G=j,z=0|this.h3,X=z,ee=0|this.h4,se=ee;for(let w=0;w<5;w++){const O=4-w,ae=tf[w],Ae=rf[w],be=Ll[w],ve=Gl[w],Se=Wl[w],Ie=ef[w];for(let O=0;O<16;O++){const N=ac(_+Kl(w,F,j,z)+nf[be[O]]+ae,Se[O])+ee|0;_=ee,ee=z,z=0|ac(j,10),j=F,F=N}for(let w=0;w<16;w++){const _=ac(N+Kl(O,H,G,X)+nf[ve[w]]+Ae,Ie[w])+se|0;N=se,se=X,X=0|ac(G,10),G=H,H=_}}this.set(this.h1+j+X|0,this.h2+z+se|0,this.h3+ee+N|0,this.h4+_+H|0,this.h0+F+G|0)}roundClean(){nf.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const sf=fc((()=>new Dl)),af=Array.from({length:64},((w,O)=>Math.floor(2**32*Math.abs(Math.sin(O+1))))),xl=(w,O,_)=>w&O^~w&_,of=new Uint32Array([1732584193,4023233417,2562383102,271733878]),cf=new Uint32Array(16);class Tl extends Ac{constructor(){super(64,16,8,!0),this.A=0|of[0],this.B=0|of[1],this.C=0|of[2],this.D=0|of[3]}get(){const{A:w,B:O,C:_,D:N}=this;return[w,O,_,N]}set(w,O,_,N){this.A=0|w,this.B=0|O,this.C=0|_,this.D=0|N}process(w,O){for(let _=0;_<16;_++,O+=4)cf[_]=w.getUint32(O,!0);let{A:_,B:N,C:F,D:H}=this;for(let w=0;w<64;w++){let O,j,G;w<16?(O=xl(N,F,H),j=w,G=[7,12,17,22]):w<32?(O=xl(H,N,F),j=(5*w+1)%16,G=[5,9,14,20]):w<48?(O=N^F^H,j=(3*w+5)%16,G=[4,11,16,23]):(O=F^(N|~H),j=7*w%16,G=[6,10,15,21]),O=O+_+af[w]+cf[j],_=H,H=F,F=N,N+=ac(O,G[w%4])}_=_+this.A|0,N=N+this.B|0,F=F+this.C|0,H=H+this.D|0,this.set(_,N,F,H)}roundClean(){cf.fill(0)}destroy(){this.set(0,0,0,0),this.buffer.fill(0)}}const uf=new Map(Object.entries({md5:fc((()=>new Tl)),sha1:Ul,sha224:uu,sha256:cu,sha384:Xu,sha512:Zu,sha3_256:Dh,sha3_512:Uh,ripemd160:sf}));var hf=Object.freeze({__proto__:null,nobleHashes:uf});function Nl(w,O,_,N,F,H){const j=[16843776,0,65536,16843780,16842756,66564,4,65536,1024,16843776,16843780,1024,16778244,16842756,16777216,4,1028,16778240,16778240,66560,66560,16842752,16842752,16778244,65540,16777220,16777220,65540,0,1028,66564,16777216,65536,16843780,4,16842752,16843776,16777216,16777216,1024,16842756,65536,66560,16777220,1024,4,16778244,66564,16843780,65540,16842752,16778244,16777220,1028,66564,16843776,1028,16778240,16778240,0,65540,66560,0,16842756],G=[-2146402272,-2147450880,32768,1081376,1048576,32,-2146435040,-2147450848,-2147483616,-2146402272,-2146402304,-2147483648,-2147450880,1048576,32,-2146435040,1081344,1048608,-2147450848,0,-2147483648,32768,1081376,-2146435072,1048608,-2147483616,0,1081344,32800,-2146402304,-2146435072,32800,0,1081376,-2146435040,1048576,-2147450848,-2146435072,-2146402304,32768,-2146435072,-2147450880,32,-2146402272,1081376,32,32768,-2147483648,32800,-2146402304,1048576,-2147483616,1048608,-2147450848,-2147483616,1048608,1081344,0,-2147450880,32800,-2147483648,-2146435040,-2146402272,1081344],z=[520,134349312,0,134348808,134218240,0,131592,134218240,131080,134217736,134217736,131072,134349320,131080,134348800,520,134217728,8,134349312,512,131584,134348800,134348808,131592,134218248,131584,131072,134218248,8,134349320,512,134217728,134349312,134217728,131080,520,131072,134349312,134218240,0,512,131080,134349320,134218240,134217736,512,0,134348808,134218248,131072,134217728,134349320,8,131592,131584,134217736,134348800,134218248,520,134348800,131592,8,134348808,131584],X=[8396801,8321,8321,128,8396928,8388737,8388609,8193,0,8396800,8396800,8396929,129,0,8388736,8388609,1,8192,8388608,8396801,128,8388608,8193,8320,8388737,1,8320,8388736,8192,8396928,8396929,129,8388736,8388609,8396800,8396929,129,0,0,8396800,8320,8388736,8388737,1,8396801,8321,8321,128,8396929,129,1,8192,8388609,8193,8396928,8388737,8193,8320,8388608,8396801,128,8388608,8192,8396928],ee=[256,34078976,34078720,1107296512,524288,256,1073741824,34078720,1074266368,524288,33554688,1074266368,1107296512,1107820544,524544,1073741824,33554432,1074266112,1074266112,0,1073742080,1107820800,1107820800,33554688,1107820544,1073742080,0,1107296256,34078976,33554432,1107296256,524544,524288,1107296512,256,33554432,1073741824,34078720,1107296512,1074266368,33554688,1073741824,1107820544,34078976,1074266368,256,33554432,1107820544,1107820800,524544,1107296256,1107820800,34078720,0,1074266112,1107296256,524544,33554688,1073742080,524288,0,1074266112,34078976,1073742080],se=[536870928,541065216,16384,541081616,541065216,16,541081616,4194304,536887296,4210704,4194304,536870928,4194320,536887296,536870912,16400,0,4194320,536887312,16384,4210688,536887312,16,541065232,541065232,0,4210704,541081600,16400,4210688,541081600,536870912,536887296,16,541065232,4210688,541081616,4194304,16400,536870928,4194304,536887296,536870912,16400,536870928,541081616,4210688,541065216,4210704,541081600,0,541065232,16,16384,541065216,4210704,16384,4194320,536887312,0,541081600,536870912,4194320,536887312],ae=[2097152,69206018,67110914,0,2048,67110914,2099202,69208064,69208066,2097152,0,67108866,2,67108864,69206018,2050,67110912,2099202,2097154,67110912,67108866,69206016,69208064,2097154,69206016,2048,2050,69208066,2099200,2,67108864,2099200,67108864,2099200,2097152,67110914,67110914,69206018,69206018,2,2097154,67108864,67110912,2097152,69208064,2050,2099202,69208064,2050,67108866,69208066,69206016,2099200,0,2,69208066,0,2099202,69206016,2048,67108866,67110912,2048,2097154],Ae=[268439616,4096,262144,268701760,268435456,268439616,64,268435456,262208,268697600,268701760,266240,268701696,266304,4096,64,268697600,268435520,268439552,4160,266240,262208,268697664,268701696,4160,0,0,268697664,268435520,268439552,266304,262144,266304,262144,268701696,4096,64,268697664,4096,266304,268439552,64,268435520,268697600,268697664,268435456,262144,268439616,0,268701760,262208,268435520,268697600,268439552,268439616,0,268701760,266240,266240,4160,4160,262208,268435456,268701696];let be,ve,Se,Ie,Be,Pe,xe,De,Ue,Oe,_e=0,Re=O.length;const Te=32===w.length?3:9;De=3===Te?_?[0,32,2]:[30,-2,-2]:_?[0,32,2,62,30,-2,64,96,2]:[94,62,-2,32,64,2,30,-2,-2],_&&(O=function(w){const O=8-w.length%8;let _;if(!(O<8)){if(8===O)return w;throw Error("des: invalid padding")}_=0;const N=new Uint8Array(w.length+O);for(let O=0;O<w.length;O++)N[O]=w[O];for(let F=0;F<O;F++)N[w.length+F]=_;return N}(O),Re=O.length);let Qe=new Uint8Array(Re),Me=0;for(;_e<Re;){for(Pe=O[_e++]<<24|O[_e++]<<16|O[_e++]<<8|O[_e++],xe=O[_e++]<<24|O[_e++]<<16|O[_e++]<<8|O[_e++],Se=252645135&(Pe>>>4^xe),xe^=Se,Pe^=Se<<4,Se=65535&(Pe>>>16^xe),xe^=Se,Pe^=Se<<16,Se=858993459&(xe>>>2^Pe),Pe^=Se,xe^=Se<<2,Se=16711935&(xe>>>8^Pe),Pe^=Se,xe^=Se<<8,Se=1431655765&(Pe>>>1^xe),xe^=Se,Pe^=Se<<1,Pe=Pe<<1|Pe>>>31,xe=xe<<1|xe>>>31,ve=0;ve<Te;ve+=3){for(Ue=De[ve+1],Oe=De[ve+2],be=De[ve];be!==Ue;be+=Oe)Ie=xe^w[be],Be=(xe>>>4|xe<<28)^w[be+1],Se=Pe,Pe=xe,xe=Se^(G[Ie>>>24&63]|X[Ie>>>16&63]|se[Ie>>>8&63]|Ae[63&Ie]|j[Be>>>24&63]|z[Be>>>16&63]|ee[Be>>>8&63]|ae[63&Be]);Se=Pe,Pe=xe,xe=Se}Pe=Pe>>>1|Pe<<31,xe=xe>>>1|xe<<31,Se=1431655765&(Pe>>>1^xe),xe^=Se,Pe^=Se<<1,Se=16711935&(xe>>>8^Pe),Pe^=Se,xe^=Se<<8,Se=858993459&(xe>>>2^Pe),Pe^=Se,xe^=Se<<2,Se=65535&(Pe>>>16^xe),xe^=Se,Pe^=Se<<16,Se=252645135&(Pe>>>4^xe),xe^=Se,Pe^=Se<<4,Qe[Me++]=Pe>>>24,Qe[Me++]=Pe>>>16&255,Qe[Me++]=Pe>>>8&255,Qe[Me++]=255&Pe,Qe[Me++]=xe>>>24,Qe[Me++]=xe>>>16&255,Qe[Me++]=xe>>>8&255,Qe[Me++]=255&xe}return _||(Qe=function(w){let O,_=null;if(O=0,!_){for(_=1;w[w.length-_]===O;)_++;_--}return w.subarray(0,w.length-_)}(Qe)),Qe}function Fl(w){const O=[0,4,536870912,536870916,65536,65540,536936448,536936452,512,516,536871424,536871428,66048,66052,536936960,536936964],_=[0,1,1048576,1048577,67108864,67108865,68157440,68157441,256,257,1048832,1048833,67109120,67109121,68157696,68157697],N=[0,8,2048,2056,16777216,16777224,16779264,16779272,0,8,2048,2056,16777216,16777224,16779264,16779272],F=[0,2097152,134217728,136314880,8192,2105344,134225920,136323072,131072,2228224,134348800,136445952,139264,2236416,134356992,136454144],H=[0,262144,16,262160,0,262144,16,262160,4096,266240,4112,266256,4096,266240,4112,266256],j=[0,1024,32,1056,0,1024,32,1056,33554432,33555456,33554464,33555488,33554432,33555456,33554464,33555488],G=[0,268435456,524288,268959744,2,268435458,524290,268959746,0,268435456,524288,268959744,2,268435458,524290,268959746],z=[0,65536,2048,67584,536870912,536936448,536872960,536938496,131072,196608,133120,198656,537001984,537067520,537004032,537069568],X=[0,262144,0,262144,2,262146,2,262146,33554432,33816576,33554432,33816576,33554434,33816578,33554434,33816578],ee=[0,268435456,8,268435464,0,268435456,8,268435464,1024,268436480,1032,268436488,1024,268436480,1032,268436488],se=[0,32,0,32,1048576,1048608,1048576,1048608,8192,8224,8192,8224,1056768,1056800,1056768,1056800],ae=[0,16777216,512,16777728,2097152,18874368,2097664,18874880,67108864,83886080,67109376,83886592,69206016,85983232,69206528,85983744],Ae=[0,4096,134217728,134221824,524288,528384,134742016,134746112,16,4112,134217744,134221840,524304,528400,134742032,134746128],be=[0,4,256,260,0,4,256,260,1,5,257,261,1,5,257,261],ve=w.length>8?3:1,Se=Array(32*ve),Ie=[0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0];let Be,Pe,xe,De=0,Ue=0;for(let Oe=0;Oe<ve;Oe++){let ve=w[De++]<<24|w[De++]<<16|w[De++]<<8|w[De++],Oe=w[De++]<<24|w[De++]<<16|w[De++]<<8|w[De++];xe=252645135&(ve>>>4^Oe),Oe^=xe,ve^=xe<<4,xe=65535&(Oe>>>-16^ve),ve^=xe,Oe^=xe<<-16,xe=858993459&(ve>>>2^Oe),Oe^=xe,ve^=xe<<2,xe=65535&(Oe>>>-16^ve),ve^=xe,Oe^=xe<<-16,xe=1431655765&(ve>>>1^Oe),Oe^=xe,ve^=xe<<1,xe=16711935&(Oe>>>8^ve),ve^=xe,Oe^=xe<<8,xe=1431655765&(ve>>>1^Oe),Oe^=xe,ve^=xe<<1,xe=ve<<8|Oe>>>20&240,ve=Oe<<24|Oe<<8&16711680|Oe>>>8&65280|Oe>>>24&240,Oe=xe;for(let w=0;w<16;w++)Ie[w]?(ve=ve<<2|ve>>>26,Oe=Oe<<2|Oe>>>26):(ve=ve<<1|ve>>>27,Oe=Oe<<1|Oe>>>27),ve&=-15,Oe&=-15,Be=O[ve>>>28]|_[ve>>>24&15]|N[ve>>>20&15]|F[ve>>>16&15]|H[ve>>>12&15]|j[ve>>>8&15]|G[ve>>>4&15],Pe=z[Oe>>>28]|X[Oe>>>24&15]|ee[Oe>>>20&15]|se[Oe>>>16&15]|ae[Oe>>>12&15]|Ae[Oe>>>8&15]|be[Oe>>>4&15],xe=65535&(Pe>>>16^Be),Se[Ue++]=Be^xe,Se[Ue++]=Pe^xe<<16}return Se}function Ol(w){this.key=[];for(let O=0;O<3;O++)this.key.push(new Uint8Array(w.subarray(8*O,8*O+8)));this.encrypt=function(w){return Nl(Fl(this.key[2]),Nl(Fl(this.key[1]),Nl(Fl(this.key[0]),w,!0),!1),!0)}}function Hl(){this.BlockSize=8,this.KeySize=16,this.setKey=function(w){if(this.masking=Array(16),this.rotate=Array(16),this.reset(),w.length!==this.KeySize)throw Error("CAST-128: keys must be 16 bytes");return this.keySchedule(w),!0},this.reset=function(){for(let w=0;w<16;w++)this.masking[w]=0,this.rotate[w]=0},this.getBlockSize=function(){return this.BlockSize},this.encrypt=function(w){const O=Array(w.length);for(let _=0;_<w.length;_+=8){let N,F=w[_]<<24|w[_+1]<<16|w[_+2]<<8|w[_+3],H=w[_+4]<<24|w[_+5]<<16|w[_+6]<<8|w[_+7];N=H,H=F^r(H,this.masking[0],this.rotate[0]),F=N,N=H,H=F^n(H,this.masking[1],this.rotate[1]),F=N,N=H,H=F^i(H,this.masking[2],this.rotate[2]),F=N,N=H,H=F^r(H,this.masking[3],this.rotate[3]),F=N,N=H,H=F^n(H,this.masking[4],this.rotate[4]),F=N,N=H,H=F^i(H,this.masking[5],this.rotate[5]),F=N,N=H,H=F^r(H,this.masking[6],this.rotate[6]),F=N,N=H,H=F^n(H,this.masking[7],this.rotate[7]),F=N,N=H,H=F^i(H,this.masking[8],this.rotate[8]),F=N,N=H,H=F^r(H,this.masking[9],this.rotate[9]),F=N,N=H,H=F^n(H,this.masking[10],this.rotate[10]),F=N,N=H,H=F^i(H,this.masking[11],this.rotate[11]),F=N,N=H,H=F^r(H,this.masking[12],this.rotate[12]),F=N,N=H,H=F^n(H,this.masking[13],this.rotate[13]),F=N,N=H,H=F^i(H,this.masking[14],this.rotate[14]),F=N,N=H,H=F^r(H,this.masking[15],this.rotate[15]),F=N,O[_]=H>>>24&255,O[_+1]=H>>>16&255,O[_+2]=H>>>8&255,O[_+3]=255&H,O[_+4]=F>>>24&255,O[_+5]=F>>>16&255,O[_+6]=F>>>8&255,O[_+7]=255&F}return O},this.decrypt=function(w){const O=Array(w.length);for(let _=0;_<w.length;_+=8){let N,F=w[_]<<24|w[_+1]<<16|w[_+2]<<8|w[_+3],H=w[_+4]<<24|w[_+5]<<16|w[_+6]<<8|w[_+7];N=H,H=F^r(H,this.masking[15],this.rotate[15]),F=N,N=H,H=F^i(H,this.masking[14],this.rotate[14]),F=N,N=H,H=F^n(H,this.masking[13],this.rotate[13]),F=N,N=H,H=F^r(H,this.masking[12],this.rotate[12]),F=N,N=H,H=F^i(H,this.masking[11],this.rotate[11]),F=N,N=H,H=F^n(H,this.masking[10],this.rotate[10]),F=N,N=H,H=F^r(H,this.masking[9],this.rotate[9]),F=N,N=H,H=F^i(H,this.masking[8],this.rotate[8]),F=N,N=H,H=F^n(H,this.masking[7],this.rotate[7]),F=N,N=H,H=F^r(H,this.masking[6],this.rotate[6]),F=N,N=H,H=F^i(H,this.masking[5],this.rotate[5]),F=N,N=H,H=F^n(H,this.masking[4],this.rotate[4]),F=N,N=H,H=F^r(H,this.masking[3],this.rotate[3]),F=N,N=H,H=F^i(H,this.masking[2],this.rotate[2]),F=N,N=H,H=F^n(H,this.masking[1],this.rotate[1]),F=N,N=H,H=F^r(H,this.masking[0],this.rotate[0]),F=N,O[_]=H>>>24&255,O[_+1]=H>>>16&255,O[_+2]=H>>>8&255,O[_+3]=255&H,O[_+4]=F>>>24&255,O[_+5]=F>>16&255,O[_+6]=F>>8&255,O[_+7]=255&F}return O};const w=[,,,,];w[0]=[,,,,],w[0][0]=[4,0,13,15,12,14,8],w[0][1]=[5,2,16,18,17,19,10],w[0][2]=[6,3,23,22,21,20,9],w[0][3]=[7,1,26,25,27,24,11],w[1]=[,,,,],w[1][0]=[0,6,21,23,20,22,16],w[1][1]=[1,4,0,2,1,3,18],w[1][2]=[2,5,7,6,5,4,17],w[1][3]=[3,7,10,9,11,8,19],w[2]=[,,,,],w[2][0]=[4,0,13,15,12,14,8],w[2][1]=[5,2,16,18,17,19,10],w[2][2]=[6,3,23,22,21,20,9],w[2][3]=[7,1,26,25,27,24,11],w[3]=[,,,,],w[3][0]=[0,6,21,23,20,22,16],w[3][1]=[1,4,0,2,1,3,18],w[3][2]=[2,5,7,6,5,4,17],w[3][3]=[3,7,10,9,11,8,19];const O=[,,,,];function r(w,O,N){const F=O+w,H=F<<N|F>>>32-N;return(_[0][H>>>24]^_[1][H>>>16&255])-_[2][H>>>8&255]+_[3][255&H]}function n(w,O,N){const F=O^w,H=F<<N|F>>>32-N;return _[0][H>>>24]-_[1][H>>>16&255]+_[2][H>>>8&255]^_[3][255&H]}function i(w,O,N){const F=O-w,H=F<<N|F>>>32-N;return(_[0][H>>>24]+_[1][H>>>16&255]^_[2][H>>>8&255])-_[3][255&H]}O[0]=[,,,,],O[0][0]=[24,25,23,22,18],O[0][1]=[26,27,21,20,22],O[0][2]=[28,29,19,18,25],O[0][3]=[30,31,17,16,28],O[1]=[,,,,],O[1][0]=[3,2,12,13,8],O[1][1]=[1,0,14,15,13],O[1][2]=[7,6,8,9,3],O[1][3]=[5,4,10,11,7],O[2]=[,,,,],O[2][0]=[19,18,28,29,25],O[2][1]=[17,16,30,31,28],O[2][2]=[23,22,24,25,18],O[2][3]=[21,20,26,27,22],O[3]=[,,,,],O[3][0]=[8,9,7,6,3],O[3][1]=[10,11,5,4,7],O[3][2]=[12,13,3,2,8],O[3][3]=[14,15,1,0,13],this.keySchedule=function(N){const F=[,,,,,,,,],H=Array(32);let j;for(let w=0;w<4;w++)j=4*w,F[w]=N[j]<<24|N[j+1]<<16|N[j+2]<<8|N[j+3];const G=[6,7,4,5];let z,X=0;for(let N=0;N<2;N++)for(let N=0;N<4;N++){for(j=0;j<4;j++){const O=w[N][j];z=F[O[1]],z^=_[4][F[O[2]>>>2]>>>24-8*(3&O[2])&255],z^=_[5][F[O[3]>>>2]>>>24-8*(3&O[3])&255],z^=_[6][F[O[4]>>>2]>>>24-8*(3&O[4])&255],z^=_[7][F[O[5]>>>2]>>>24-8*(3&O[5])&255],z^=_[G[j]][F[O[6]>>>2]>>>24-8*(3&O[6])&255],F[O[0]]=z}for(j=0;j<4;j++){const w=O[N][j];z=_[4][F[w[0]>>>2]>>>24-8*(3&w[0])&255],z^=_[5][F[w[1]>>>2]>>>24-8*(3&w[1])&255],z^=_[6][F[w[2]>>>2]>>>24-8*(3&w[2])&255],z^=_[7][F[w[3]>>>2]>>>24-8*(3&w[3])&255],z^=_[4+j][F[w[4]>>>2]>>>24-8*(3&w[4])&255],H[X]=z,X++}}for(let w=0;w<16;w++)this.masking[w]=H[w],this.rotate[w]=31&H[16+w]};const _=[,,,,,,,,];_[0]=[821772500,2678128395,1810681135,1059425402,505495343,2617265619,1610868032,3483355465,3218386727,2294005173,3791863952,2563806837,1852023008,365126098,3269944861,584384398,677919599,3229601881,4280515016,2002735330,1136869587,3744433750,2289869850,2731719981,2714362070,879511577,1639411079,575934255,717107937,2857637483,576097850,2731753936,1725645e3,2810460463,5111599,767152862,2543075244,1251459544,1383482551,3052681127,3089939183,3612463449,1878520045,1510570527,2189125840,2431448366,582008916,3163445557,1265446783,1354458274,3529918736,3202711853,3073581712,3912963487,3029263377,1275016285,4249207360,2905708351,3304509486,1442611557,3585198765,2712415662,2731849581,3248163920,2283946226,208555832,2766454743,1331405426,1447828783,3315356441,3108627284,2957404670,2981538698,3339933917,1669711173,286233437,1465092821,1782121619,3862771680,710211251,980974943,1651941557,430374111,2051154026,704238805,4128970897,3144820574,2857402727,948965521,3333752299,2227686284,718756367,2269778983,2731643755,718440111,2857816721,3616097120,1113355533,2478022182,410092745,1811985197,1944238868,2696854588,1415722873,1682284203,1060277122,1998114690,1503841958,82706478,2315155686,1068173648,845149890,2167947013,1768146376,1993038550,3566826697,3390574031,940016341,3355073782,2328040721,904371731,1205506512,4094660742,2816623006,825647681,85914773,2857843460,1249926541,1417871568,3287612,3211054559,3126306446,1975924523,1353700161,2814456437,2438597621,1800716203,722146342,2873936343,1151126914,4160483941,2877670899,458611604,2866078500,3483680063,770352098,2652916994,3367839148,3940505011,3585973912,3809620402,718646636,2504206814,2914927912,3631288169,2857486607,2860018678,575749918,2857478043,718488780,2069512688,3548183469,453416197,1106044049,3032691430,52586708,3378514636,3459808877,3211506028,1785789304,218356169,3571399134,3759170522,1194783844,1523787992,3007827094,1975193539,2555452411,1341901877,3045838698,3776907964,3217423946,2802510864,2889438986,1057244207,1636348243,3761863214,1462225785,2632663439,481089165,718503062,24497053,3332243209,3344655856,3655024856,3960371065,1195698900,2971415156,3710176158,2115785917,4027663609,3525578417,2524296189,2745972565,3564906415,1372086093,1452307862,2780501478,1476592880,3389271281,18495466,2378148571,901398090,891748256,3279637769,3157290713,2560960102,1447622437,4284372637,216884176,2086908623,1879786977,3588903153,2242455666,2938092967,3559082096,2810645491,758861177,1121993112,215018983,642190776,4169236812,1196255959,2081185372,3508738393,941322904,4124243163,2877523539,1848581667,2205260958,3180453958,2589345134,3694731276,550028657,2519456284,3789985535,2973870856,2093648313,443148163,46942275,2734146937,1117713533,1115362972,1523183689,3717140224,1551984063],_[1]=[522195092,4010518363,1776537470,960447360,4267822970,4005896314,1435016340,1929119313,2913464185,1310552629,3579470798,3724818106,2579771631,1594623892,417127293,2715217907,2696228731,1508390405,3994398868,3925858569,3695444102,4019471449,3129199795,3770928635,3520741761,990456497,4187484609,2783367035,21106139,3840405339,631373633,3783325702,532942976,396095098,3548038825,4267192484,2564721535,2011709262,2039648873,620404603,3776170075,2898526339,3612357925,4159332703,1645490516,223693667,1567101217,3362177881,1029951347,3470931136,3570957959,1550265121,119497089,972513919,907948164,3840628539,1613718692,3594177948,465323573,2659255085,654439692,2575596212,2699288441,3127702412,277098644,624404830,4100943870,2717858591,546110314,2403699828,3655377447,1321679412,4236791657,1045293279,4010672264,895050893,2319792268,494945126,1914543101,2777056443,3894764339,2219737618,311263384,4275257268,3458730721,669096869,3584475730,3835122877,3319158237,3949359204,2005142349,2713102337,2228954793,3769984788,569394103,3855636576,1425027204,108000370,2736431443,3671869269,3043122623,1750473702,2211081108,762237499,3972989403,2798899386,3061857628,2943854345,867476300,964413654,1591880597,1594774276,2179821409,552026980,3026064248,3726140315,2283577634,3110545105,2152310760,582474363,1582640421,1383256631,2043843868,3322775884,1217180674,463797851,2763038571,480777679,2718707717,2289164131,3118346187,214354409,200212307,3810608407,3025414197,2674075964,3997296425,1847405948,1342460550,510035443,4080271814,815934613,833030224,1620250387,1945732119,2703661145,3966000196,1388869545,3456054182,2687178561,2092620194,562037615,1356438536,3409922145,3261847397,1688467115,2150901366,631725691,3840332284,549916902,3455104640,394546491,837744717,2114462948,751520235,2221554606,2415360136,3999097078,2063029875,803036379,2702586305,821456707,3019566164,360699898,4018502092,3511869016,3677355358,2402471449,812317050,49299192,2570164949,3259169295,2816732080,3331213574,3101303564,2156015656,3705598920,3546263921,143268808,3200304480,1638124008,3165189453,3341807610,578956953,2193977524,3638120073,2333881532,807278310,658237817,2969561766,1641658566,11683945,3086995007,148645947,1138423386,4158756760,1981396783,2401016740,3699783584,380097457,2680394679,2803068651,3334260286,441530178,4016580796,1375954390,761952171,891809099,2183123478,157052462,3683840763,1592404427,341349109,2438483839,1417898363,644327628,2233032776,2353769706,2201510100,220455161,1815641738,182899273,2995019788,3627381533,3702638151,2890684138,1052606899,588164016,1681439879,4038439418,2405343923,4229449282,167996282,1336969661,1688053129,2739224926,1543734051,1046297529,1138201970,2121126012,115334942,1819067631,1902159161,1941945968,2206692869,1159982321],_[2]=[2381300288,637164959,3952098751,3893414151,1197506559,916448331,2350892612,2932787856,3199334847,4009478890,3905886544,1373570990,2450425862,4037870920,3778841987,2456817877,286293407,124026297,3001279700,1028597854,3115296800,4208886496,2691114635,2188540206,1430237888,1218109995,3572471700,308166588,570424558,2187009021,2455094765,307733056,1310360322,3135275007,1384269543,2388071438,863238079,2359263624,2801553128,3380786597,2831162807,1470087780,1728663345,4072488799,1090516929,532123132,2389430977,1132193179,2578464191,3051079243,1670234342,1434557849,2711078940,1241591150,3314043432,3435360113,3091448339,1812415473,2198440252,267246943,796911696,3619716990,38830015,1526438404,2806502096,374413614,2943401790,1489179520,1603809326,1920779204,168801282,260042626,2358705581,1563175598,2397674057,1356499128,2217211040,514611088,2037363785,2186468373,4022173083,2792511869,2913485016,1173701892,4200428547,3896427269,1334932762,2455136706,602925377,2835607854,1613172210,41346230,2499634548,2457437618,2188827595,41386358,4172255629,1313404830,2405527007,3801973774,2217704835,873260488,2528884354,2478092616,4012915883,2555359016,2006953883,2463913485,575479328,2218240648,2099895446,660001756,2341502190,3038761536,3888151779,3848713377,3286851934,1022894237,1620365795,3449594689,1551255054,15374395,3570825345,4249311020,4151111129,3181912732,310226346,1133119310,530038928,136043402,2476768958,3107506709,2544909567,1036173560,2367337196,1681395281,1758231547,3641649032,306774401,1575354324,3716085866,1990386196,3114533736,2455606671,1262092282,3124342505,2768229131,4210529083,1833535011,423410938,660763973,2187129978,1639812e3,3508421329,3467445492,310289298,272797111,2188552562,2456863912,310240523,677093832,1013118031,901835429,3892695601,1116285435,3036471170,1337354835,243122523,520626091,277223598,4244441197,4194248841,1766575121,594173102,316590669,742362309,3536858622,4176435350,3838792410,2501204839,1229605004,3115755532,1552908988,2312334149,979407927,3959474601,1148277331,176638793,3614686272,2083809052,40992502,1340822838,2731552767,3535757508,3560899520,1354035053,122129617,7215240,2732932949,3118912700,2718203926,2539075635,3609230695,3725561661,1928887091,2882293555,1988674909,2063640240,2491088897,1459647954,4189817080,2302804382,1113892351,2237858528,1927010603,4002880361,1856122846,1594404395,2944033133,3855189863,3474975698,1643104450,4054590833,3431086530,1730235576,2984608721,3084664418,2131803598,4178205752,267404349,1617849798,1616132681,1462223176,736725533,2327058232,551665188,2945899023,1749386277,2575514597,1611482493,674206544,2201269090,3642560800,728599968,1680547377,2620414464,1388111496,453204106,4156223445,1094905244,2754698257,2201108165,3757000246,2704524545,3922940700,3996465027],_[3]=[2645754912,532081118,2814278639,3530793624,1246723035,1689095255,2236679235,4194438865,2116582143,3859789411,157234593,2045505824,4245003587,1687664561,4083425123,605965023,672431967,1336064205,3376611392,214114848,4258466608,3232053071,489488601,605322005,3998028058,264917351,1912574028,756637694,436560991,202637054,135989450,85393697,2152923392,3896401662,2895836408,2145855233,3535335007,115294817,3147733898,1922296357,3464822751,4117858305,1037454084,2725193275,2127856640,1417604070,1148013728,1827919605,642362335,2929772533,909348033,1346338451,3547799649,297154785,1917849091,4161712827,2883604526,3968694238,1469521537,3780077382,3375584256,1763717519,136166297,4290970789,1295325189,2134727907,2798151366,1566297257,3672928234,2677174161,2672173615,965822077,2780786062,289653839,1133871874,3491843819,35685304,1068898316,418943774,672553190,642281022,2346158704,1954014401,3037126780,4079815205,2030668546,3840588673,672283427,1776201016,359975446,3750173538,555499703,2769985273,1324923,69110472,152125443,3176785106,3822147285,1340634837,798073664,1434183902,15393959,216384236,1303690150,3881221631,3711134124,3960975413,106373927,2578434224,1455997841,1801814300,1578393881,1854262133,3188178946,3258078583,2302670060,1539295533,3505142565,3078625975,2372746020,549938159,3278284284,2620926080,181285381,2865321098,3970029511,68876850,488006234,1728155692,2608167508,836007927,2435231793,919367643,3339422534,3655756360,1457871481,40520939,1380155135,797931188,234455205,2255801827,3990488299,397000196,739833055,3077865373,2871719860,4022553888,772369276,390177364,3853951029,557662966,740064294,1640166671,1699928825,3535942136,622006121,3625353122,68743880,1742502,219489963,1664179233,1577743084,1236991741,410585305,2366487942,823226535,1050371084,3426619607,3586839478,212779912,4147118561,1819446015,1911218849,530248558,3486241071,3252585495,2886188651,3410272728,2342195030,20547779,2982490058,3032363469,3631753222,312714466,1870521650,1493008054,3491686656,615382978,4103671749,2534517445,1932181,2196105170,278426614,6369430,3274544417,2913018367,697336853,2143000447,2946413531,701099306,1558357093,2805003052,3500818408,2321334417,3567135975,216290473,3591032198,23009561,1996984579,3735042806,2024298078,3739440863,569400510,2339758983,3016033873,3097871343,3639523026,3844324983,3256173865,795471839,2951117563,4101031090,4091603803,3603732598,971261452,534414648,428311343,3389027175,2844869880,694888862,1227866773,2456207019,3043454569,2614353370,3749578031,3676663836,459166190,4132644070,1794958188,51825668,2252611902,3084671440,2036672799,3436641603,1099053433,2469121526,3059204941,1323291266,2061838604,1018778475,2233344254,2553501054,334295216,3556750194,1065731521,183467730],_[4]=[2127105028,745436345,2601412319,2788391185,3093987327,500390133,1155374404,389092991,150729210,3891597772,3523549952,1935325696,716645080,946045387,2901812282,1774124410,3869435775,4039581901,3293136918,3438657920,948246080,363898952,3867875531,1286266623,1598556673,68334250,630723836,1104211938,1312863373,613332731,2377784574,1101634306,441780740,3129959883,1917973735,2510624549,3238456535,2544211978,3308894634,1299840618,4076074851,1756332096,3977027158,297047435,3790297736,2265573040,3621810518,1311375015,1667687725,47300608,3299642885,2474112369,201668394,1468347890,576830978,3594690761,3742605952,1958042578,1747032512,3558991340,1408974056,3366841779,682131401,1033214337,1545599232,4265137049,206503691,103024618,2855227313,1337551222,2428998917,2963842932,4015366655,3852247746,2796956967,3865723491,3747938335,247794022,3755824572,702416469,2434691994,397379957,851939612,2314769512,218229120,1380406772,62274761,214451378,3170103466,2276210409,3845813286,28563499,446592073,1693330814,3453727194,29968656,3093872512,220656637,2470637031,77972100,1667708854,1358280214,4064765667,2395616961,325977563,4277240721,4220025399,3605526484,3355147721,811859167,3069544926,3962126810,652502677,3075892249,4132761541,3498924215,1217549313,3250244479,3858715919,3053989961,1538642152,2279026266,2875879137,574252750,3324769229,2651358713,1758150215,141295887,2719868960,3515574750,4093007735,4194485238,1082055363,3417560400,395511885,2966884026,179534037,3646028556,3738688086,1092926436,2496269142,257381841,3772900718,1636087230,1477059743,2499234752,3811018894,2675660129,3285975680,90732309,1684827095,1150307763,1723134115,3237045386,1769919919,1240018934,815675215,750138730,2239792499,1234303040,1995484674,138143821,675421338,1145607174,1936608440,3238603024,2345230278,2105974004,323969391,779555213,3004902369,2861610098,1017501463,2098600890,2628620304,2940611490,2682542546,1171473753,3656571411,3687208071,4091869518,393037935,159126506,1662887367,1147106178,391545844,3452332695,1891500680,3016609650,1851642611,546529401,1167818917,3194020571,2848076033,3953471836,575554290,475796850,4134673196,450035699,2351251534,844027695,1080539133,86184846,1554234488,3692025454,1972511363,2018339607,1491841390,1141460869,1061690759,4244549243,2008416118,2351104703,2868147542,1598468138,722020353,1027143159,212344630,1387219594,1725294528,3745187956,2500153616,458938280,4129215917,1828119673,544571780,3503225445,2297937496,1241802790,267843827,2694610800,1397140384,1558801448,3782667683,1806446719,929573330,2234912681,400817706,616011623,4121520928,3603768725,1761550015,1968522284,4053731006,4192232858,4005120285,872482584,3140537016,3894607381,2287405443,1963876937,3663887957,1584857e3,2975024454,1833426440,4025083860],_[5]=[4143615901,749497569,1285769319,3795025788,2514159847,23610292,3974978748,844452780,3214870880,3751928557,2213566365,1676510905,448177848,3730751033,4086298418,2307502392,871450977,3222878141,4110862042,3831651966,2735270553,1310974780,2043402188,1218528103,2736035353,4274605013,2702448458,3936360550,2693061421,162023535,2827510090,687910808,23484817,3784910947,3371371616,779677500,3503626546,3473927188,4157212626,3500679282,4248902014,2466621104,3899384794,1958663117,925738300,1283408968,3669349440,1840910019,137959847,2679828185,1239142320,1315376211,1547541505,1690155329,739140458,3128809933,3933172616,3876308834,905091803,1548541325,4040461708,3095483362,144808038,451078856,676114313,2861728291,2469707347,993665471,373509091,2599041286,4025009006,4170239449,2149739950,3275793571,3749616649,2794760199,1534877388,572371878,2590613551,1753320020,3467782511,1405125690,4270405205,633333386,3026356924,3475123903,632057672,2846462855,1404951397,3882875879,3915906424,195638627,2385783745,3902872553,1233155085,3355999740,2380578713,2702246304,2144565621,3663341248,3894384975,2502479241,4248018925,3094885567,1594115437,572884632,3385116731,767645374,1331858858,1475698373,3793881790,3532746431,1321687957,619889600,1121017241,3440213920,2070816767,2833025776,1933951238,4095615791,890643334,3874130214,859025556,360630002,925594799,1764062180,3920222280,4078305929,979562269,2810700344,4087740022,1949714515,546639971,1165388173,3069891591,1495988560,922170659,1291546247,2107952832,1813327274,3406010024,3306028637,4241950635,153207855,2313154747,1608695416,1150242611,1967526857,721801357,1220138373,3691287617,3356069787,2112743302,3281662835,1111556101,1778980689,250857638,2298507990,673216130,2846488510,3207751581,3562756981,3008625920,3417367384,2198807050,529510932,3547516680,3426503187,2364944742,102533054,2294910856,1617093527,1204784762,3066581635,1019391227,1069574518,1317995090,1691889997,3661132003,510022745,3238594800,1362108837,1817929911,2184153760,805817662,1953603311,3699844737,120799444,2118332377,207536705,2282301548,4120041617,145305846,2508124933,3086745533,3261524335,1877257368,2977164480,3160454186,2503252186,4221677074,759945014,254147243,2767453419,3801518371,629083197,2471014217,907280572,3900796746,940896768,2751021123,2625262786,3161476951,3661752313,3260732218,1425318020,2977912069,1496677566,3988592072,2140652971,3126511541,3069632175,977771578,1392695845,1698528874,1411812681,1369733098,1343739227,3620887944,1142123638,67414216,3102056737,3088749194,1626167401,2546293654,3941374235,697522451,33404913,143560186,2595682037,994885535,1247667115,3859094837,2699155541,3547024625,4114935275,2968073508,3199963069,2732024527,1237921620,951448369,1898488916,1211705605,2790989240,2233243581,3598044975],_[6]=[2246066201,858518887,1714274303,3485882003,713916271,2879113490,3730835617,539548191,36158695,1298409750,419087104,1358007170,749914897,2989680476,1261868530,2995193822,2690628854,3443622377,3780124940,3796824509,2976433025,4259637129,1551479e3,512490819,1296650241,951993153,2436689437,2460458047,144139966,3136204276,310820559,3068840729,643875328,1969602020,1680088954,2185813161,3283332454,672358534,198762408,896343282,276269502,3014846926,84060815,197145886,376173866,3943890818,3813173521,3545068822,1316698879,1598252827,2633424951,1233235075,859989710,2358460855,3503838400,3409603720,1203513385,1193654839,2792018475,2060853022,207403770,1144516871,3068631394,1121114134,177607304,3785736302,326409831,1929119770,2983279095,4183308101,3474579288,3200513878,3228482096,119610148,1170376745,3378393471,3163473169,951863017,3337026068,3135789130,2907618374,1183797387,2015970143,4045674555,2182986399,2952138740,3928772205,384012900,2454997643,10178499,2879818989,2596892536,111523738,2995089006,451689641,3196290696,235406569,1441906262,3890558523,3013735005,4158569349,1644036924,376726067,1006849064,3664579700,2041234796,1021632941,1374734338,2566452058,371631263,4007144233,490221539,206551450,3140638584,1053219195,1853335209,3412429660,3562156231,735133835,1623211703,3104214392,2738312436,4096837757,3366392578,3110964274,3956598718,3196820781,2038037254,3877786376,2339753847,300912036,3766732888,2372630639,1516443558,4200396704,1574567987,4069441456,4122592016,2699739776,146372218,2748961456,2043888151,35287437,2596680554,655490400,1132482787,110692520,1031794116,2188192751,1324057718,1217253157,919197030,686247489,3261139658,1028237775,3135486431,3059715558,2460921700,986174950,2661811465,4062904701,2752986992,3709736643,367056889,1353824391,731860949,1650113154,1778481506,784341916,357075625,3608602432,1074092588,2480052770,3811426202,92751289,877911070,3600361838,1231880047,480201094,3756190983,3094495953,434011822,87971354,363687820,1717726236,1901380172,3926403882,2481662265,400339184,1490350766,2661455099,1389319756,2558787174,784598401,1983468483,30828846,3550527752,2716276238,3841122214,1765724805,1955612312,1277890269,1333098070,1564029816,2704417615,1026694237,3287671188,1260819201,3349086767,1016692350,1582273796,1073413053,1995943182,694588404,1025494639,3323872702,3551898420,4146854327,453260480,1316140391,1435673405,3038941953,3486689407,1622062951,403978347,817677117,950059133,4246079218,3278066075,1486738320,1417279718,481875527,2549965225,3933690356,760697757,1452955855,3897451437,1177426808,1702951038,4085348628,2447005172,1084371187,3516436277,3068336338,1073369276,1027665953,3284188590,1230553676,1368340146,2226246512,267243139,2274220762,4070734279,2497715176,2423353163,2504755875],_[7]=[3793104909,3151888380,2817252029,895778965,2005530807,3871412763,237245952,86829237,296341424,3851759377,3974600970,2475086196,709006108,1994621201,2972577594,937287164,3734691505,168608556,3189338153,2225080640,3139713551,3033610191,3025041904,77524477,185966941,1208824168,2344345178,1721625922,3354191921,1066374631,1927223579,1971335949,2483503697,1551748602,2881383779,2856329572,3003241482,48746954,1398218158,2050065058,313056748,4255789917,393167848,1912293076,940740642,3465845460,3091687853,2522601570,2197016661,1727764327,364383054,492521376,1291706479,3264136376,1474851438,1685747964,2575719748,1619776915,1814040067,970743798,1561002147,2925768690,2123093554,1880132620,3151188041,697884420,2550985770,2607674513,2659114323,110200136,1489731079,997519150,1378877361,3527870668,478029773,2766872923,1022481122,431258168,1112503832,897933369,2635587303,669726182,3383752315,918222264,163866573,3246985393,3776823163,114105080,1903216136,761148244,3571337562,1690750982,3166750252,1037045171,1888456500,2010454850,642736655,616092351,365016990,1185228132,4174898510,1043824992,2023083429,2241598885,3863320456,3279669087,3674716684,108438443,2132974366,830746235,606445527,4173263986,2204105912,1844756978,2532684181,4245352700,2969441100,3796921661,1335562986,4061524517,2720232303,2679424040,634407289,885462008,3294724487,3933892248,2094100220,339117932,4048830727,3202280980,1458155303,2689246273,1022871705,2464987878,3714515309,353796843,2822958815,4256850100,4052777845,551748367,618185374,3778635579,4020649912,1904685140,3069366075,2670879810,3407193292,2954511620,4058283405,2219449317,3135758300,1120655984,3447565834,1474845562,3577699062,550456716,3466908712,2043752612,881257467,869518812,2005220179,938474677,3305539448,3850417126,1315485940,3318264702,226533026,965733244,321539988,1136104718,804158748,573969341,3708209826,937399083,3290727049,2901666755,1461057207,4013193437,4066861423,3242773476,2421326174,1581322155,3028952165,786071460,3900391652,3918438532,1485433313,4023619836,3708277595,3678951060,953673138,1467089153,1930354364,1533292819,2492563023,1346121658,1685000834,1965281866,3765933717,4190206607,2052792609,3515332758,690371149,3125873887,2180283551,2903598061,3933952357,436236910,289419410,14314871,1242357089,2904507907,1616633776,2666382180,585885352,3471299210,2699507360,1432659641,277164553,3354103607,770115018,2303809295,3741942315,3177781868,2853364978,2269453327,3774259834,987383833,1290892879,225909803,1741533526,890078084,1496906255,1111072499,916028167,243534141,1252605537,2204162171,531204876,290011180,3916834213,102027703,237315147,209093447,1486785922,220223953,2758195998,4175039106,82940208,3127791296,2569425252,518464269,1353887104,3941492737,2377294467,3935040926]}function zl(w){this.cast5=new Hl,this.cast5.setKey(w),this.encrypt=function(w){return this.cast5.encrypt(w)}}Ol.keySize=Ol.prototype.keySize=24,Ol.blockSize=Ol.prototype.blockSize=8,zl.blockSize=zl.prototype.blockSize=8,zl.keySize=zl.prototype.keySize=16;const lf=4294967295;function _l(w,O){return(w<<O|w>>>32-O)&lf}function jl(w,O){return w[O]|w[O+1]<<8|w[O+2]<<16|w[O+3]<<24}function ql(w,O,_){w.splice(O,4,255&_,_>>>8&255,_>>>16&255,_>>>24&255)}function Vl(w,O){return w>>>8*O&255}function Jl(w){this.tf=function(){let w=null,O=null,_=-1,N=[],F=[[],[],[],[]];function s(w){return F[0][Vl(w,0)]^F[1][Vl(w,1)]^F[2][Vl(w,2)]^F[3][Vl(w,3)]}function a(w){return F[0][Vl(w,3)]^F[1][Vl(w,0)]^F[2][Vl(w,1)]^F[3][Vl(w,2)]}function o(w,O){let _=s(O[0]),F=a(O[1]);O[2]=_l(O[2]^_+F+N[4*w+8]&lf,31),O[3]=_l(O[3],1)^_+2*F+N[4*w+9]&lf,_=s(O[2]),F=a(O[3]),O[0]=_l(O[0]^_+F+N[4*w+10]&lf,31),O[1]=_l(O[1],1)^_+2*F+N[4*w+11]&lf}function c(w,O){let _=s(O[0]),F=a(O[1]);O[2]=_l(O[2],1)^_+F+N[4*w+10]&lf,O[3]=_l(O[3]^_+2*F+N[4*w+11]&lf,31),_=s(O[2]),F=a(O[3]),O[0]=_l(O[0],1)^_+F+N[4*w+8]&lf,O[1]=_l(O[1]^_+2*F+N[4*w+9]&lf,31)}return{name:"twofish",blocksize:16,open:function(O){let _,H,j,G,z;w=O;const X=[],ee=[],se=[];let ae;const Ae=[];let be,ve,Se;const Ie=[[8,1,7,13,6,15,3,2,0,11,5,9,14,12,10,4],[2,8,11,13,15,7,6,14,3,1,9,4,0,10,12,5]],Be=[[14,12,11,8,1,2,3,5,15,4,10,6,7,0,9,13],[1,14,2,11,4,12,3,7,6,13,10,5,15,9,0,8]],Pe=[[11,10,5,14,6,13,9,0,12,8,15,3,2,4,7,1],[4,12,7,5,1,6,9,10,0,14,13,8,2,11,3,15]],xe=[[13,7,15,4,1,2,6,14,9,11,3,0,8,5,12,10],[11,9,5,1,12,3,13,14,6,4,7,15,2,0,8,10]],De=[0,8,1,9,2,10,3,11,4,12,5,13,6,14,7,15],Ue=[0,9,2,11,4,13,6,15,8,1,10,3,12,5,14,7],Oe=[[],[]],_e=[[],[],[],[]];function B(w){return w^w>>2^[0,90,180,238][3&w]}function S(w){return w^w>>1^w>>2^[0,238,180,90][3&w]}function K(w,O){let _,N,F;for(_=0;_<8;_++)N=O>>>24,O=O<<8&lf|w>>>24,w=w<<8&lf,F=N<<1,128&N&&(F^=333),O^=N^F<<16,F^=N>>>1,1&N&&(F^=166),O^=F<<24|F<<8;return O}function C(w,O){const _=O>>4,N=15&O,F=Ie[w][_^N],H=Be[w][De[N]^Ue[_]];return xe[w][De[H]^Ue[F]]<<4|Pe[w][F^H]}function D(w,O){let _=Vl(w,0),N=Vl(w,1),F=Vl(w,2),H=Vl(w,3);switch(ae){case 4:_=Oe[1][_]^Vl(O[3],0),N=Oe[0][N]^Vl(O[3],1),F=Oe[0][F]^Vl(O[3],2),H=Oe[1][H]^Vl(O[3],3);case 3:_=Oe[1][_]^Vl(O[2],0),N=Oe[1][N]^Vl(O[2],1),F=Oe[0][F]^Vl(O[2],2),H=Oe[0][H]^Vl(O[2],3);case 2:_=Oe[0][Oe[0][_]^Vl(O[1],0)]^Vl(O[0],0),N=Oe[0][Oe[1][N]^Vl(O[1],1)]^Vl(O[0],1),F=Oe[1][Oe[0][F]^Vl(O[1],2)]^Vl(O[0],2),H=Oe[1][Oe[1][H]^Vl(O[1],3)]^Vl(O[0],3)}return _e[0][_]^_e[1][N]^_e[2][F]^_e[3][H]}for(w=w.slice(0,32),_=w.length;16!==_&&24!==_&&32!==_;)w[_++]=0;for(_=0;_<w.length;_+=4)se[_>>2]=jl(w,_);for(_=0;_<256;_++)Oe[0][_]=C(0,_),Oe[1][_]=C(1,_);for(_=0;_<256;_++)be=Oe[1][_],ve=B(be),Se=S(be),_e[0][_]=be+(ve<<8)+(Se<<16)+(Se<<24),_e[2][_]=ve+(Se<<8)+(be<<16)+(Se<<24),be=Oe[0][_],ve=B(be),Se=S(be),_e[1][_]=Se+(Se<<8)+(ve<<16)+(be<<24),_e[3][_]=ve+(be<<8)+(Se<<16)+(ve<<24);for(ae=se.length/2,_=0;_<ae;_++)H=se[_+_],X[_]=H,j=se[_+_+1],ee[_]=j,Ae[ae-_-1]=K(H,j);for(_=0;_<40;_+=2)H=16843009*_,j=H+16843009,H=D(H,X),j=_l(D(j,ee),8),N[_]=H+j&lf,N[_+1]=_l(H+2*j,9);for(_=0;_<256;_++)switch(H=j=G=z=_,ae){case 4:H=Oe[1][H]^Vl(Ae[3],0),j=Oe[0][j]^Vl(Ae[3],1),G=Oe[0][G]^Vl(Ae[3],2),z=Oe[1][z]^Vl(Ae[3],3);case 3:H=Oe[1][H]^Vl(Ae[2],0),j=Oe[1][j]^Vl(Ae[2],1),G=Oe[0][G]^Vl(Ae[2],2),z=Oe[0][z]^Vl(Ae[2],3);case 2:F[0][_]=_e[0][Oe[0][Oe[0][H]^Vl(Ae[1],0)]^Vl(Ae[0],0)],F[1][_]=_e[1][Oe[0][Oe[1][j]^Vl(Ae[1],1)]^Vl(Ae[0],1)],F[2][_]=_e[2][Oe[1][Oe[0][G]^Vl(Ae[1],2)]^Vl(Ae[0],2)],F[3][_]=_e[3][Oe[1][Oe[1][z]^Vl(Ae[1],3)]^Vl(Ae[0],3)]}},close:function(){N=[],F=[[],[],[],[]]},encrypt:function(w,F){O=w,_=F;const H=[jl(O,_)^N[0],jl(O,_+4)^N[1],jl(O,_+8)^N[2],jl(O,_+12)^N[3]];for(let w=0;w<8;w++)o(w,H);return ql(O,_,H[2]^N[4]),ql(O,_+4,H[3]^N[5]),ql(O,_+8,H[0]^N[6]),ql(O,_+12,H[1]^N[7]),_+=16,O},decrypt:function(w,F){O=w,_=F;const H=[jl(O,_)^N[4],jl(O,_+4)^N[5],jl(O,_+8)^N[6],jl(O,_+12)^N[7]];for(let w=7;w>=0;w--)c(w,H);ql(O,_,H[2]^N[0]),ql(O,_+4,H[3]^N[1]),ql(O,_+8,H[0]^N[2]),ql(O,_+12,H[1]^N[3]),_+=16},finalize:function(){return O}}}(),this.tf.open(Array.from(w),0),this.encrypt=function(w){return this.tf.encrypt(Array.from(w),0)}}function Yl(){}function Zl(w){this.bf=new Yl,this.bf.init(w),this.encrypt=function(w){return this.bf.encryptBlock(w)}}Jl.keySize=Jl.prototype.keySize=32,Jl.blockSize=Jl.prototype.blockSize=16,Yl.prototype.BLOCKSIZE=8,Yl.prototype.SBOXES=[[3509652390,2564797868,805139163,3491422135,3101798381,1780907670,3128725573,4046225305,614570311,3012652279,134345442,2240740374,1667834072,1901547113,2757295779,4103290238,227898511,1921955416,1904987480,2182433518,2069144605,3260701109,2620446009,720527379,3318853667,677414384,3393288472,3101374703,2390351024,1614419982,1822297739,2954791486,3608508353,3174124327,2024746970,1432378464,3864339955,2857741204,1464375394,1676153920,1439316330,715854006,3033291828,289532110,2706671279,2087905683,3018724369,1668267050,732546397,1947742710,3462151702,2609353502,2950085171,1814351708,2050118529,680887927,999245976,1800124847,3300911131,1713906067,1641548236,4213287313,1216130144,1575780402,4018429277,3917837745,3693486850,3949271944,596196993,3549867205,258830323,2213823033,772490370,2760122372,1774776394,2652871518,566650946,4142492826,1728879713,2882767088,1783734482,3629395816,2517608232,2874225571,1861159788,326777828,3124490320,2130389656,2716951837,967770486,1724537150,2185432712,2364442137,1164943284,2105845187,998989502,3765401048,2244026483,1075463327,1455516326,1322494562,910128902,469688178,1117454909,936433444,3490320968,3675253459,1240580251,122909385,2157517691,634681816,4142456567,3825094682,3061402683,2540495037,79693498,3249098678,1084186820,1583128258,426386531,1761308591,1047286709,322548459,995290223,1845252383,2603652396,3431023940,2942221577,3202600964,3727903485,1712269319,422464435,3234572375,1170764815,3523960633,3117677531,1434042557,442511882,3600875718,1076654713,1738483198,4213154764,2393238008,3677496056,1014306527,4251020053,793779912,2902807211,842905082,4246964064,1395751752,1040244610,2656851899,3396308128,445077038,3742853595,3577915638,679411651,2892444358,2354009459,1767581616,3150600392,3791627101,3102740896,284835224,4246832056,1258075500,768725851,2589189241,3069724005,3532540348,1274779536,3789419226,2764799539,1660621633,3471099624,4011903706,913787905,3497959166,737222580,2514213453,2928710040,3937242737,1804850592,3499020752,2949064160,2386320175,2390070455,2415321851,4061277028,2290661394,2416832540,1336762016,1754252060,3520065937,3014181293,791618072,3188594551,3933548030,2332172193,3852520463,3043980520,413987798,3465142937,3030929376,4245938359,2093235073,3534596313,375366246,2157278981,2479649556,555357303,3870105701,2008414854,3344188149,4221384143,3956125452,2067696032,3594591187,2921233993,2428461,544322398,577241275,1471733935,610547355,4027169054,1432588573,1507829418,2025931657,3646575487,545086370,48609733,2200306550,1653985193,298326376,1316178497,3007786442,2064951626,458293330,2589141269,3591329599,3164325604,727753846,2179363840,146436021,1461446943,4069977195,705550613,3059967265,3887724982,4281599278,3313849956,1404054877,2845806497,146425753,1854211946],[1266315497,3048417604,3681880366,3289982499,290971e4,1235738493,2632868024,2414719590,3970600049,1771706367,1449415276,3266420449,422970021,1963543593,2690192192,3826793022,1062508698,1531092325,1804592342,2583117782,2714934279,4024971509,1294809318,4028980673,1289560198,2221992742,1669523910,35572830,157838143,1052438473,1016535060,1802137761,1753167236,1386275462,3080475397,2857371447,1040679964,2145300060,2390574316,1461121720,2956646967,4031777805,4028374788,33600511,2920084762,1018524850,629373528,3691585981,3515945977,2091462646,2486323059,586499841,988145025,935516892,3367335476,2599673255,2839830854,265290510,3972581182,2759138881,3795373465,1005194799,847297441,406762289,1314163512,1332590856,1866599683,4127851711,750260880,613907577,1450815602,3165620655,3734664991,3650291728,3012275730,3704569646,1427272223,778793252,1343938022,2676280711,2052605720,1946737175,3164576444,3914038668,3967478842,3682934266,1661551462,3294938066,4011595847,840292616,3712170807,616741398,312560963,711312465,1351876610,322626781,1910503582,271666773,2175563734,1594956187,70604529,3617834859,1007753275,1495573769,4069517037,2549218298,2663038764,504708206,2263041392,3941167025,2249088522,1514023603,1998579484,1312622330,694541497,2582060303,2151582166,1382467621,776784248,2618340202,3323268794,2497899128,2784771155,503983604,4076293799,907881277,423175695,432175456,1378068232,4145222326,3954048622,3938656102,3820766613,2793130115,2977904593,26017576,3274890735,3194772133,1700274565,1756076034,4006520079,3677328699,720338349,1533947780,354530856,688349552,3973924725,1637815568,332179504,3949051286,53804574,2852348879,3044236432,1282449977,3583942155,3416972820,4006381244,1617046695,2628476075,3002303598,1686838959,431878346,2686675385,1700445008,1080580658,1009431731,832498133,3223435511,2605976345,2271191193,2516031870,1648197032,4164389018,2548247927,300782431,375919233,238389289,3353747414,2531188641,2019080857,1475708069,455242339,2609103871,448939670,3451063019,1395535956,2413381860,1841049896,1491858159,885456874,4264095073,4001119347,1565136089,3898914787,1108368660,540939232,1173283510,2745871338,3681308437,4207628240,3343053890,4016749493,1699691293,1103962373,3625875870,2256883143,3830138730,1031889488,3479347698,1535977030,4236805024,3251091107,2132092099,1774941330,1199868427,1452454533,157007616,2904115357,342012276,595725824,1480756522,206960106,497939518,591360097,863170706,2375253569,3596610801,1814182875,2094937945,3421402208,1082520231,3463918190,2785509508,435703966,3908032597,1641649973,2842273706,3305899714,1510255612,2148256476,2655287854,3276092548,4258621189,236887753,3681803219,274041037,1734335097,3815195456,3317970021,1899903192,1026095262,4050517792,356393447,2410691914,3873677099,3682840055],[3913112168,2491498743,4132185628,2489919796,1091903735,1979897079,3170134830,3567386728,3557303409,857797738,1136121015,1342202287,507115054,2535736646,337727348,3213592640,1301675037,2528481711,1895095763,1721773893,3216771564,62756741,2142006736,835421444,2531993523,1442658625,3659876326,2882144922,676362277,1392781812,170690266,3921047035,1759253602,3611846912,1745797284,664899054,1329594018,3901205900,3045908486,2062866102,2865634940,3543621612,3464012697,1080764994,553557557,3656615353,3996768171,991055499,499776247,1265440854,648242737,3940784050,980351604,3713745714,1749149687,3396870395,4211799374,3640570775,1161844396,3125318951,1431517754,545492359,4268468663,3499529547,1437099964,2702547544,3433638243,2581715763,2787789398,1060185593,1593081372,2418618748,4260947970,69676912,2159744348,86519011,2512459080,3838209314,1220612927,3339683548,133810670,1090789135,1078426020,1569222167,845107691,3583754449,4072456591,1091646820,628848692,1613405280,3757631651,526609435,236106946,48312990,2942717905,3402727701,1797494240,859738849,992217954,4005476642,2243076622,3870952857,3732016268,765654824,3490871365,2511836413,1685915746,3888969200,1414112111,2273134842,3281911079,4080962846,172450625,2569994100,980381355,4109958455,2819808352,2716589560,2568741196,3681446669,3329971472,1835478071,660984891,3704678404,4045999559,3422617507,3040415634,1762651403,1719377915,3470491036,2693910283,3642056355,3138596744,1364962596,2073328063,1983633131,926494387,3423689081,2150032023,4096667949,1749200295,3328846651,309677260,2016342300,1779581495,3079819751,111262694,1274766160,443224088,298511866,1025883608,3806446537,1145181785,168956806,3641502830,3584813610,1689216846,3666258015,3200248200,1692713982,2646376535,4042768518,1618508792,1610833997,3523052358,4130873264,2001055236,3610705100,2202168115,4028541809,2961195399,1006657119,2006996926,3186142756,1430667929,3210227297,1314452623,4074634658,4101304120,2273951170,1399257539,3367210612,3027628629,1190975929,2062231137,2333990788,2221543033,2438960610,1181637006,548689776,2362791313,3372408396,3104550113,3145860560,296247880,1970579870,3078560182,3769228297,1714227617,3291629107,3898220290,166772364,1251581989,493813264,448347421,195405023,2709975567,677966185,3703036547,1463355134,2715995803,1338867538,1343315457,2802222074,2684532164,233230375,2599980071,2000651841,3277868038,1638401717,4028070440,3237316320,6314154,819756386,300326615,590932579,1405279636,3267499572,3150704214,2428286686,3959192993,3461946742,1862657033,1266418056,963775037,2089974820,2263052895,1917689273,448879540,3550394620,3981727096,150775221,3627908307,1303187396,508620638,2975983352,2726630617,1817252668,1876281319,1457606340,908771278,3720792119,3617206836,2455994898,1729034894,1080033504],[976866871,3556439503,2881648439,1522871579,1555064734,1336096578,3548522304,2579274686,3574697629,3205460757,3593280638,3338716283,3079412587,564236357,2993598910,1781952180,1464380207,3163844217,3332601554,1699332808,1393555694,1183702653,3581086237,1288719814,691649499,2847557200,2895455976,3193889540,2717570544,1781354906,1676643554,2592534050,3230253752,1126444790,2770207658,2633158820,2210423226,2615765581,2414155088,3127139286,673620729,2805611233,1269405062,4015350505,3341807571,4149409754,1057255273,2012875353,2162469141,2276492801,2601117357,993977747,3918593370,2654263191,753973209,36408145,2530585658,25011837,3520020182,2088578344,530523599,2918365339,1524020338,1518925132,3760827505,3759777254,1202760957,3985898139,3906192525,674977740,4174734889,2031300136,2019492241,3983892565,4153806404,3822280332,352677332,2297720250,60907813,90501309,3286998549,1016092578,2535922412,2839152426,457141659,509813237,4120667899,652014361,1966332200,2975202805,55981186,2327461051,676427537,3255491064,2882294119,3433927263,1307055953,942726286,933058658,2468411793,3933900994,4215176142,1361170020,2001714738,2830558078,3274259782,1222529897,1679025792,2729314320,3714953764,1770335741,151462246,3013232138,1682292957,1483529935,471910574,1539241949,458788160,3436315007,1807016891,3718408830,978976581,1043663428,3165965781,1927990952,4200891579,2372276910,3208408903,3533431907,1412390302,2931980059,4132332400,1947078029,3881505623,4168226417,2941484381,1077988104,1320477388,886195818,18198404,3786409e3,2509781533,112762804,3463356488,1866414978,891333506,18488651,661792760,1628790961,3885187036,3141171499,876946877,2693282273,1372485963,791857591,2686433993,3759982718,3167212022,3472953795,2716379847,445679433,3561995674,3504004811,3574258232,54117162,3331405415,2381918588,3769707343,4154350007,1140177722,4074052095,668550556,3214352940,367459370,261225585,2610173221,4209349473,3468074219,3265815641,314222801,3066103646,3808782860,282218597,3406013506,3773591054,379116347,1285071038,846784868,2669647154,3771962079,3550491691,2305946142,453669953,1268987020,3317592352,3279303384,3744833421,2610507566,3859509063,266596637,3847019092,517658769,3462560207,3443424879,370717030,4247526661,2224018117,4143653529,4112773975,2788324899,2477274417,1456262402,2901442914,1517677493,1846949527,2295493580,3734397586,2176403920,1280348187,1908823572,3871786941,846861322,1172426758,3287448474,3383383037,1655181056,3139813346,901632758,1897031941,2986607138,3066810236,3447102507,1393639104,373351379,950779232,625454576,3124240540,4148612726,2007998917,544563296,2244738638,2330496472,2058025392,1291430526,424198748,50039436,29584100,3605783033,2429876329,2791104160,1057563949,3255363231,3075367218,3463963227,1469046755,985887462]],Yl.prototype.PARRAY=[608135816,2242054355,320440878,57701188,2752067618,698298832,137296536,3964562569,1160258022,953160567,3193202383,887688300,3232508343,3380367581,1065670069,3041331479,2450970073,2306472731],Yl.prototype.NN=16,Yl.prototype._clean=function(w){if(w<0){w=(2147483647&w)+2147483648}return w},Yl.prototype._F=function(w){let O;const _=255&w,N=255&(w>>>=8),F=255&(w>>>=8),H=255&(w>>>=8);return O=this.sboxes[0][H]+this.sboxes[1][F],O^=this.sboxes[2][N],O+=this.sboxes[3][_],O},Yl.prototype._encryptBlock=function(w){let O,_=w[0],N=w[1];for(O=0;O<this.NN;++O){_^=this.parray[O],N=this._F(_)^N;const w=_;_=N,N=w}_^=this.parray[this.NN+0],N^=this.parray[this.NN+1],w[0]=this._clean(N),w[1]=this._clean(_)},Yl.prototype.encryptBlock=function(w){let O;const _=[0,0],N=this.BLOCKSIZE/2;for(O=0;O<this.BLOCKSIZE/2;++O)_[0]=_[0]<<8|255&w[O+0],_[1]=_[1]<<8|255&w[O+N];this._encryptBlock(_);const F=[];for(O=0;O<this.BLOCKSIZE/2;++O)F[O+0]=_[0]>>>24-8*O&255,F[O+N]=_[1]>>>24-8*O&255;return F},Yl.prototype._decryptBlock=function(w){let O,_=w[0],N=w[1];for(O=this.NN+1;O>1;--O){_^=this.parray[O],N=this._F(_)^N;const w=_;_=N,N=w}_^=this.parray[1],N^=this.parray[0],w[0]=this._clean(N),w[1]=this._clean(_)},Yl.prototype.init=function(w){let O,_=0;for(this.parray=[],O=0;O<this.NN+2;++O){let N=0;for(let O=0;O<4;++O)N=N<<8|255&w[_],++_>=w.length&&(_=0);this.parray[O]=this.PARRAY[O]^N}for(this.sboxes=[],O=0;O<4;++O)for(this.sboxes[O]=[],_=0;_<256;++_)this.sboxes[O][_]=this.SBOXES[O][_];const N=[0,0];for(O=0;O<this.NN+2;O+=2)this._encryptBlock(N),this.parray[O+0]=N[0],this.parray[O+1]=N[1];for(O=0;O<4;++O)for(_=0;_<256;_+=2)this._encryptBlock(N),this.sboxes[O][_+0]=N[0],this.sboxes[O][_+1]=N[1]},Zl.keySize=Zl.prototype.keySize=16,Zl.blockSize=Zl.prototype.blockSize=8;const ff=new Map(Object.entries({tripledes:Ol,cast5:zl,twofish:Jl,blowfish:Zl}));var yf=Object.freeze({__proto__:null,legacyCiphers:ff});function Xl(w,O,_,N){w[O]+=_[N],w[O+1]+=_[N+1]+(w[O]<_[N])}function ey(w,O){w[0]+=O,w[1]+=w[0]<O}function ty(w,O,_,N,F,H,j,G){Xl(w,_,w,N),Xl(w,_,O,j);let z=w[H]^w[_],X=w[H+1]^w[_+1];w[H]=X,w[H+1]=z,Xl(w,F,w,H),z=w[N]^w[F],X=w[N+1]^w[F+1],w[N]=z>>>24^X<<8,w[N+1]=X>>>24^z<<8,Xl(w,_,w,N),Xl(w,_,O,G),z=w[H]^w[_],X=w[H+1]^w[_+1],w[H]=z>>>16^X<<16,w[H+1]=X>>>16^z<<16,Xl(w,F,w,H),z=w[N]^w[F],X=w[N+1]^w[F+1],w[N]=X>>>31^z<<1,w[N+1]=z>>>31^X<<1}const df=new Uint32Array([4089235720,1779033703,2227873595,3144134277,4271175723,1013904242,1595750129,2773480762,2917565137,1359893119,725511199,2600822924,4215389547,528734635,327033209,1541459225]),pf=new Uint8Array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9,12,5,1,15,14,13,4,10,0,7,6,3,9,2,8,11,13,11,7,14,12,1,3,9,5,0,15,4,8,6,2,10,6,15,14,9,11,3,0,8,12,2,13,7,1,4,10,5,10,2,8,4,7,6,1,5,15,11,9,14,3,12,13,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3].map((w=>2*w)));function iy(w,O){const _=new Uint32Array(32),N=new Uint32Array(w.b.buffer,w.b.byteOffset,32);for(let O=0;O<16;O++)_[O]=w.h[O],_[O+16]=df[O];_[24]^=w.t0[0],_[25]^=w.t0[1];const F=O?4294967295:0;_[28]^=F,_[29]^=F;for(let w=0;w<12;w++){const O=w<<4;ty(_,N,0,8,16,24,pf[O+0],pf[O+1]),ty(_,N,2,10,18,26,pf[O+2],pf[O+3]),ty(_,N,4,12,20,28,pf[O+4],pf[O+5]),ty(_,N,6,14,22,30,pf[O+6],pf[O+7]),ty(_,N,0,10,20,30,pf[O+8],pf[O+9]),ty(_,N,2,12,22,24,pf[O+10],pf[O+11]),ty(_,N,4,14,16,26,pf[O+12],pf[O+13]),ty(_,N,6,8,18,28,pf[O+14],pf[O+15])}for(let O=0;O<16;O++)w.h[O]^=_[O]^_[O+16]}class sy{constructor(w,O,_,N){const F=new Uint8Array(64);this.S={b:new Uint8Array(wf),h:new Uint32Array(gf/4),t0:new Uint32Array(2),c:0,outlen:w},F[0]=w,O&&(F[1]=O.length),F[2]=1,F[3]=1,_&&F.set(_,32),N&&F.set(N,48);const H=new Uint32Array(F.buffer,F.byteOffset,F.length/Uint32Array.BYTES_PER_ELEMENT);for(let w=0;w<16;w++)this.S.h[w]=df[w]^H[w];if(O){const w=new Uint8Array(wf);w.set(O),this.update(w)}}update(w){if(!(w instanceof Uint8Array))throw Error("Input must be Uint8Array or Buffer");let O=0;for(;O<w.length;){this.S.c===wf&&(ey(this.S.t0,this.S.c),iy(this.S,!1),this.S.c=0);let _=wf-this.S.c;this.S.b.set(w.subarray(O,O+_),this.S.c);const N=Math.min(_,w.length-O);this.S.c+=N,O+=N}return this}digest(w){ey(this.S.t0,this.S.c),this.S.b.fill(0,this.S.c),this.S.c=wf,iy(this.S,!0);const O=w||new Uint8Array(this.S.outlen);for(let w=0;w<this.S.outlen;w++)O[w]=this.S.h[w>>2]>>8*(3&w);return this.S.h=null,O.buffer}}function ay(w,O,_,N){if(w>gf)throw Error(`outlen must be at most ${gf} (given: ${w})`);return new sy(w,O,_,N)}const gf=64,wf=128,mf=2,Af=19,bf=4294967295,vf=4,Ef=4294967295,kf=8,Sf=4294967295,If=8,Bf=4294967295,Cf=4294967295,Pf=32,Kf=1024,xf=64,Df=205===new Uint8Array(new Uint16Array([43981]).buffer)[0];function vy(w,O,_){return w[_+0]=O,w[_+1]=O>>8,w[_+2]=O>>16,w[_+3]=O>>24,w}function Iy(w,O,_){if(O>Number.MAX_SAFE_INTEGER)throw Error("LE64: large numbers unsupported");let N=O;for(let O=_;O<_+7;O++)w[O]=N,N=(N-w[O])/256;return w}function By(w,O,_){const N=new Uint8Array(64),F=new Uint8Array(4+O.length);if(vy(F,w,0),F.set(O,4),w<=64)return ay(w).update(F).digest(_),_;const H=Math.ceil(w/32)-2;for(let w=0;w<H;w++)ay(64).update(0===w?F:N).digest(N),_.set(N.subarray(0,32),32*w);const j=new Uint8Array(ay(w-32*H).update(N).digest());return _.set(j,32*H),_}function Sy(w,O,_,N){return w.fn.XOR(O.byteOffset,_.byteOffset,N.byteOffset),O}function Ky(w,O,_,N){return w.fn.G(O.byteOffset,_.byteOffset,N.byteOffset,w.refs.gZ.byteOffset),N}function Cy(w,O,_,N){return w.fn.G2(O.byteOffset,_.byteOffset,N.byteOffset,w.refs.gZ.byteOffset),N}function*Dy(w,O,_,N,F,H,j,G){w.refs.prngTmp.fill(0);const z=w.refs.prngTmp.subarray(0,48);Iy(z,O,0),Iy(z,_,8),Iy(z,N,16),Iy(z,F,24),Iy(z,H,32),Iy(z,mf,40);for(let O=1;O<=j;O++){Iy(w.refs.prngTmp,O,z.length);const _=Cy(w,w.refs.ZERO1024,w.refs.prngTmp,w.refs.prngR);for(let w=1===O?8*G:0;w<_.length;w+=8)yield _.subarray(w,w+8)}return[]}const Uf=1024,Of=64*Uf;function xy(w,{memory:O,instance:_}){if(!Df)throw Error("BigEndian system not supported");const N=function({type:w,version:O,tagLength:_,password:N,salt:F,ad:H,secret:j,parallelism:G,memorySize:z,passes:X}){const u=(w,O,_,N)=>{if(O<_||O>N)throw Error(`${w} size should be between ${_} and ${N} bytes`)};if(w!==mf||O!==Af)throw Error("Unsupported type or version");return u("password",N,If,Sf),u("salt",F,kf,Ef),u("tag",_,vf,bf),u("memory",z,8*G,Bf),H&&u("associated data",H,0,Cf),j&&u("secret",j,0,Pf),{type:w,version:O,tagLength:_,password:N,salt:F,ad:H,secret:j,lanes:G,memorySize:z,passes:X}}({type:mf,version:Af,...w}),{G:F,G2:H,xor:j,getLZ:G}=_.exports,z={},X={};X.G=F,X.G2=H,X.XOR=j;const ee=4*N.lanes*Math.floor(N.memorySize/(4*N.lanes)),se=ee*Kf+10*Uf;if(O.buffer.byteLength<se){const w=Math.ceil((se-O.buffer.byteLength)/Of);O.grow(w)}let ae=0;z.gZ=new Uint8Array(O.buffer,ae,Kf),ae+=z.gZ.length,z.prngR=new Uint8Array(O.buffer,ae,Kf),ae+=z.prngR.length,z.prngTmp=new Uint8Array(O.buffer,ae,Kf),ae+=z.prngTmp.length,z.ZERO1024=new Uint8Array(O.buffer,ae,1024),ae+=z.ZERO1024.length;const Ae=new Uint32Array(O.buffer,ae,2);ae+=Ae.length*Uint32Array.BYTES_PER_ELEMENT;const be={fn:X,refs:z},ve=new Uint8Array(O.buffer,ae,Kf);ae+=ve.length;const Se=new Uint8Array(O.buffer,ae,N.memorySize*Kf),Ie=new Uint8Array(O.buffer,0,ae),Be=function(w){const O=ay(xf),_=new Uint8Array(4),N=new Uint8Array(24);vy(N,w.lanes,0),vy(N,w.tagLength,4),vy(N,w.memorySize,8),vy(N,w.passes,12),vy(N,w.version,16),vy(N,w.type,20);const F=[N];w.password?(F.push(vy(new Uint8Array(4),w.password.length,0)),F.push(w.password)):F.push(_);w.salt?(F.push(vy(new Uint8Array(4),w.salt.length,0)),F.push(w.salt)):F.push(_);w.secret?(F.push(vy(new Uint8Array(4),w.secret.length,0)),F.push(w.secret)):F.push(_);w.ad?(F.push(vy(new Uint8Array(4),w.ad.length,0)),F.push(w.ad)):F.push(_);O.update(function(w){if(1===w.length)return w[0];let O=0;for(let _=0;_<w.length;_++){if(!(w[_]instanceof Uint8Array))throw Error("concatArrays: Data must be in the form of a Uint8Array");O+=w[_].length}const _=new Uint8Array(O);let N=0;return w.forEach((w=>{_.set(w,N),N+=w.length})),_}(F));const H=O.digest();return new Uint8Array(H)}(N),Pe=ee/N.lanes,xe=Array(N.lanes).fill(null).map((()=>Array(Pe))),k=(w,O)=>(xe[w][O]=Se.subarray(w*Pe*1024+1024*O,w*Pe*1024+1024*O+Kf),xe[w][O]);for(let w=0;w<N.lanes;w++){const O=new Uint8Array(Be.length+8);O.set(Be),vy(O,0,Be.length),vy(O,w,Be.length+4),By(Kf,O,k(w,0)),vy(O,1,Be.length),By(Kf,O,k(w,1))}const De=Pe/4;for(let w=0;w<N.passes;w++)for(let O=0;O<4;O++){const _=0===w&&O<=1;for(let F=0;F<N.lanes;F++){let H=0===O&&0===w?2:0;const j=_?Dy(be,w,F,O,ee,N.passes,De,H):null;for(;H<De;H++){const z=O*De+H,X=z>0?xe[F][z-1]:xe[F][Pe-1],ee=_?j.next().value:X;G(Ae.byteOffset,ee.byteOffset,F,N.lanes,w,O,H,4,De);const se=Ae[0],ae=Ae[1];0===w&&k(F,z),Ky(be,X,xe[se][ae],w>0?ve:xe[F][z]),w>0&&Sy(be,xe[F][z],ve,xe[F][z])}}}const Ue=xe[0][Pe-1];for(let w=1;w<N.lanes;w++)Sy(be,Ue,Ue,xe[w][Pe-1]);const Oe=By(N.tagLength,Ue,new Uint8Array(N.tagLength));return Ie.fill(0),O.grow(0),Oe}let _f;async function Ry(w,O){const _=new WebAssembly.Memory({initial:1040,maximum:65536}),N=await async function(w,O,_){const N={env:{memory:w}};if(void 0===_f)try{const w=await O(N);return _f=!0,w}catch(w){_f=!1}return(_f?O:_)(N)}(_,w,O);return w=>xy(w,{instance:N.instance,memory:_})}function Ty(w,O,_,N){return function(w,O){var _=WebAssembly.instantiate,N=WebAssembly.compile;return O?_(w,O):N(w)}(Buffer.from(_,"base64"),N)}var Rf=Object.freeze({__proto__:null,default:async()=>Ry((w=>Ty(0,0,"AGFzbQEAAAABKwdgBH9/f38AYAABf2AAAGADf39/AGAJf39/f39/f39/AX9gAX8AYAF/AX8CEwEDZW52Bm1lbW9yeQIBkAiAgAQDCgkCAwAABAEFBgEEBQFwAQICBgkBfwFBkIjAAgsHfQoDeG9yAAEBRwACAkcyAAMFZ2V0TFoABBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALX2luaXRpYWxpemUAABBfX2Vycm5vX2xvY2F0aW9uAAgJc3RhY2tTYXZlAAUMc3RhY2tSZXN0b3JlAAYKc3RhY2tBbGxvYwAHCQcBAEEBCwEACs0gCQMAAQtYAQJ/A0AgACAEQQR0IgNqIAIgA2r9AAQAIAEgA2r9AAQA/VH9CwQAIAAgA0EQciIDaiACIANq/QAEACABIANq/QAEAP1R/QsEACAEQQJqIgRBwABHDQALC7ceAgt7A38DQCADIBFBBHQiD2ogASAPav0ABAAgACAPav0ABAD9USIF/QsEACACIA9qIAX9CwQAIAMgD0EQciIPaiABIA9q/QAEACAAIA9q/QAEAP1RIgX9CwQAIAIgD2ogBf0LBAAgEUECaiIRQcAARw0ACwNAIAMgEEEHdGoiAEEQaiAA/QAEcCAA/QAEMCIFIAD9AAQQIgT9zgEgBSAF/Q0AAQIDCAkKCwABAgMICQoLIAQgBP0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgT9USIJQSD9ywEgCUEg/c0B/VAiCSAA/QAEUCIG/c4BIAkgCf0NAAECAwgJCgsAAQIDCAkKCyAGIAb9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIGIAX9USIFQSj9ywEgBUEY/c0B/VAiCCAE/c4BIAggCP0NAAECAwgJCgsAAQIDCAkKCyAEIAT9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIKIAogCf1RIgVBMP3LASAFQRD9zQH9UCIFIAb9zgEgBSAF/Q0AAQIDCAkKCwABAgMICQoLIAYgBv0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgkgCP1RIgRBAf3LASAEQT/9zQH9UCIMIAD9AARgIAD9AAQgIgQgAP0ABAAiBv3OASAEIAT9DQABAgMICQoLAAECAwgJCgsgBiAG/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBv1RIghBIP3LASAIQSD9zQH9UCIIIABBQGsiAf0ABAAiB/3OASAIIAj9DQABAgMICQoLAAECAwgJCgsgByAH/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiByAE/VEiBEEo/csBIARBGP3NAf1QIgsgBv3OASALIAv9DQABAgMICQoLAAECAwgJCgsgBiAG/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBiAI/VEiBEEw/csBIARBEP3NAf1QIgQgB/3OASAEIAT9DQABAgMICQoLAAECAwgJCgsgByAH/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiCCAL/VEiB0EB/csBIAdBP/3NAf1QIg0gDf0NAAECAwQFBgcQERITFBUWF/0NCAkKCwwNDg8YGRobHB0eHyIH/c4BIAcgB/0NAAECAwgJCgsAAQIDCAkKCyAKIAr9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIKIAQgBSAF/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4f/VEiC0Eg/csBIAtBIP3NAf1QIgsgCP3OASALIAv9DQABAgMICQoLAAECAwgJCgsgCCAI/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiCCAH/VEiB0Eo/csBIAdBGP3NAf1QIgcgCv3OASAHIAf9DQABAgMICQoLAAECAwgJCgsgCiAK/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiDv0LBAAgACAGIA0gDCAM/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4fIgr9zgEgCiAK/Q0AAQIDCAkKCwABAgMICQoLIAYgBv0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgYgBSAEIAT9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh/9USIFQSD9ywEgBUEg/c0B/VAiBSAJ/c4BIAUgBf0NAAECAwgJCgsAAQIDCAkKCyAJIAn9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIJIAr9USIEQSj9ywEgBEEY/c0B/VAiCiAG/c4BIAogCv0NAAECAwgJCgsAAQIDCAkKCyAGIAb9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIE/QsEACAAIAQgBf1RIgVBMP3LASAFQRD9zQH9UCIFIA4gC/1RIgRBMP3LASAEQRD9zQH9UCIEIAT9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh/9CwRgIAAgBCAFIAX9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh/9CwRwIAEgBCAI/c4BIAQgBP0NAAECAwgJCgsAAQIDCAkKCyAIIAj9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIE/QsEACAAIAUgCf3OASAFIAX9DQABAgMICQoLAAECAwgJCgsgCSAJ/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiCf0LBFAgACAEIAf9USIFQQH9ywEgBUE//c0B/VAiBSAJIAr9USIEQQH9ywEgBEE//c0B/VAiBCAE/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4f/QsEICAAIAQgBSAF/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4f/QsEMCAQQQFqIhBBCEcNAAtBACEQA0AgAyAQQQR0aiIAQYABaiAA/QAEgAcgAP0ABIADIgUgAP0ABIABIgT9zgEgBSAF/Q0AAQIDCAkKCwABAgMICQoLIAQgBP0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgT9USIJQSD9ywEgCUEg/c0B/VAiCSAA/QAEgAUiBv3OASAJIAn9DQABAgMICQoLAAECAwgJCgsgBiAG/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBiAF/VEiBUEo/csBIAVBGP3NAf1QIgggBP3OASAIIAj9DQABAgMICQoLAAECAwgJCgsgBCAE/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiCiAKIAn9USIFQTD9ywEgBUEQ/c0B/VAiBSAG/c4BIAUgBf0NAAECAwgJCgsAAQIDCAkKCyAGIAb9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIJIAj9USIEQQH9ywEgBEE//c0B/VAiDCAA/QAEgAYgAP0ABIACIgQgAP0ABAAiBv3OASAEIAT9DQABAgMICQoLAAECAwgJCgsgBiAG/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBv1RIghBIP3LASAIQSD9zQH9UCIIIAD9AASABCIH/c4BIAggCP0NAAECAwgJCgsAAQIDCAkKCyAHIAf9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIHIAT9USIEQSj9ywEgBEEY/c0B/VAiCyAG/c4BIAsgC/0NAAECAwgJCgsAAQIDCAkKCyAGIAb9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIGIAj9USIEQTD9ywEgBEEQ/c0B/VAiBCAH/c4BIAQgBP0NAAECAwgJCgsAAQIDCAkKCyAHIAf9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIIIAv9USIHQQH9ywEgB0E//c0B/VAiDSAN/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4fIgf9zgEgByAH/Q0AAQIDCAkKCwABAgMICQoLIAogCv0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgogBCAFIAX9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh/9USILQSD9ywEgC0Eg/c0B/VAiCyAI/c4BIAsgC/0NAAECAwgJCgsAAQIDCAkKCyAIIAj9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIIIAf9USIHQSj9ywEgB0EY/c0B/VAiByAK/c4BIAcgB/0NAAECAwgJCgsAAQIDCAkKCyAKIAr9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIO/QsEACAAIAYgDSAMIAz9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh8iCv3OASAKIAr9DQABAgMICQoLAAECAwgJCgsgBiAG/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBiAFIAQgBP0NAAECAwQFBgcQERITFBUWF/0NCAkKCwwNDg8YGRobHB0eH/1RIgVBIP3LASAFQSD9zQH9UCIFIAn9zgEgBSAF/Q0AAQIDCAkKCwABAgMICQoLIAkgCf0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgkgCv1RIgRBKP3LASAEQRj9zQH9UCIKIAb9zgEgCiAK/Q0AAQIDCAkKCwABAgMICQoLIAYgBv0NAAECAwgJCgsAAQIDCAkKC/3eAUEB/csB/c4BIgT9CwQAIAAgBCAF/VEiBUEw/csBIAVBEP3NAf1QIgUgDiAL/VEiBEEw/csBIARBEP3NAf1QIgQgBP0NAAECAwQFBgcQERITFBUWF/0NCAkKCwwNDg8YGRobHB0eH/0LBIAGIAAgBCAFIAX9DQABAgMEBQYHEBESExQVFhf9DQgJCgsMDQ4PGBkaGxwdHh/9CwSAByAAIAQgCP3OASAEIAT9DQABAgMICQoLAAECAwgJCgsgCCAI/Q0AAQIDCAkKCwABAgMICQoL/d4BQQH9ywH9zgEiBP0LBIAEIAAgBSAJ/c4BIAUgBf0NAAECAwgJCgsAAQIDCAkKCyAJIAn9DQABAgMICQoLAAECAwgJCgv93gFBAf3LAf3OASIJ/QsEgAUgACAEIAf9USIFQQH9ywEgBUE//c0B/VAiBSAJIAr9USIEQQH9ywEgBEE//c0B/VAiBCAE/Q0AAQIDBAUGBxAREhMUFRYX/Q0ICQoLDA0ODxgZGhscHR4f/QsEgAIgACAEIAUgBf0NAAECAwQFBgcQERITFBUWF/0NCAkKCwwNDg8YGRobHB0eH/0LBIADIBBBAWoiEEEIRw0AC0EAIRADQCACIBBBBHQiAGoiASAAIANq/QAEACAB/QAEAP1R/QsEACACIABBEHIiAWoiDyABIANq/QAEACAP/QAEAP1R/QsEACACIABBIHIiAWoiDyABIANq/QAEACAP/QAEAP1R/QsEACACIABBMHIiAGoiASAAIANq/QAEACAB/QAEAP1R/QsEACAQQQRqIhBBwABHDQALCxYAIAAgASACIAMQAiAAIAIgAiADEAILewIBfwF+IAIhCSABNQIAIQogBCAFcgRAIAEoAgQgA3AhCQsgACAJNgIAIAAgB0EBayAFIAQbIAhsIAZBAWtBAEF/IAYbIAIgCUYbaiIBIAVBAWogCGxBACAEG2ogAa0gCiAKfkIgiH5CIIinQX9zaiAHIAhscDYCBCAACwQAIwALBgAgACQACxAAIwAgAGtBcHEiACQAIAALBQBBgAgL",w)),(w=>Ty(0,0,"AGFzbQEAAAABPwhgBH9/f38AYAABf2AAAGADf39/AGARf39/f39/f39/f39/f39/f38AYAl/f39/f39/f38Bf2ABfwBgAX8BfwITAQNlbnYGbWVtb3J5AgGQCICABAMLCgIDBAAABQEGBwEEBQFwAQICBgkBfwFBkIjAAgsHfQoDeG9yAAEBRwADAkcyAAQFZ2V0TFoABRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALX2luaXRpYWxpemUAABBfX2Vycm5vX2xvY2F0aW9uAAkJc3RhY2tTYXZlAAYMc3RhY2tSZXN0b3JlAAcKc3RhY2tBbGxvYwAICQcBAEEBCwEACssaCgMAAQtQAQJ/A0AgACAEQQN0IgNqIAIgA2opAwAgASADaikDAIU3AwAgACADQQhyIgNqIAIgA2opAwAgASADaikDAIU3AwAgBEECaiIEQYABRw0ACwveDwICfgF/IAAgAUEDdGoiEyATKQMAIhEgACAFQQN0aiIBKQMAIhJ8IBFCAYZC/v///x+DIBJC/////w+DfnwiETcDACAAIA1BA3RqIgUgESAFKQMAhUIgiSIRNwMAIAAgCUEDdGoiCSARIAkpAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAEgESABKQMAhUIoiSIRNwMAIBMgESATKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACAFIBEgBSkDAIVCMIkiETcDACAJIBEgCSkDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgASARIAEpAwCFQgGJNwMAIAAgAkEDdGoiDSANKQMAIhEgACAGQQN0aiICKQMAIhJ8IBFCAYZC/v///x+DIBJC/////w+DfnwiETcDACAAIA5BA3RqIgYgESAGKQMAhUIgiSIRNwMAIAAgCkEDdGoiCiARIAopAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAIgESACKQMAhUIoiSIRNwMAIA0gESANKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACAGIBEgBikDAIVCMIkiETcDACAKIBEgCikDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgAiARIAIpAwCFQgGJNwMAIAAgA0EDdGoiDiAOKQMAIhEgACAHQQN0aiIDKQMAIhJ8IBFCAYZC/v///x+DIBJC/////w+DfnwiETcDACAAIA9BA3RqIgcgESAHKQMAhUIgiSIRNwMAIAAgC0EDdGoiCyARIAspAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAMgESADKQMAhUIoiSIRNwMAIA4gESAOKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACAHIBEgBykDAIVCMIkiETcDACALIBEgCykDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgAyARIAMpAwCFQgGJNwMAIAAgBEEDdGoiDyAPKQMAIhEgACAIQQN0aiIEKQMAIhJ8IBFCAYZC/v///x+DIBJC/////w+DfnwiETcDACAAIBBBA3RqIgggESAIKQMAhUIgiSIRNwMAIAAgDEEDdGoiACARIAApAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAQgESAEKQMAhUIoiSIRNwMAIA8gESAPKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACAIIBEgCCkDAIVCMIkiETcDACAAIBEgACkDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgBCARIAQpAwCFQgGJNwMAIBMgEykDACIRIAIpAwAiEnwgEUIBhkL+////H4MgEkL/////D4N+fCIRNwMAIAggESAIKQMAhUIgiSIRNwMAIAsgESALKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACACIBEgAikDAIVCKIkiETcDACATIBEgEykDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgCCARIAgpAwCFQjCJIhE3AwAgCyARIAspAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAIgESACKQMAhUIBiTcDACANIA0pAwAiESADKQMAIhJ8IBFCAYZC/v///x+DIBJC/////w+DfnwiETcDACAFIBEgBSkDAIVCIIkiETcDACAAIBEgACkDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgAyARIAMpAwCFQiiJIhE3AwAgDSARIA0pAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAUgESAFKQMAhUIwiSIRNwMAIAAgESAAKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACADIBEgAykDAIVCAYk3AwAgDiAOKQMAIhEgBCkDACISfCARQgGGQv7///8fgyASQv////8Pg358IhE3AwAgBiARIAYpAwCFQiCJIhE3AwAgCSARIAkpAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAQgESAEKQMAhUIoiSIRNwMAIA4gESAOKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACAGIBEgBikDAIVCMIkiETcDACAJIBEgCSkDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgBCARIAQpAwCFQgGJNwMAIA8gDykDACIRIAEpAwAiEnwgEUIBhkL+////H4MgEkL/////D4N+fCIRNwMAIAcgESAHKQMAhUIgiSIRNwMAIAogESAKKQMAIhJ8IBFC/////w+DIBJCAYZC/v///x+DfnwiETcDACABIBEgASkDAIVCKIkiETcDACAPIBEgDykDACISfCARQv////8PgyASQgGGQv7///8fg358IhE3AwAgByARIAcpAwCFQjCJIhE3AwAgCiARIAopAwAiEnwgEUL/////D4MgEkIBhkL+////H4N+fCIRNwMAIAEgESABKQMAhUIBiTcDAAvdCAEPfwNAIAIgBUEDdCIGaiABIAZqKQMAIAAgBmopAwCFNwMAIAIgBkEIciIGaiABIAZqKQMAIAAgBmopAwCFNwMAIAVBAmoiBUGAAUcNAAsDQCADIARBA3QiAGogACACaikDADcDACADIARBAXIiAEEDdCIBaiABIAJqKQMANwMAIAMgBEECciIBQQN0IgVqIAIgBWopAwA3AwAgAyAEQQNyIgVBA3QiBmogAiAGaikDADcDACADIARBBHIiBkEDdCIHaiACIAdqKQMANwMAIAMgBEEFciIHQQN0IghqIAIgCGopAwA3AwAgAyAEQQZyIghBA3QiCWogAiAJaikDADcDACADIARBB3IiCUEDdCIKaiACIApqKQMANwMAIAMgBEEIciIKQQN0IgtqIAIgC2opAwA3AwAgAyAEQQlyIgtBA3QiDGogAiAMaikDADcDACADIARBCnIiDEEDdCINaiACIA1qKQMANwMAIAMgBEELciINQQN0Ig5qIAIgDmopAwA3AwAgAyAEQQxyIg5BA3QiD2ogAiAPaikDADcDACADIARBDXIiD0EDdCIQaiACIBBqKQMANwMAIAMgBEEOciIQQQN0IhFqIAIgEWopAwA3AwAgAyAEQQ9yIhFBA3QiEmogAiASaikDADcDACADIARB//8DcSAAQf//A3EgAUH//wNxIAVB//8DcSAGQf//A3EgB0H//wNxIAhB//8DcSAJQf//A3EgCkH//wNxIAtB//8DcSAMQf//A3EgDUH//wNxIA5B//8DcSAPQf//A3EgEEH//wNxIBFB//8DcRACIARB8ABJIQAgBEEQaiEEIAANAAtBACEBIANBAEEBQRBBEUEgQSFBMEExQcAAQcEAQdAAQdEAQeAAQeEAQfAAQfEAEAIgA0ECQQNBEkETQSJBI0EyQTNBwgBBwwBB0gBB0wBB4gBB4wBB8gBB8wAQAiADQQRBBUEUQRVBJEElQTRBNUHEAEHFAEHUAEHVAEHkAEHlAEH0AEH1ABACIANBBkEHQRZBF0EmQSdBNkE3QcYAQccAQdYAQdcAQeYAQecAQfYAQfcAEAIgA0EIQQlBGEEZQShBKUE4QTlByABByQBB2ABB2QBB6ABB6QBB+ABB+QAQAiADQQpBC0EaQRtBKkErQTpBO0HKAEHLAEHaAEHbAEHqAEHrAEH6AEH7ABACIANBDEENQRxBHUEsQS1BPEE9QcwAQc0AQdwAQd0AQewAQe0AQfwAQf0AEAIgA0EOQQ9BHkEfQS5BL0E+QT9BzgBBzwBB3gBB3wBB7gBB7wBB/gBB/wAQAgNAIAIgAUEDdCIAaiIEIAAgA2opAwAgBCkDAIU3AwAgAiAAQQhyIgRqIgUgAyAEaikDACAFKQMAhTcDACACIABBEHIiBGoiBSADIARqKQMAIAUpAwCFNwMAIAIgAEEYciIAaiIEIAAgA2opAwAgBCkDAIU3AwAgAUEEaiIBQYABRw0ACwsWACAAIAEgAiADEAMgACACIAIgAxADC3sCAX8BfiACIQkgATUCACEKIAQgBXIEQCABKAIEIANwIQkLIAAgCTYCACAAIAdBAWsgBSAEGyAIbCAGQQFrQQBBfyAGGyACIAlGG2oiASAFQQFqIAhsQQAgBBtqIAGtIAogCn5CIIh+QiCIp0F/c2ogByAIbHA2AgQgAAsEACMACwYAIAAkAAsQACMAIABrQXBxIgAkACAACwUAQYAICw==",w)))}),Tf=[0,1,3,7,15,31,63,127,255],Ny=function(w){this.stream=w,this.bitOffset=0,this.curByte=0,this.hasByte=!1};Ny.prototype._ensureByte=function(){this.hasByte||(this.curByte=this.stream.readByte(),this.hasByte=!0)},Ny.prototype.read=function(w){for(var O=0;w>0;){this._ensureByte();var _=8-this.bitOffset;if(w>=_)O<<=_,O|=Tf[_]&this.curByte,this.hasByte=!1,this.bitOffset=0,w-=_;else{O<<=w;var N=_-w;O|=(this.curByte&Tf[w]<<N)>>N,this.bitOffset+=w,w=0}}return O},Ny.prototype.seek=function(w){var O=w%8,_=(w-O)/8;this.bitOffset=O,this.stream.seek(_),this.hasByte=!1},Ny.prototype.pi=function(){var w,O=new Uint8Array(6);for(w=0;w<O.length;w++)O[w]=this.read(8);return function(w){return Array.prototype.map.call(w,(w=>("00"+w.toString(16)).slice(-2))).join("")}(O)};var Qf=Ny,Oy=function(){};Oy.prototype.readByte=function(){throw Error("abstract method readByte() not implemented")},Oy.prototype.read=function(w,O,_){for(var N=0;N<_;){var F=this.readByte();if(F<0)return 0===N?-1:N;w[O++]=F,N++}return N},Oy.prototype.seek=function(w){throw Error("abstract method seek() not implemented")},Oy.prototype.writeByte=function(w){throw Error("abstract method readByte() not implemented")},Oy.prototype.write=function(w,O,_){var N;for(N=0;N<_;N++)this.writeByte(w[O++]);return _},Oy.prototype.flush=function(){};var Mf,Lf=Oy,Nf=(Mf=new Uint32Array([0,79764919,159529838,222504665,319059676,398814059,445009330,507990021,638119352,583659535,797628118,726387553,890018660,835552979,1015980042,944750013,1276238704,1221641927,1167319070,1095957929,1595256236,1540665371,1452775106,1381403509,1780037320,1859660671,1671105958,1733955601,2031960084,2111593891,1889500026,1952343757,2552477408,2632100695,2443283854,2506133561,2334638140,2414271883,2191915858,2254759653,3190512472,3135915759,3081330742,3009969537,2905550212,2850959411,2762807018,2691435357,3560074640,3505614887,3719321342,3648080713,3342211916,3287746299,3467911202,3396681109,4063920168,4143685023,4223187782,4286162673,3779000052,3858754371,3904687514,3967668269,881225847,809987520,1023691545,969234094,662832811,591600412,771767749,717299826,311336399,374308984,453813921,533576470,25881363,88864420,134795389,214552010,2023205639,2086057648,1897238633,1976864222,1804852699,1867694188,1645340341,1724971778,1587496639,1516133128,1461550545,1406951526,1302016099,1230646740,1142491917,1087903418,2896545431,2825181984,2770861561,2716262478,3215044683,3143675388,3055782693,3001194130,2326604591,2389456536,2200899649,2280525302,2578013683,2640855108,2418763421,2498394922,3769900519,3832873040,3912640137,3992402750,4088425275,4151408268,4197601365,4277358050,3334271071,3263032808,3476998961,3422541446,3585640067,3514407732,3694837229,3640369242,1762451694,1842216281,1619975040,1682949687,2047383090,2127137669,1938468188,2001449195,1325665622,1271206113,1183200824,1111960463,1543535498,1489069629,1434599652,1363369299,622672798,568075817,748617968,677256519,907627842,853037301,1067152940,995781531,51762726,131386257,177728840,240578815,269590778,349224269,429104020,491947555,4046411278,4126034873,4172115296,4234965207,3794477266,3874110821,3953728444,4016571915,3609705398,3555108353,3735388376,3664026991,3290680682,3236090077,3449943556,3378572211,3174993278,3120533705,3032266256,2961025959,2923101090,2868635157,2813903052,2742672763,2604032198,2683796849,2461293480,2524268063,2284983834,2364738477,2175806836,2238787779,1569362073,1498123566,1409854455,1355396672,1317987909,1246755826,1192025387,1137557660,2072149281,2135122070,1912620623,1992383480,1753615357,1816598090,1627664531,1707420964,295390185,358241886,404320391,483945776,43990325,106832002,186451547,266083308,932423249,861060070,1041341759,986742920,613929101,542559546,756411363,701822548,3316196985,3244833742,3425377559,3370778784,3601682597,3530312978,3744426955,3689838204,3819031489,3881883254,3928223919,4007849240,4037393693,4100235434,4180117107,4259748804,2310601993,2373574846,2151335527,2231098320,2596047829,2659030626,2470359227,2550115596,2947551409,2876312838,2788305887,2733848168,3165939309,3094707162,3040238851,2985771188]),function(){var w=4294967295;this.getCRC=function(){return~w>>>0},this.updateCRC=function(O){w=w<<8^Mf[255&(w>>>24^O)]},this.updateCRCRun=function(O,_){for(;_-- >0;)w=w<<8^Mf[255&(w>>>24^O)]}}),Ff=Qf,Hf=Lf,jf=Nf,Vy=function(w,O){var _,N=w[O];for(_=O;_>0;_--)w[_]=w[_-1];return w[0]=N,N},Gf={OK:0,LAST_BLOCK:-1,NOT_BZIP_DATA:-2,UNEXPECTED_INPUT_EOF:-3,UNEXPECTED_OUTPUT_EOF:-4,DATA_ERROR:-5,OUT_OF_MEMORY:-6,OBSOLETE_INPUT:-7,END_OF_BLOCK:-8},zf={};zf[Gf.LAST_BLOCK]="Bad file checksum",zf[Gf.NOT_BZIP_DATA]="Not bzip data",zf[Gf.UNEXPECTED_INPUT_EOF]="Unexpected input EOF",zf[Gf.UNEXPECTED_OUTPUT_EOF]="Unexpected output EOF",zf[Gf.DATA_ERROR]="Data error",zf[Gf.OUT_OF_MEMORY]="Out of memory",zf[Gf.OBSOLETE_INPUT]="Obsolete (pre 0.9.5) bzip format not supported.";var Zy=function(w,O){var _=zf[w]||"unknown error";O&&(_+=": "+O);var N=new TypeError(_);throw N.errorCode=w,N},Wy=function(w,O){this.writePos=this.writeCurrent=this.writeCount=0,this._start_bunzip(w,O)};Wy.prototype._init_block=function(){return this._get_next_block()?(this.blockCRC=new jf,!0):(this.writeCount=-1,!1)},Wy.prototype._start_bunzip=function(w,O){var _=new Uint8Array(4);4===w.read(_,0,4)&&"BZh"===String.fromCharCode(_[0],_[1],_[2])||Zy(Gf.NOT_BZIP_DATA,"bad magic");var N=_[3]-48;(N<1||N>9)&&Zy(Gf.NOT_BZIP_DATA,"level out of range"),this.reader=new Ff(w),this.dbufSize=1e5*N,this.nextoutput=0,this.outputStream=O,this.streamCRC=0},Wy.prototype._get_next_block=function(){var w,O,_,N=this.reader,F=N.pi();if("177245385090"===F)return!1;"314159265359"!==F&&Zy(Gf.NOT_BZIP_DATA),this.targetBlockCRC=N.read(32)>>>0,this.streamCRC=(this.targetBlockCRC^(this.streamCRC<<1|this.streamCRC>>>31))>>>0,N.read(1)&&Zy(Gf.OBSOLETE_INPUT);var H=N.read(24);H>this.dbufSize&&Zy(Gf.DATA_ERROR,"initial position out of bounds");var j=N.read(16),G=new Uint8Array(256),z=0;for(w=0;w<16;w++)if(j&1<<15-w){var X=16*w;for(_=N.read(16),O=0;O<16;O++)_&1<<15-O&&(G[z++]=X+O)}var ee=N.read(3);(ee<2||ee>6)&&Zy(Gf.DATA_ERROR);var se=N.read(15);0===se&&Zy(Gf.DATA_ERROR);var ae=new Uint8Array(256);for(w=0;w<ee;w++)ae[w]=w;var Ae=new Uint8Array(se);for(w=0;w<se;w++){for(O=0;N.read(1);O++)O>=ee&&Zy(Gf.DATA_ERROR);Ae[w]=Vy(ae,O)}var be,ve=z+2,Se=[];for(O=0;O<ee;O++){var Ie,Be,Pe=new Uint8Array(ve),xe=new Uint16Array(21);for(j=N.read(5),w=0;w<ve;w++){for(;(j<1||j>20)&&Zy(Gf.DATA_ERROR),N.read(1);)N.read(1)?j--:j++;Pe[w]=j}for(Ie=Be=Pe[0],w=1;w<ve;w++)Pe[w]>Be?Be=Pe[w]:Pe[w]<Ie&&(Ie=Pe[w]);be={},Se.push(be),be.permute=new Uint16Array(258),be.limit=new Uint32Array(22),be.base=new Uint32Array(21),be.minLen=Ie,be.maxLen=Be;var De=0;for(w=Ie;w<=Be;w++)for(xe[w]=be.limit[w]=0,j=0;j<ve;j++)Pe[j]===w&&(be.permute[De++]=j);for(w=0;w<ve;w++)xe[Pe[w]]++;for(De=j=0,w=Ie;w<Be;w++)De+=xe[w],be.limit[w]=De-1,De<<=1,j+=xe[w],be.base[w+1]=De-j;be.limit[Be+1]=Number.MAX_VALUE,be.limit[Be]=De+xe[Be]-1,be.base[Ie]=0}var Ue=new Uint32Array(256);for(w=0;w<256;w++)ae[w]=w;var Oe,_e=0,Re=0,Te=0,Qe=this.dbuf=new Uint32Array(this.dbufSize);for(ve=0;;){for(ve--||(ve=49,Te>=se&&Zy(Gf.DATA_ERROR),be=Se[Ae[Te++]]),w=be.minLen,O=N.read(w);w>be.maxLen&&Zy(Gf.DATA_ERROR),!(O<=be.limit[w]);w++)O=O<<1|N.read(1);((O-=be.base[w])<0||O>=258)&&Zy(Gf.DATA_ERROR);var Me=be.permute[O];if(0!==Me&&1!==Me){if(_e)for(_e=0,Re+j>this.dbufSize&&Zy(Gf.DATA_ERROR),Ue[Oe=G[ae[0]]]+=j;j--;)Qe[Re++]=Oe;if(Me>z)break;Re>=this.dbufSize&&Zy(Gf.DATA_ERROR),Ue[Oe=G[Oe=Vy(ae,w=Me-1)]]++,Qe[Re++]=Oe}else _e||(_e=1,j=0),j+=0===Me?_e:2*_e,_e<<=1}for((H<0||H>=Re)&&Zy(Gf.DATA_ERROR),O=0,w=0;w<256;w++)_=O+Ue[w],Ue[w]=O,O=_;for(w=0;w<Re;w++)Qe[Ue[Oe=255&Qe[w]]]|=w<<8,Ue[Oe]++;var Le=0,je=0,qe=0;return Re&&(je=255&(Le=Qe[H]),Le>>=8,qe=-1),this.writePos=Le,this.writeCurrent=je,this.writeCount=Re,this.writeRun=qe,!0},Wy.prototype._read_bunzip=function(w,O){var _,N,F;if(this.writeCount<0)return 0;var H=this.dbuf,j=this.writePos,G=this.writeCurrent,z=this.writeCount;this.outputsize;for(var X=this.writeRun;z;){for(z--,N=G,G=255&(j=H[j]),j>>=8,3==X++?(_=G,F=N,G=-1):(_=1,F=G),this.blockCRC.updateCRCRun(F,_);_--;)this.outputStream.writeByte(F),this.nextoutput++;G!=N&&(X=0)}return this.writeCount=z,this.blockCRC.getCRC()!==this.targetBlockCRC&&Zy(Gf.DATA_ERROR,"Bad block CRC (got "+this.blockCRC.getCRC().toString(16)+" expected "+this.targetBlockCRC.toString(16)+")"),this.nextoutput};var $y=function(w){if("readByte"in w)return w;var O=new Hf;return O.pos=0,O.readByte=function(){return w[this.pos++]},O.seek=function(w){this.pos=w},O.eof=function(){return this.pos>=w.length},O},Xy=function(w){var O=new Hf,_=!0;if(w)if("number"==typeof w)O.buffer=new Uint8Array(w),_=!1;else{if("writeByte"in w)return w;O.buffer=w,_=!1}else O.buffer=new Uint8Array(16384);return O.pos=0,O.writeByte=function(w){if(_&&this.pos>=this.buffer.length){var O=new Uint8Array(2*this.buffer.length);O.set(this.buffer),this.buffer=O}this.buffer[this.pos++]=w},O.getBuffer=function(){if(this.pos!==this.buffer.length){if(!_)throw new TypeError("outputsize does not match decoded input");var w=new Uint8Array(this.pos);w.set(this.buffer.subarray(0,this.pos)),this.buffer=w}return this.buffer},O._coerced=!0,O};var qf={Bunzip:Wy,Stream:Hf,Err:Gf,decode:function(w,O,_){for(var N=$y(w),F=Xy(O),H=new Wy(N,F);!("eof"in N)||!N.eof();)if(H._init_block())H._read_bunzip();else{var j=H.reader.read(32)>>>0;if(j!==H.streamCRC&&Zy(Gf.DATA_ERROR,"Bad stream CRC (got "+H.streamCRC.toString(16)+" expected "+j.toString(16)+")"),!_||!("eof"in N)||N.eof())break;H._start_bunzip(N,F)}if("getBuffer"in F)return F.getBuffer()},decodeBlock:function(w,O,_){var N=$y(w),F=Xy(_),H=new Wy(N,F);if(H.reader.seek(O),H._get_next_block()&&(H.blockCRC=new jf,H.writeCopies=0,H._read_bunzip()),"getBuffer"in F)return F.getBuffer()},table:function(w,O,_){var N=new Hf;N.delegate=$y(w),N.pos=0,N.readByte=function(){return this.pos++,this.delegate.readByte()},N.delegate.eof&&(N.eof=N.delegate.eof.bind(N.delegate));var F=new Hf;F.pos=0,F.writeByte=function(){this.pos++};for(var H=new Wy(N,F),j=H.dbufSize;!("eof"in N)||!N.eof();){var G=8*N.pos+H.reader.bitOffset;if(H.reader.hasByte&&(G-=8),H._init_block()){var z=F.pos;H._read_bunzip(),O(G,F.pos-z)}else{if(H.reader.read(32),!_||!("eof"in N)||N.eof())break;H._start_bunzip(N,F),console.assert(H.dbufSize===j,"shouldn't change block size within multistream file")}}}},$f=s({__proto__:null},[qf]);O.AEADEncryptedDataPacket=Ja,O.CleartextMessage=Go,O.CompressedDataPacket=Na,O.LiteralDataPacket=Sa,O.MarkerPacket=class{static get tag(){return ve.packet.marker}read(w){return 80===w[0]&&71===w[1]&&80===w[2]}write(){return new Uint8Array([80,71,80])}},O.Message=Fo,O.OnePassSignaturePacket=Ra,O.PacketList=La,O.PaddingPacket=class{static get tag(){return ve.packet.padding}constructor(){this.padding=null}read(w){}write(){return this.padding}async createPadding(w){this.padding=await we(w)}},O.PrivateKey=xo,O.PublicKey=Po,O.PublicKeyEncryptedSessionKeyPacket=Ya,O.PublicKeyPacket=$a,O.PublicSubkeyPacket=to,O.SecretKeyPacket=no,O.SecretSubkeyPacket=ao,O.Signature=co,O.SignaturePacket=Pa,O.Subkey=So,O.SymEncryptedIntegrityProtectedDataPacket=ja,O.SymEncryptedSessionKeyPacket=Wa,O.SymmetricallyEncryptedDataPacket=eo,O.TrustPacket=class{static get tag(){return ve.packet.trust}read(){throw new er("Trust packets are not supported")}write(){throw new er("Trust packets are not supported")}},O.UnparseablePacket=rr,O.UserAttributePacket=ro,O.UserIDPacket=so,O.armor=ie,O.config=Se,O.createCleartextMessage=async function({text:w,...O}){if(!w)throw Error("createCleartextMessage: must pass options object containing `text`");if(!Be.isString(w))throw Error("createCleartextMessage: options.text must be a string");const _=Object.keys(O);if(_.length>0)throw Error("Unknown option: "+_.join(", "));return new Go(w)},O.createMessage=async function({text:w,binary:O,filename:_,date:N=new Date,format:F=(void 0!==w?"utf8":"binary"),...H}){const j=void 0!==w?w:O;if(void 0===j)throw Error("createMessage: must pass options object containing `text` or `binary`");if(w&&!Be.isString(w)&&!Be.isStream(w))throw Error("createMessage: options.text must be a string or stream");if(O&&!Be.isUint8Array(O)&&!Be.isStream(O))throw Error("createMessage: options.binary must be a Uint8Array or stream");const G=Object.keys(H);if(G.length>0)throw Error("Unknown option: "+G.join(", "));const z=Be.isStream(j),X=new Sa(N);void 0!==w?X.setText(j,ve.write(ve.literal,F)):X.setBytes(j,ve.write(ve.literal,F)),void 0!==_&&X.setFilename(_);const ee=new La;ee.push(X);const se=new Fo(ee);return se.fromStream=z,se},O.decrypt=async function({message:w,decryptionKeys:O,passwords:_,sessionKeys:N,verificationKeys:F,expectSigned:H=!1,format:j="utf8",signature:G=null,date:z=new Date,config:X,...ee}){if(Jo(X={...Se,...X}),_o(w),F=Yo(F),O=Yo(O),_=Yo(_),N=Yo(N),ee.privateKeys)throw Error("The `privateKeys` option has been removed from openpgp.decrypt, pass `decryptionKeys` instead");if(ee.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.decrypt, pass `verificationKeys` instead");const se=Object.keys(ee);if(se.length>0)throw Error("Unknown option: "+se.join(", "));try{const ee=await w.decrypt(O,_,N,z,X);F||(F=[]);const se={};if(se.signatures=G?await ee.verifyDetached(G,F,z,X):await ee.verify(F,z,X),se.data="binary"===j?ee.getLiteralData():ee.getText(),se.filename=ee.getFilename(),Wo(se,w),H){if(0===F.length)throw Error("Verification keys are required to verify message signatures");if(0===se.signatures.length)throw Error("Message is not signed");se.data=E([se.data,T((async()=>(await Be.anyPromise(se.signatures.map((w=>w.verified))),"binary"===j?new Uint8Array:"")))])}return se.data=await Zo(se.data),se}catch(w){throw Be.wrapError("Error decrypting message",w)}},O.decryptKey=async function({privateKey:w,passphrase:O,config:_,...N}){Jo(_={...Se,..._});const F=Object.keys(N);if(F.length>0)throw Error("Unknown option: "+F.join(", "));if(!w.isPrivate())throw Error("Cannot decrypt a public key");const H=w.clone(!0),j=Be.isArray(O)?O:[O];try{return await Promise.all(H.getKeys().map((w=>Be.anyPromise(j.map((O=>w.keyPacket.decrypt(O))))))),await H.validate(_),H}catch(w){throw H.clearPrivateParams(),Be.wrapError("Error decrypting private key",w)}},O.decryptSessionKeys=async function({message:w,decryptionKeys:O,passwords:_,date:N=new Date,config:F,...H}){if(Jo(F={...Se,...F}),_o(w),O=Yo(O),_=Yo(_),H.privateKeys)throw Error("The `privateKeys` option has been removed from openpgp.decryptSessionKeys, pass `decryptionKeys` instead");const j=Object.keys(H);if(j.length>0)throw Error("Unknown option: "+j.join(", "));try{return await w.decryptSessionKeys(O,_,void 0,N,F)}catch(w){throw Be.wrapError("Error decrypting session keys",w)}},O.encrypt=async function({message:w,encryptionKeys:O,signingKeys:_,passwords:N,sessionKey:F,format:H="armored",signature:j=null,wildcard:G=!1,signingKeyIDs:z=[],encryptionKeyIDs:X=[],date:ee=new Date,signingUserIDs:se=[],encryptionUserIDs:ae=[],signatureNotations:Ae=[],config:be,...Ie}){if(Jo(be={...Se,...be}),_o(w),qo(H),O=Yo(O),_=Yo(_),N=Yo(N),z=Yo(z),X=Yo(X),se=Yo(se),ae=Yo(ae),Ae=Yo(Ae),Ie.detached)throw Error("The `detached` option has been removed from openpgp.encrypt, separately call openpgp.sign instead. Don't forget to remove the `privateKeys` option as well.");if(Ie.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.encrypt, pass `encryptionKeys` instead");if(Ie.privateKeys)throw Error("The `privateKeys` option has been removed from openpgp.encrypt, pass `signingKeys` instead");if(void 0!==Ie.armor)throw Error("The `armor` option has been removed from openpgp.encrypt, pass `format` instead.");const Pe=Object.keys(Ie);if(Pe.length>0)throw Error("Unknown option: "+Pe.join(", "));_||(_=[]);try{if((_.length||j)&&(w=await w.sign(_,O,j,z,ee,se,X,Ae,be)),w=w.compress(await async function(w=[],O=new Date,_=[],N=Se){const F=ve.compression.uncompressed,H=N.preferredCompressionAlgorithm,j=await Promise.all(w.map((async function(w,F){const j=(await w.getPrimarySelfSignature(O,_[F],N)).preferredCompressionAlgorithms;return!!j&&j.indexOf(H)>=0})));return j.every(Boolean)?H:F}(O,ee,ae,be),be),w=await w.encrypt(O,N,F,G,X,ee,ae,be),"object"===H)return w;const Ie="armored"===H?w.armor(be):w.write();return await Zo(Ie)}catch(w){throw Be.wrapError("Error encrypting message",w)}},O.encryptKey=async function({privateKey:w,passphrase:O,config:_,...N}){Jo(_={...Se,..._});const F=Object.keys(N);if(F.length>0)throw Error("Unknown option: "+F.join(", "));if(!w.isPrivate())throw Error("Cannot encrypt a public key");const H=w.clone(!0),j=H.getKeys(),G=Be.isArray(O)?O:Array(j.length).fill(O);if(G.length!==j.length)throw Error("Invalid number of passphrases given for key encryption");try{return await Promise.all(j.map((async(w,O)=>{const{keyPacket:N}=w;await N.encrypt(G[O],_),N.clearPrivateParams()}))),H}catch(w){throw H.clearPrivateParams(),Be.wrapError("Error encrypting private key",w)}},O.encryptSessionKey=async function({data:w,algorithm:O,aeadAlgorithm:_,encryptionKeys:N,passwords:F,format:H="armored",wildcard:j=!1,encryptionKeyIDs:G=[],date:z=new Date,encryptionUserIDs:X=[],config:ee,...se}){if(Jo(ee={...Se,...ee}),function(w){if(!Be.isUint8Array(w))throw Error("Parameter [data] must be of type Uint8Array")}(w),function(w,O){if(!Be.isString(w))throw Error("Parameter ["+O+"] must be of type String")}(O,"algorithm"),qo(H),N=Yo(N),F=Yo(F),G=Yo(G),X=Yo(X),se.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.encryptSessionKey, pass `encryptionKeys` instead");const ae=Object.keys(se);if(ae.length>0)throw Error("Unknown option: "+ae.join(", "));if(!(N&&0!==N.length||F&&0!==F.length))throw Error("No encryption keys or passwords provided.");try{return $o(await Fo.encryptSessionKey(w,O,_,N,F,j,G,z,X,ee),H,ee)}catch(w){throw Be.wrapError("Error encrypting session key",w)}},O.enums=ve,O.generateKey=async function({userIDs:w=[],passphrase:O,type:_,curve:N,rsaBits:F=4096,keyExpirationTime:H=0,date:j=new Date,subkeys:G=[{}],format:z="armored",config:X,...ee}){Jo(X={...Se,...X}),_||N?(_=_||"ecc",N=N||"curve25519Legacy"):(_=X.v6Keys?"curve25519":"ecc",N="curve25519Legacy"),w=Yo(w);const se=Object.keys(ee);if(se.length>0)throw Error("Unknown option: "+se.join(", "));if(0===w.length&&!X.v6Keys)throw Error("UserIDs are required for V4 keys");if("rsa"===_&&F<X.minRSABits)throw Error(`rsaBits should be at least ${X.minRSABits}, got: ${F}`);const ae={userIDs:w,passphrase:O,type:_,rsaBits:F,curve:N,keyExpirationTime:H,date:j,subkeys:G};try{const{key:w,revocationCertificate:O}=await async function(w,O){w.sign=!0,(w=bo(w)).subkeys=w.subkeys.map(((O,_)=>bo(w.subkeys[_],w)));let _=[uo(w,O)];_=_.concat(w.subkeys.map((w=>ho(w,O))));const N=await Promise.all(_),F=await To(N[0],N.slice(1),w,O),H=await F.getRevocationCertificate(w.date,O);return F.revocationSignatures=[],{key:F,revocationCertificate:H}}(ae,X);return w.getKeys().forEach((({keyPacket:w})=>Io(w,X))),{privateKey:$o(w,z,X),publicKey:$o(w.toPublic(),z,X),revocationCertificate:O}}catch(w){throw Be.wrapError("Error generating keypair",w)}},O.generateSessionKey=async function({encryptionKeys:w,date:O=new Date,encryptionUserIDs:_=[],config:N,...F}){if(Jo(N={...Se,...N}),w=Yo(w),_=Yo(_),F.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.generateSessionKey, pass `encryptionKeys` instead");const H=Object.keys(F);if(H.length>0)throw Error("Unknown option: "+H.join(", "));try{return await Fo.generateSessionKey(w,O,_,N)}catch(w){throw Be.wrapError("Error generating session key",w)}},O.readCleartextMessage=async function({cleartextMessage:w,config:O,..._}){if(O={...Se,...O},!w)throw Error("readCleartextMessage: must pass options object containing `cleartextMessage`");if(!Be.isString(w))throw Error("readCleartextMessage: options.cleartextMessage must be a string");const N=Object.keys(_);if(N.length>0)throw Error("Unknown option: "+N.join(", "));const F=await ne(w);if(F.type!==ve.armor.signed)throw Error("No cleartext signed message.");const H=await La.fromBinary(F.data,Mc,O);!function(w,O){const r=function(w){const r=w=>O=>w.hashAlgorithm===O;for(let _=0;_<O.length;_++)if(O[_].constructor.tag===ve.packet.signature&&!w.some(r(O[_])))return!1;return!0},_=[];if(w.forEach((w=>{const O=w.match(/^Hash: (.+)$/);if(!O)throw Error('Only "Hash" header allowed in cleartext signed message');{const w=O[1].replace(/\s/g,"").split(",").map((w=>{try{return ve.write(ve.hash,w.toLowerCase())}catch(O){throw Error("Unknown hash algorithm in armor header: "+w.toLowerCase())}}));_.push(...w)}})),_.length&&!r(_))throw Error("Hash algorithm mismatch in armor header and signature")}(F.headers,H);const j=new co(H);return new Go(F.text,j)},O.readKey=async function({armoredKey:w,binaryKey:O,config:_,...N}){if(_={...Se,..._},!w&&!O)throw Error("readKey: must pass options object containing `armoredKey` or `binaryKey`");if(w&&!Be.isString(w))throw Error("readKey: options.armoredKey must be a string");if(O&&!Be.isUint8Array(O))throw Error("readKey: options.binaryKey must be a Uint8Array");const F=Object.keys(N);if(F.length>0)throw Error("Unknown option: "+F.join(", "));let H;if(w){const{type:O,data:_}=await ne(w);if(O!==ve.armor.publicKey&&O!==ve.armor.privateKey)throw Error("Armored text not of type key");H=_}else H=O;const j=await La.fromBinary(H,Cc,_),G=j.indexOfTag(ve.packet.publicKey,ve.packet.secretKey);if(0===G.length)throw Error("No key packet found");return Ro(j.slice(G[0],G[1]))},O.readKeys=async function({armoredKeys:w,binaryKeys:O,config:_,...N}){_={...Se,..._};let F=w||O;if(!F)throw Error("readKeys: must pass options object containing `armoredKeys` or `binaryKeys`");if(w&&!Be.isString(w))throw Error("readKeys: options.armoredKeys must be a string");if(O&&!Be.isUint8Array(O))throw Error("readKeys: options.binaryKeys must be a Uint8Array");const H=Object.keys(N);if(H.length>0)throw Error("Unknown option: "+H.join(", "));if(w){const{type:O,data:_}=await ne(w);if(O!==ve.armor.publicKey&&O!==ve.armor.privateKey)throw Error("Armored text not of type key");F=_}const j=[],G=await La.fromBinary(F,Cc,_),z=G.indexOfTag(ve.packet.publicKey,ve.packet.secretKey);if(0===z.length)throw Error("No key packet found");for(let w=0;w<z.length;w++){const O=Ro(G.slice(z[w],z[w+1]));j.push(O)}return j},O.readMessage=async function({armoredMessage:w,binaryMessage:O,config:_,...N}){_={...Se,..._};let F=w||O;if(!F)throw Error("readMessage: must pass options object containing `armoredMessage` or `binaryMessage`");if(w&&!Be.isString(w)&&!Be.isStream(w))throw Error("readMessage: options.armoredMessage must be a string or stream");if(O&&!Be.isUint8Array(O)&&!Be.isStream(O))throw Error("readMessage: options.binaryMessage must be a Uint8Array or stream");const H=Object.keys(N);if(H.length>0)throw Error("Unknown option: "+H.join(", "));const j=Be.isStream(F);if(w){const{type:w,data:O}=await ne(F);if(w!==ve.armor.message)throw Error("Armored text not of type message");F=O}const G=await La.fromBinary(F,Kc,_),z=new Fo(G);return z.fromStream=j,z},O.readPrivateKey=async function({armoredKey:w,binaryKey:O,config:_,...N}){if(_={...Se,..._},!w&&!O)throw Error("readPrivateKey: must pass options object containing `armoredKey` or `binaryKey`");if(w&&!Be.isString(w))throw Error("readPrivateKey: options.armoredKey must be a string");if(O&&!Be.isUint8Array(O))throw Error("readPrivateKey: options.binaryKey must be a Uint8Array");const F=Object.keys(N);if(F.length>0)throw Error("Unknown option: "+F.join(", "));let H;if(w){const{type:O,data:_}=await ne(w);if(O!==ve.armor.privateKey)throw Error("Armored text not of type private key");H=_}else H=O;const j=await La.fromBinary(H,Cc,_),G=j.indexOfTag(ve.packet.publicKey,ve.packet.secretKey);for(let w=0;w<G.length;w++){if(j[G[w]].constructor.tag===ve.packet.publicKey)continue;const O=j.slice(G[w],G[w+1]);return new xo(O)}throw Error("No secret key packet found")},O.readPrivateKeys=async function({armoredKeys:w,binaryKeys:O,config:_}){_={...Se,..._};let N=w||O;if(!N)throw Error("readPrivateKeys: must pass options object containing `armoredKeys` or `binaryKeys`");if(w&&!Be.isString(w))throw Error("readPrivateKeys: options.armoredKeys must be a string");if(O&&!Be.isUint8Array(O))throw Error("readPrivateKeys: options.binaryKeys must be a Uint8Array");if(w){const{type:O,data:_}=await ne(w);if(O!==ve.armor.privateKey)throw Error("Armored text not of type private key");N=_}const F=[],H=await La.fromBinary(N,Cc,_),j=H.indexOfTag(ve.packet.publicKey,ve.packet.secretKey);for(let w=0;w<j.length;w++){if(H[j[w]].constructor.tag===ve.packet.publicKey)continue;const O=H.slice(j[w],j[w+1]),_=new xo(O);F.push(_)}if(0===F.length)throw Error("No secret key packet found");return F},O.readSignature=async function({armoredSignature:w,binarySignature:O,config:_,...N}){_={...Se,..._};let F=w||O;if(!F)throw Error("readSignature: must pass options object containing `armoredSignature` or `binarySignature`");if(w&&!Be.isString(w))throw Error("readSignature: options.armoredSignature must be a string");if(O&&!Be.isUint8Array(O))throw Error("readSignature: options.binarySignature must be a Uint8Array");const H=Object.keys(N);if(H.length>0)throw Error("Unknown option: "+H.join(", "));if(w){const{type:w,data:O}=await ne(F);if(w!==ve.armor.signature)throw Error("Armored text not of type signature");F=O}const j=await La.fromBinary(F,mc,_);return new co(j)},O.reformatKey=async function({privateKey:w,userIDs:O=[],passphrase:_,keyExpirationTime:N=0,date:F,format:H="armored",config:j,...G}){Jo(j={...Se,...j}),O=Yo(O);const z=Object.keys(G);if(z.length>0)throw Error("Unknown option: "+z.join(", "));if(0===O.length&&6!==w.keyPacket.version)throw Error("UserIDs are required for V4 keys");const X={privateKey:w,userIDs:O,passphrase:_,keyExpirationTime:N,date:F};try{const{key:w,revocationCertificate:O}=await async function(w,O){w=o(w);const{privateKey:_}=w;if(!_.isPrivate())throw Error("Cannot reformat a public key");if(_.keyPacket.isDummy())throw Error("Cannot reformat a gnu-dummy primary key");if(!_.getKeys().every((({keyPacket:w})=>w.isDecrypted())))throw Error("Key is not decrypted");const N=_.keyPacket;w.subkeys||(w.subkeys=await Promise.all(_.subkeys.map((async w=>{const _=w.keyPacket,F={key:N,bind:_},H=await lo(w.bindingSignatures,N,ve.signature.subkeyBinding,F,null,O).catch((()=>({})));return{sign:H.keyFlags&&H.keyFlags[0]&ve.keyFlags.signData}}))));const F=_.subkeys.map((w=>w.keyPacket));if(w.subkeys.length!==F.length)throw Error("Number of subkey options does not match number of subkeys");w.subkeys=w.subkeys.map((O=>o(O,w)));const H=await To(N,F,w,O),j=await H.getRevocationCertificate(w.date,O);return H.revocationSignatures=[],{key:H,revocationCertificate:j};function o(w,O={}){return w.keyExpirationTime=w.keyExpirationTime||O.keyExpirationTime,w.passphrase=Be.isString(w.passphrase)?w.passphrase:O.passphrase,w.date=w.date||O.date,w}}(X,j);return{privateKey:$o(w,H,j),publicKey:$o(w.toPublic(),H,j),revocationCertificate:O}}catch(w){throw Be.wrapError("Error reformatting keypair",w)}},O.revokeKey=async function({key:w,revocationCertificate:O,reasonForRevocation:_,date:N=new Date,format:F="armored",config:H,...j}){Jo(H={...Se,...H});const G=Object.keys(j);if(G.length>0)throw Error("Unknown option: "+G.join(", "));try{const j=O?await w.applyRevocationCertificate(O,N,H):await w.revoke(_,N,H);return j.isPrivate()?{privateKey:$o(j,F,H),publicKey:$o(j.toPublic(),F,H)}:{privateKey:null,publicKey:$o(j,F,H)}}catch(w){throw Be.wrapError("Error revoking key",w)}},O.sign=async function({message:w,signingKeys:O,recipientKeys:_=[],format:N="armored",detached:F=!1,signingKeyIDs:H=[],date:j=new Date,signingUserIDs:G=[],recipientUserIDs:z=[],signatureNotations:X=[],config:ee,...se}){if(Jo(ee={...Se,...ee}),jo(w),qo(N),O=Yo(O),H=Yo(H),G=Yo(G),_=Yo(_),z=Yo(z),X=Yo(X),se.privateKeys)throw Error("The `privateKeys` option has been removed from openpgp.sign, pass `signingKeys` instead");if(void 0!==se.armor)throw Error("The `armor` option has been removed from openpgp.sign, pass `format` instead.");const ae=Object.keys(se);if(ae.length>0)throw Error("Unknown option: "+ae.join(", "));if(w instanceof Go&&"binary"===N)throw Error("Cannot return signed cleartext message in binary format");if(w instanceof Go&&F)throw Error("Cannot detach-sign a cleartext message");if(!O||0===O.length)throw Error("No signing keys provided");try{let se;if(se=F?await w.signDetached(O,_,void 0,H,j,G,z,X,ee):await w.sign(O,_,void 0,H,j,G,z,X,ee),"object"===N)return se;return se="armored"===N?se.armor(ee):se.write(),F&&(se=K(w.packets.write(),(async(w,O)=>{await Promise.all([v(se,O),Q(w).catch((()=>{}))])}))),await Zo(se)}catch(w){throw Be.wrapError("Error signing message",w)}},O.unarmor=ne,O.verify=async function({message:w,verificationKeys:O,expectSigned:_=!1,format:N="utf8",signature:F=null,date:H=new Date,config:j,...G}){if(Jo(j={...Se,...j}),jo(w),O=Yo(O),G.publicKeys)throw Error("The `publicKeys` option has been removed from openpgp.verify, pass `verificationKeys` instead");const z=Object.keys(G);if(z.length>0)throw Error("Unknown option: "+z.join(", "));if(w instanceof Go&&"binary"===N)throw Error("Can't return cleartext message data as binary");if(w instanceof Go&&F)throw Error("Can't verify detached cleartext signature");try{const G={};if(G.signatures=F?await w.verifyDetached(F,O,H,j):await w.verify(O,H,j),G.data="binary"===N?w.getLiteralData():w.getText(),w.fromStream&&!F&&Wo(G,w),_){if(0===G.signatures.length)throw Error("Message is not signed");G.data=E([G.data,T((async()=>(await Be.anyPromise(G.signatures.map((w=>w.verified))),"binary"===N?new Uint8Array:"")))])}return G.data=await Zo(G.data),G}catch(w){throw Be.wrapError("Error verifying signed message",w)}}}};var O={};function __nccwpck_require__(_){var N=O[_];if(N!==undefined){return N.exports}var F=O[_]={exports:{}};var H=true;try{w[_].call(F.exports,F,F.exports,__nccwpck_require__);H=false}finally{if(H)delete O[_]}return F.exports}if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var _=__nccwpck_require__(399);module.exports=_})();
//# sourceMappingURL=index.js.map